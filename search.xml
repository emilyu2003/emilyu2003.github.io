<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java学习笔记2</title>
      <link href="/2022/02/26/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
      <url>/2022/02/26/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><ul><li>意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</li><li>主要解决：主要解决接口选择的问题。</li><li>何时使用：我们明确地计划不同条件下创建不同实例时。</li><li>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</li><li>关键代码：创建过程在其子类执行。</li><li>应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</li><li>优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</li><li>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</li></ul><h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。<br>接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承就是定义子类继承父类的特征和行为，使得子类可以拥有父类的属性和方法，从而起到代码复用的目的。</p><h4 id="向上转型（up-cast）"><a href="#向上转型（up-cast）" class="headerlink" title="向上转型（up cast）"></a>向上转型（up cast）</h4><p>在建立了继承关系之后，可以使用父类型去引用通过子类型创建的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类 名称 = <span class="keyword">new</span> 子类();</span><br></pre></td></tr></table></figure><p>但是，此时这个对象所用的方法还是父类中的方法。即父类型引用不能直接调用子类型对象特有的方法。</p><h4 id="向下转型（down-cast）"><a href="#向下转型（down-cast）" class="headerlink" title="向下转型（down cast）"></a>向下转型（down cast）</h4><p>Java 语言提供了一个特殊的关键词 instanceof 用来判断一个对象引用所指向的对象的创建类型是否为特定的某个类，一般写为 obj instanceof A，其中 obj 为一个对象引用，A 为一个类型（类或接口），这个表达式的取值结果为布尔型，如果 obj 的创建类型为 A，则结果为 true，否则为 false。</p><p>此时可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(对象引用 <span class="keyword">instanceof</span> 类型) &#123;</span><br><span class="line">类型 名称 = (类型)对象引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个错误"><a href="#一个错误" class="headerlink" title="一个错误"></a>一个错误</h4><p>记得对象随用随建！！！！如果在if外面定义，共用同一个对象，可能出现第二个覆盖第一个的情况…总之会有错，请随用随建！</p><h4 id="重新"><a href="#重新" class="headerlink" title="重新"></a>重新</h4><p>让子类重新实现一个在父类中已经实现的方法是面向对象的一个重要机制，称为方法重写。</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>引用类型相同，但创建类型不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引用类型 名称<span class="number">1</span> = <span class="keyword">new</span> 创建类型<span class="number">1</span>();</span><br><span class="line">引用类型 名称<span class="number">2</span> = <span class="keyword">new</span> 创建类型<span class="number">2</span>();</span><br></pre></td></tr></table></figure><h4 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 待排序的类名 <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;待排序的类名&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span> 待排序的类名(参数) &#123;</span><br><span class="line"><span class="keyword">this</span>.参数 = 参数;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> 待排序的对象(参数) &#123;</span><br><span class="line"><span class="keyword">return</span> 待排序的对象;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(待排序的类名 对象名)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.待排序的对象 &lt; 对象名) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">// this &lt; 对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.待排序的对象 &gt; 对象名) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line">Collections.sort(序列名称);</span><br></pre></td></tr></table></figure><hr><!--从这里开始，丢了很多内容。--><!--歪三已经记不得了，只记得有几段写的还挺不错，甚至可以用精彩形容。--><!--可一般不都是这样吗，一些不经意间的闪光出现在了错误的地点。--><!--只能狠自己喜欢保存吧。--><!--不想回忆了，当时明明记录了对于抽象类经实践后的突然醍醐灌顶的理解，现在呢，烟消云散了。--><!--真好。--><hr><h4 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h4><p>如果想在多个方法中都用到scanner去读入，若每次都重新实例化一个scanner则它们会拒绝读入然后卡死在那里。所以可以采取如下方式解决：<br>把scanner的实例化扔到主类里面主程序入口的外面，也就是如下的样子，并变成public，其他地方调用Main.scanner即可使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h4><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>那天我遇到了一个问题，发现我需要在父类中定义一个方法，因为他的儿子们要用。</p><p>但是，在父类面前，我却一点也写不出来，只好撂了一个空壳子在哪儿，等着子类重写。这种情况就是所谓，“父类抽象程度很高，以至于在父类中没有办法去编写一个实现具体功能的方法。”</p><p>所以这么看起来，留个空壳等后人来填，也是可行之举。</p><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>但是抽象类的限制有很多。比如这个方法只能存在于父类和他们的儿子中，别的类想要用就属于是痴心妄想了，或者这么说，“那么你就会触霉头了”。接口很大程度上放宽了这种限制，因此，我们可以写出可复用性更好的代码。</p><p>在编程的时候，接口和类创建文件的方式是一样的，每个接口都需要一个独立的.java文件，idea会很贴心的给你标出一个绿色带有“I”字的logo以示区别。哪里用，哪里implements即可。</p><p>接口可以作为引用类型，不可以作为创建类型。也就是说，你不能用接口类型来实例化一个对象，因为这样实例化的行为的概念过于抽象以至于实例化没有意义。</p><h4 id="一个大改进"><a href="#一个大改进" class="headerlink" title="一个大改进"></a>一个大改进</h4><p>曾经，我的代码极度冗长，因为未能好好理解多态的概念。</p><p>每种装备都要单独建立一个序列，因为在我的眼里，类型不同的对象不能扔到一起去呀，那样怎么处理啊。</p><p>但是转念一想，你个蒟蒻，你管他是什么类的，他们都是equipment类下的小子，统一管理就可以了，反正它都调用的是子类重写的方法，它是什么类型，不需要我操心。</p><p>你看，这就是多态啊。</p><h4 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h4><p>我向往自由，我要学面向抽象变成！我真是，我要被象抽死了！</p><h4 id="自定义排序-1"><a href="#自定义排序-1" class="headerlink" title="自定义排序"></a>自定义排序</h4><p>我们对需要被排序的对象所在的类进行操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 待排序对象类型 <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;待排序对象类型&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(待排序对象类型 o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.方法() &lt; o.方法()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 返回 -1 代表 this 小于 o</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.方法() &gt; other.方法()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回 1 代表 this 大于 o</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在需要被排序的数组那里，直接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(待排序对象组成的序列);</span><br></pre></td></tr></table></figure><h4 id="java类型表示范围"><a href="#java类型表示范围" class="headerlink" title="java类型表示范围"></a>java类型表示范围</h4><p>int：32位，-2,147,483,648（-2^31）到  2,147,483,647（2^31 - 1）<br>long：64位，-9,223,372,036,854,775,808（-2^63）到  9,223,372,036,854,775,807（2^63 -1）<br>不够用的时候一定要换BigInteger！<br>要不然就可以享受debug一天的快乐了hhh</p><hr><!--终于，补完了印象中的大部分内容。--><!--累了，洗洗睡吧！--><hr><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>jsonString.split方法，可以根据给定的分隔符来将字符串分割为若干个字符串；<br>jsonString.indexOf方法，可以在给定的字符串中搜索给定字符串出现的位置；<br>jsonString.substring方法，可以按照下表位置区间来从给定字符串截取子字符串;<br>然后真正关于正则表达式的部分，教程里可谓是春秋笔法呢。</p><p>所以我们求助菜鸟教程——</p><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>\</td><td>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如， <strong>n</strong>匹配字符 <strong>n</strong>。<strong>\n</strong> 匹配换行符。序列 <strong>\\** 匹配 *<em>\*</em> ，</strong>\(** 匹配 **(**。</td></tr><tr><td>^</td><td>匹配输入字符串开始的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，^ 还会与”\n”或”\r”之后的位置匹配。</td></tr><tr><td>$</td><td>匹配输入字符串结尾的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，$ 还会与”\n”或”\r”之前的位置匹配。</td></tr><tr><td>*</td><td>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</td></tr><tr><td>+</td><td>一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</td></tr><tr><td>?</td><td>零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</td></tr><tr><td>{<em>n</em>}</td><td><em>n</em> 是非负整数。正好匹配 <em>n</em> 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td></tr><tr><td>{<em>n</em>,}</td><td><em>n</em> 是非负整数。至少匹配 <em>n</em> 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。</td></tr><tr><td>{<em>n</em>,<em>m</em>}</td><td><em>m</em> 和 <em>n</em> 是非负整数，其中 <em>n</em> &lt;= <em>m</em>。匹配至少 <em>n</em> 次，至多 <em>m</em> 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td></tr><tr><td>?</td><td>当此字符紧随任何其他限定符（*、+、?、{<em>n</em>}、{<em>n</em>,}、{<em>n</em>,<em>m</em>}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</td></tr><tr><td>.</td><td>匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</td></tr><tr><td>(<em>pattern</em>)</td><td>匹配 <em>pattern</em> 并捕获该匹配的子表达式。可以使用 <strong>$0…$9</strong> 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。</td></tr><tr><td>(?:<em>pattern</em>)</td><td>匹配 <em>pattern</em> 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。</td></tr><tr><td>(?=<em>pattern</em>)</td><td>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 <em>pattern</em> 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr><tr><td>(?!<em>pattern</em>)</td><td>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 <em>pattern</em> 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr><tr><td><em>x</em>|<em>y</em></td><td>匹配 <em>x</em> 或 <em>y</em>。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。</td></tr><tr><td>[<em>xyz</em>]</td><td>字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</td></tr><tr><td>[^<em>xyz</em>]</td><td>反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</td></tr><tr><td>[<em>a-z</em>]</td><td>字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</td></tr><tr><td>[^<em>a-z</em>]</td><td>反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</td></tr><tr><td>\b</td><td>匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</td></tr><tr><td>\B</td><td>非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</td></tr><tr><td>\c<em>x</em></td><td>匹配 <em>x</em> 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。<em>x</em> 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</td></tr><tr><td>\d</td><td>数字字符匹配。等效于 [0-9]。</td></tr><tr><td>\D</td><td>非数字字符匹配。等效于 [^0-9]。</td></tr><tr><td>\f</td><td>换页符匹配。等效于 \x0c 和 \cL。</td></tr><tr><td>\n</td><td>换行符匹配。等效于 \x0a 和 \cJ。</td></tr><tr><td>\r</td><td>匹配一个回车符。等效于 \x0d 和 \cM。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</td></tr><tr><td>\t</td><td>制表符匹配。与 \x09 和 \cI 等效。</td></tr><tr><td>\v</td><td>垂直制表符匹配。与 \x0b 和 \cK 等效。</td></tr><tr><td>\w</td><td>匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</td></tr><tr><td>\W</td><td>与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</td></tr><tr><td>\x<em>n</em></td><td>匹配 <em>n</em>，此处的 <em>n</em> 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</td></tr><tr><td>*num*</td><td>匹配 <em>num</em>，此处的 <em>num</em> 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</td></tr><tr><td>*n*</td><td>标识一个八进制转义码或反向引用。如果 *n* 前面至少有 <em>n</em> 个捕获子表达式，那么 <em>n</em> 是反向引用。否则，如果 <em>n</em> 是八进制数 (0-7)，那么 <em>n</em> 是八进制转义码。</td></tr><tr><td>*nm*</td><td>标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 <em>nm</em> 个捕获子表达式，那么 <em>nm</em> 是反向引用。如果 *nm* 前面至少有 <em>n</em> 个捕获，则 <em>n</em> 是反向引用，后面跟有字符 <em>m</em>。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 <em>nm</em>，其中 <em>n</em> 和 <em>m</em> 是八进制数字 (0-7)。</td></tr><tr><td>\nml</td><td>当 <em>n</em> 是八进制数 (0-3)，<em>m</em> 和 <em>l</em> 是八进制数 (0-7) 时，匹配八进制转义码 <em>nml</em>。</td></tr><tr><td>\u<em>n</em></td><td>匹配 <em>n</em>，其中 <em>n</em> 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td></tr></tbody></table><p>匹配使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String content = <span class="string">&quot;I am noob &quot;</span> +  <span class="string">&quot;from runoob.com.&quot;</span>;</span><br><span class="line"> </span><br><span class="line">String pattern = <span class="string">&quot;.*runoob.*&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isMatch = Pattern.matches(pattern, content);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串中是否包含了 &#x27;runoob&#x27; 子字符串? &quot;</span> + isMatch);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>更厉害的一种操作叫：</p><h5 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h5><h6 id="普通捕获组"><a href="#普通捕获组" class="headerlink" title="普通捕获组"></a>普通捕获组</h6><p>从正则表达式左侧开始，每出现一个左括号”(“记做一个分组，分组编号从 1 开始。0 代表整个表达式。</p><p>例子如下：<br>对于时间字符串：2017-04-25，表达式：**(\d{4})-((\d{2})-(\d{2}))**<br>有 4 个左括号，所以有 4 个分组:</p><table><thead><tr><th>编号</th><th>捕获组</th><th>匹配</th></tr></thead><tbody><tr><td>0</td><td>(\d{4})-((\d{2})-(\d{2}))</td><td>2017-04-25</td></tr><tr><td>1</td><td>(\d{4})</td><td>2017</td></tr><tr><td>2</td><td>((\d{2})-(\d{2}))</td><td>04-25</td></tr><tr><td>3</td><td>(\d{2})</td><td>04</td></tr><tr><td>4</td><td>(\d{2})</td><td>25</td></tr></tbody></table><h6 id="命名捕获组"><a href="#命名捕获组" class="headerlink" title="命名捕获组"></a>命名捕获组</h6><p>每个以左括号开始的捕获组，都紧跟着 **?**，而后才是正则表达式。</p><p>例子如下：</p><p>对于时间字符串：2017-04-25，表达式如下：**(?&lt;year&gt;\d{4})-(?&lt;md&gt;(?&lt;month&gt;\d{2})-(?&lt;date&gt;\d{2}))**</p><p>有 4 个命名的捕获组，分别是:</p><table><thead><tr><th align="left">编号</th><th align="left">名称</th><th align="left">捕获组</th><th align="left">匹配</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0</td><td align="left">(?\d{4})-(?(?\d{2})-(?\d{2}))</td><td align="left">2017-04-25</td></tr><tr><td align="left">1</td><td align="left">year</td><td align="left">(?\d{4})-</td><td align="left">2017</td></tr><tr><td align="left">2</td><td align="left">md</td><td align="left">(?(?\d{2})-(?\d{2}))</td><td align="left">04-25</td></tr><tr><td align="left">3</td><td align="left">month</td><td align="left">(?\d{2})</td><td align="left">04</td></tr><tr><td align="left">4</td><td align="left">date</td><td align="left">(?\d{2})</td><td align="left">25</td></tr></tbody></table><p>使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按指定模式在字符串查找</span></span><br><span class="line">String line = <span class="string">&quot;This order was placed for QT3000! OK?&quot;</span>;</span><br><span class="line">String pattern = <span class="string">&quot;(\\D*)(\\d+)(.*)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Pattern 对象</span></span><br><span class="line">Pattern r = Pattern.compile(pattern);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在创建 matcher 对象</span></span><br><span class="line">Matcher m = r.matcher(line);</span><br><span class="line"><span class="keyword">if</span> (m.find( )) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Found value: &quot;</span> + m.group(<span class="number">0</span>) );</span><br><span class="line">    System.out.println(<span class="string">&quot;Found value: &quot;</span> + m.group(<span class="number">1</span>) );</span><br><span class="line">    System.out.println(<span class="string">&quot;Found value: &quot;</span> + m.group(<span class="number">2</span>) );</span><br><span class="line">    System.out.println(<span class="string">&quot;Found value: &quot;</span> + m.group(<span class="number">3</span>) ); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;NO MATCH&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Found value: This order was placed for QT3000! OK?</span></span><br><span class="line"><span class="comment">    Found value: This order was placed for QT</span></span><br><span class="line"><span class="comment">    Found value: 3000</span></span><br><span class="line"><span class="comment">    Found value: ! OK?</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h6 id="非捕获组"><a href="#非捕获组" class="headerlink" title="非捕获组"></a>非捕获组</h6><p>在左括号后紧跟 **?:**，而后再加上正则表达式，构成非捕获组 **(?:Expression)**。</p><p>对于时间字符串：2017-04-25，表达式如下：(?:\d{4})-((\d{2})-(\d{2}))</p><p>这个正则表达式虽然有四个左括号，理论上有 4 个捕获组。但是第一组 **(?:\d{4})**，其实是被忽略的。当使用 matcher.group(4) 时，系统会报错。</p><h4 id="非贪婪匹配"><a href="#非贪婪匹配" class="headerlink" title="非贪婪匹配"></a>非贪婪匹配</h4><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>*？</td><td>重复任意次，但尽可能少重复</td></tr><tr><td>+？</td><td>重复1次或更多次，但尽可能少重复</td></tr><tr><td>？？</td><td>重复0次或1次，但尽可能少重复</td></tr><tr><td>{n,m}?</td><td>重复n到m次，但尽可能少重复</td></tr><tr><td>{n,}?</td><td>重复n次以上，但尽可能少重复</td></tr></tbody></table><h4 id="一些小说明"><a href="#一些小说明" class="headerlink" title="一些小说明"></a>一些小说明</h4><p>首先，正则表达式的调试：<a href="https://c.runoob.com/front-end/854/">https://c.runoob.com/front-end/854/</a> 用在线的测试工具来debug，会比本地瞪眼瞅/先大量删除然后慢慢加回去的方法有效一些。<br>但是，这个方法并不靠谱……即使是直接用它的导出代码也不靠谱。而且注意右边的修饰符下拉菜单，有时候需要用多行模式！<br>这里总结一个小经验，如果不是用捕获组之类而是直接匹配，记得给pattern串加上严格的开始喝结尾限制！</p><p>例子，我们现在要匹配当前的句子里是否有这样的前缀存在，于是我们应该使用：*<em>^[a]{2,3}[b]{2,4}[c]{2,4}.</em>$**这样的pattern来处理。</p><p>一开始，蒟蒻是这样理解正则表达式的，即带匹配串里面包含这个pattern部分就可以被识别出来。所以当时本人使用的是**^[a]{2,3}[b]{2,4}[c]{2,4}**，区别在于这个只限制了开头的样子，没有关心结尾在哪里，是什么样的。结果就是，遇到如aaabbbcc a这样中间存在空格的字符串，就无法匹配到。</p><p>但是，与之对应的，在捕获组的时候我就完全没有考虑这个开头结尾的约束问题…但，蒟蒻个人猜测，应该是空格惹的祸，这个\s，上次就是因为打成大写了结果意思完全反了过来，这次又整这出，真实不省心。<br>真正的原因还未确定。所以这里暂时挂起，待我慢慢解决。</p><p>补充一下另一种匹配方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATTERN = <span class="string">&quot;^.*a.*a.*b.*b.*b.*b.*b.*c.*c.*$&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> Pattern pattern = Pattern.compile(PATTERN);</span><br><span class="line"></span><br><span class="line">String content = <span class="string">&quot;&quot;</span>;<span class="comment">// 待匹配的串</span></span><br><span class="line"><span class="keyword">boolean</span> isMatch = (patternA4.matcher(content).matches() ? <span class="number">1</span> : <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="再遇小问题"><a href="#再遇小问题" class="headerlink" title="再遇小问题"></a>再遇小问题</h4><p>打开gitlab上提供的代码，结果告诉我抽象类不能access。<br>解决方法：invalid cache，重启，好了。<br>所以当你确定没有实现上的问题的时候，重启IDEA可解决大部分问题。</p>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记</title>
      <link href="/2022/02/18/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/18/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>matlab学习笔记</p><h1 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一   基础知识"></a>一   基础知识</h1><h3 id="常用数学函数"><a href="#常用数学函数" class="headerlink" title="常用数学函数"></a>常用数学函数</h3><ul><li><p>sin如果是角度用sind</p><ul><li>如sin(pi/2) = sind(90)</li></ul></li><li><p>abs可用来求实数的绝对值、复数的模、字符串的ASCII码值</p></li><li><p>取整</p><ul><li>round：四舍五入</li><li>ceil：向上</li><li>floor：向下</li><li>fix：舍去小数取整 </li></ul></li><li><p>%： rem(x, y)</p></li><li><p>isprime(x)</p></li><li><p>标准函数名都是小写</p></li><li><p>区分大小写</p></li><li><p>预定义变量</p><ul><li>ans：默认复制变量</li><li>NaN：画图时用于裁剪</li><li>i和j：复数（注意！循环变量避让！）</li><li>pi</li></ul></li><li><p>变量的删除修改</p><ul><li><p>工作区改</p></li><li><p>who</p></li><li><p>whos</p></li><li><p>.mat</p><ul><li>保存工作区变量的文件</li><li>使用save和load命令</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save mydata a x// a和x两个变量装入madata.mat中</span><br><span class="line">load mydata// 从mydata.mat中取出变量</span><br></pre></td></tr></table></figure></li></ul></li><li><p>输出格式</p><ul><li>用format来定义</li><li>目前已知rat是有理数</li></ul></li></ul><h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><ul><li><strong>事实证明，下标从1开始</strong></li><li>冒号表达式：<ul><li>初始值:步长:终止值</li><li>步长可省，忽略为1，此时只有一个冒号</li></ul></li><li>linspace(第一个元素, 最后一个元素, 总数)<ul><li>总数可省，自动产生100个元素 </li></ul></li><li>结构矩阵<ul><li>或许可以理解为结构体？</li><li>结构矩阵元素.成员名 = 表达式</li><li>可以分别是不同的类型，matlab会放弃给你都显示的</li></ul></li><li>单元矩阵<ul><li>每个元素就是由不同类型的数据组成的</li><li>用{}括起来！</li><li>直接写，不用想结构矩阵那样拆开分别赋值</li></ul></li><li>矩阵元素引用<ul><li>如果改动的位置比较大，超出了原来的矩阵大小，matlab会自动在扩大的地方填充0</li><li>通过下标找元素，如A(x,y)</li><li>通过序号引用：按内存顺序<ul><li>序号 = sub2ind(要转换的行数和列数的向量size(A)，转换矩阵的元素行下标，转换矩阵元素的列下标)，后两者可以是矩阵，即多个元素都要转换：由下标换位序号</li><li>[行下标, 列下标] = ind2sub(要转换的行数和列数的向量size(A), 序号)：序号换成下标</li></ul></li></ul></li><li>子矩阵<ul><li>A(i,:)：第i行</li><li>A(i:i+m,:)：第i-i+m行</li><li>A(:,j)：第j列</li><li>A(i:i+n,k:k+m)：第i-i+n行且在k-k+m列中的元素</li><li>当然，这里面都是冒号表达式，所以甚至可以写步长</li><li>end用来代指最后一行/一列</li></ul></li><li>删除元素<ul><li>空矩阵：x = []</li><li>删除方法：赋值为空矩阵</li><li>删除后矩阵会缩小的</li></ul></li><li>reshape(矩阵，行数，列数)：总元素不变，改行数列数，存储顺序不变   </li><li>堆叠元素：A(:)，使之成为一个列向量，实践证明是按列展开的，不是按存储顺序</li></ul><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><ul><li>在矩阵意义下的运算</li><li>算数运算<ul><li>标量可以和矩阵运算，此时标量作用于矩阵中每一个数</li><li>除法：右除( $ B*A^{-1} $ )、左除(A^{-1}*B)</li><li>乘方：A^x，注意A是方阵，x是标量！</li><li>点运算：<ul><li>.*：对应元素做乘法运算</li><li>./：点右除</li><li>.\：点左除    </li><li>.^：点乘方</li></ul></li></ul></li><li>关系运算<ul><li>~=：不等于</li><li>矩阵和矩阵相比是按位置比较，得到一个矩阵</li><li>标量和矩阵比则标量和每一个矩阵元素比，也得到一个矩阵</li></ul></li><li>逻辑运算<ul><li>比较方法同上</li></ul></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>单引号</li><li>字符串即一个行向量</li><li>用两个单引号表示字符串中的单引号</li><li>可以形成字符串矩阵，但需要保证列数相同</li><li>eval(s)：把字符串内容作为指令执行</li><li>可以用char()和abs()/double()在ASCII和字符串之间转换</li><li>可以比较，得到一个同样大小的矩阵/向量<ul><li>strcmp(s1,s2)：相等返回1</li><li>strncmp(s1,s2,n)：前n个字符相等返回1</li><li>strcmpi(s1,s2)：忽略大小写，相等返回1</li><li>strncmpi(s1,s2,n)：忽略大小写，前n个字符相等返回1</li></ul></li><li>findstr(s1, s2)：返回短字符串在成字符串中的开始位置</li><li>strrep(s1,s2,s3)：将字符串s1中的左右子字符串s2替换为s3，区分大小写！</li></ul><h1 id="二-矩阵处理"><a href="#二-矩阵处理" class="headerlink" title="二   矩阵处理"></a>二   矩阵处理</h1><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><ul><li><p>zeros：全零</p></li><li><p>ones：全一</p></li><li><p>eye：对角线为1（方阵即单位矩阵，可以不是方阵，从左上角开始为1）</p></li><li><p>rand：（0,1）区间均匀分布的随机矩阵</p></li><li><p>randn：~N(0,1)</p></li><li><p>可以使用函数(size(A))这种形式</p></li><li><p>magic(n)：幻方</p></li><li><p>vander(V)：以V为基础的范德蒙矩阵</p></li><li><p>hilb(n)：希尔伯特矩阵，H(i,j) = 1/(i+j-1)</p></li><li><p>compan(p)：p是一个多项式的系数向量，伴随矩阵</p></li><li><p>pascal(5)：帕斯卡矩阵，p(i,j)=p(i,j-1)+p(i-1,j)    </p></li></ul><h3 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h3><ul><li><p>diag(A,k)：提出矩阵A第K条对角线上的元素，右上为正，左下为负，主对角线为0（此时k可省略）</p></li><li><p>diag(V,k)：以向量V为第k条对角线元素，产生对角矩阵，k为0即主对角线时可省略</p></li><li><p>triu(A,k)：上三角阵，提取第k条及右上的元素，k为0时可省略</p></li><li><p>tril(A,k)：同理</p></li><li><p>A.’：转置</p></li><li><p>A’：共轭转置（用于复数）</p></li><li><p>rot90(A,k)：将矩阵A逆时针方向旋转90°的k倍，k为1时可省略</p></li><li><p>fliplr(A)：左右翻转</p></li><li><p>flipud(A)：上下翻转</p></li><li><p>inv：逆矩阵</p></li><li><p>方程求解</p><ul><li>A是系数矩阵，B是常数向量，用x=A\b可解</li><li>也可用x = inv(A)*b,这里就是说Ax=b的意思，其实两种都一样</li></ul></li></ul><h3 id="矩阵求值"><a href="#矩阵求值" class="headerlink" title="矩阵求值"></a>矩阵求值</h3><ul><li><p>det(A)：方阵A对应行列式</p></li><li><p>rank(A)；秩</p></li><li><p>trace(A)：迹（对角线元素之和）</p></li><li><p>范数</p><ul><li>norm(V,2)：向量V的1——范数（向量元素的绝对值之和，2可省略）</li><li>norm(V,1)：向量V的2——范数（向量元素平方和的平方根）</li><li>norm(V,inf)：向量V的$\infty$——范数（所有向量元素绝对值中的最大值）</li></ul></li><li><p>条件数</p><ul><li>矩阵A的条件数 = A的范数*A的逆矩阵范数</li><li>越接近1，性能越好</li><li>cond(A,1)：矩阵A的1——范数下的条件数</li><li>cond(A,2)：矩阵A的2——范数下的条件数，2可省略</li><li>cond(A,inf)：矩阵A的$\infty$——范数下的条件数</li></ul></li></ul><h3 id="矩阵特征值"><a href="#矩阵特征值" class="headerlink" title="矩阵特征值"></a>矩阵特征值</h3><ul><li>$ Ax = \lambda x $</li><li>E = eig(A)</li><li>[X, D] = eig(A)，X是各列对应的特征向量，D是X的各列的特征值</li></ul><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><ul><li>A = sparse(S)，将S转化为稀疏存储方式的矩阵</li><li>S = full(A)，将A转化为完全存储方式的矩阵</li><li>sparse(u, v, S)：uvS等长，S为要存储的非零元素，(u,v)是坐标</li><li>带状稀疏矩阵：<ul><li>[B,d] = spdiags(A)，从A中提取全部非零对角线得到B，位置向量得到d</li><li>A = spdiags(B, d, m, n)，上述的操作反过来</li></ul></li></ul><h3 id="程设"><a href="#程设" class="headerlink" title="程设"></a>程设</h3><ul><li>注意运行脚本文件的时候，matlab需要在那个目录下才行，要不然无法实现</li><li>input();</li><li>disp();</li><li>匿名函数：函数句柄变量 = @(匿名函数输入参数)匿名表达式</li></ul><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><ul><li>plot(x, y)</li><li>plot(x)，其中横坐标为1,2,3,4,…</li><li>fplot(f, lims, 选项)</li><li>fplot(funx, funy, tlims, 选项)</li><li>title(图形标题)</li><li>xlable()和ylable()</li><li>text(x, y, 说明)</li><li>gtext(说明)，用鼠标定位</li><li>legend(图例1，图例2，…)</li><li>axis([xmin, xmax, ymin, ymax, zmin, zmax])</li><li>hold on / hold off / hold</li><li>subplot(n, m, p)，n行m列，第p张图</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h6 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h6><p>目标：$ min{ c^T\cdot x } $<br>s.t.<br>$ Ax &lt;= b $<br>$ Aeq\cdot x = beq $<br>$ lb &lt;= x &lt;= ub $</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x, fval] = <span class="built_in">linprog</span>(c, A, b)</span><br><span class="line">[x, fval] = <span class="built_in">linprog</span>(c, A, b, Aeq, beq)</span><br><span class="line">[x, fval] = <span class="built_in">linprog</span>(c, A, b, Aeq, beq, lb, ub)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记1</title>
      <link href="/2022/02/15/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
      <url>/2022/02/15/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h4 id="读入"><a href="#读入" class="headerlink" title="读入"></a>读入</h4><p>使用scanner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">String name = scanner.next();</span><br><span class="line"><span class="keyword">long</span> price = scanner.nextLong();</span><br><span class="line"><span class="keyword">double</span> capacity = scanner.nextDouble();</span><br></pre></td></tr></table></figure><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><h5 id="ArrayList-lt-gt"><a href="#ArrayList-lt-gt" class="headerlink" title="ArrayList&lt;&gt;"></a>ArrayList&lt;&gt;</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;类&gt; 名字 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">名字.add(元素);</span><br><span class="line">名字.set(idx, 元素);</span><br><span class="line">名字.remove(idx或元素);</span><br><span class="line"><span class="keyword">for</span> (类型 item : 名称) &#123;&#125;</span><br><span class="line">Collections.sort(名称); <span class="comment">//引入collections类</span></span><br><span class="line"><span class="keyword">if</span> (名称.contains(元素)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>于是这里歪三产生了一个奇怪的问题，即如果列表里的元素和下标无法区分怎么办：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">tmp.add(<span class="number">5</span>);</span><br><span class="line">tmp.add(<span class="number">6</span>);</span><br><span class="line">tmp.add(<span class="number">3</span>);</span><br><span class="line">tmp.add(<span class="number">4</span>);</span><br><span class="line">System.out.println(tmp);</span><br><span class="line">tmp.remove(<span class="number">3</span>);</span><br><span class="line">System.out.println(tmp);</span><br></pre></td></tr></table></figure><p>采取以上实验之后，她发现了，程序移除了3号位置的元素，而非3这个元素，在idea里，括号中出现的提示字符串也是“index:”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>故idx优先级比元素内容高，且如果两个类型相同，按idx来，所以如果真的要remove一个比较大的元素，直接输入值可能出现越界行为，如下（但满面红光！）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IndexOutOfBoundsException: Index <span class="number">5</span> out of bounds <span class="keyword">for</span> length <span class="number">4</span></span><br><span class="line">at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:<span class="number">64</span>)</span><br><span class="line">at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:<span class="number">70</span>)</span><br><span class="line">at java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:<span class="number">266</span>)</span><br><span class="line">at java.base/java.util.Objects.checkIndex(Objects.java:<span class="number">359</span>)</span><br><span class="line">at java.base/java.util.ArrayList.remove(ArrayList.java:<span class="number">504</span>)</span><br><span class="line">at Main.main(Main.java:<span class="number">15</span>)</span><br></pre></td></tr></table></figure><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p>散列表，无序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;类<span class="number">1</span>, 类<span class="number">2</span>&gt; 名称 = <span class="keyword">new</span> HashMap&lt;类<span class="number">1</span>, 类<span class="number">2</span>&gt;();</span><br><span class="line">名称.put(key,value);</span><br><span class="line">名称.remove(key);</span><br><span class="line">名称.clear();</span><br><span class="line">名称.size();</span><br><span class="line"><span class="keyword">for</span> (Integer item : 名称.keySet()) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (Integer item : 名称.values()) &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h5><p>它存储类似于HashMap<br>只允许不同的key<br>log（n）的时间成本<br>有序<br>本质是红黑树    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;类<span class="number">1</span>, 类<span class="number">2</span>&gt; pairs = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">名称.put(key,value);</span><br><span class="line">value = 名称.get(key);</span><br><span class="line">名称.remove(key);</span><br><span class="line">名称.clear();</span><br><span class="line">名称.size();</span><br><span class="line">名称.firstKey();</span><br><span class="line">名称.lastKey();</span><br><span class="line">名称.ceillingKey(key);<span class="comment">//返回大于或等于给定键的最小键，如果没有这样的键则返回null，floor反之</span></span><br><span class="line">名称.higherKey(key);<span class="comment">//返回严格大于指定键的最小键，lower反之</span></span><br><span class="line"><span class="comment">//上面四个Key换成Entry就可对键值对进行操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>集合，无序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;类&gt; 名称 = <span class="keyword">new</span> HashSet&lt;类&gt;();</span><br><span class="line">名称.add(元素);</span><br><span class="line">名称.remove(元素);</span><br><span class="line">名称.clear();</span><br><span class="line">名称.size();</span><br><span class="line"><span class="keyword">for</span> (Integer item : 名称) &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>有序集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;类&gt; 名称 = <span class="keyword">new</span> TreeSet&lt;类&gt;();</span><br><span class="line">名称.add(元素);</span><br><span class="line">名称.remove(元素);</span><br><span class="line">名称.clear();</span><br><span class="line">名称.size();</span><br><span class="line"><span class="keyword">for</span> (Integer item : 名称) &#123;&#125;</span><br></pre></td></tr></table></figure><p>那怎样重载排序的运算符呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Integer&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? <span class="number">1</span> : -<span class="number">1</span>;<span class="comment">// 从大往小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h5><p>好难用…c/c++选手留下痛苦的泪水<br>今天也是怀念unsigned long long的一天啊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger sum = <span class="keyword">new</span> BigInteger(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">sum = sum.add(tmp);</span><br></pre></td></tr></table></figure><p>怎么进行数据转换呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger tmp = <span class="keyword">new</span> BigInteger(val.toString());<span class="comment">//但是对于非val类型的就得看下面的方法了</span></span><br><span class="line">BigInteger tmp = <span class="keyword">new</span> BigInteger(Long.toString(一个长整型数));<span class="comment">//int同理</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记0</title>
      <link href="/2022/02/13/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/"/>
      <url>/2022/02/13/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/</url>
      
        <content type="html"><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="一-java对象及语言初步"><a href="#一-java对象及语言初步" class="headerlink" title="一   java对象及语言初步"></a>一   java对象及语言初步</h2><ul><li><p>java的并发性</p><ul><li>无并发：main loop</li><li>对象并发</li></ul></li><li><p>对象在程序中第一次出现的时候只是一个引用，需要实例化（开辟的是引用空间而不是数据空间）</p></li><li><p>语法</p><ul><li>驼峰 接口名、类名首字母大写</li></ul></li><li><p>UML?  VISIO? UMLet工具和Dia？ </p></li></ul><p><strong>“我们要做对编译系统友好的程序员”</strong></p><h2 id="二-java的表达式，流控制和数组"><a href="#二-java的表达式，流控制和数组" class="headerlink" title="二   java的表达式，流控制和数组"></a>二   java的表达式，流控制和数组</h2><h6 id="和C的区别"><a href="#和C的区别" class="headerlink" title="和C的区别"></a>和C的区别</h6><ul><li>强类型语言</li><li>不提供指针运算符！但是有引用</li><li>字符串运算符+</li><li>零填充的右移&gt;&gt;&gt;</li><li>++、–是最快的操作，还有移位操作，都是一个时钟周期的事情</li></ul><h6 id="混合类型运算"><a href="#混合类型运算" class="headerlink" title="混合类型运算"></a>混合类型运算</h6><ul><li>long：都不是float和double，至少有一个是long</li><li>int：只能是int</li><li>double：至少有一个是double</li><li>float 只少有一个是float，且都不是double</li></ul><h6 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h6><ul><li>位移<ul><li>无符号右移：&gt;&gt;&gt;</li></ul></li><li>逻辑运算（区别于布尔运算）<ul><li>&amp;|^~</li><li>异或曾经被大量用在画画中</li></ul></li><li>逻辑操作符<ul><li>&amp;&amp; || ! &amp; | ^</li></ul></li><li>赋值<ul><li>注意新增一个&gt;&gt;&gt;=</li></ul></li><li>其他<ul><li>instanceof：<ul><li>op1 instanceof op2</li></ul></li></ul></li></ul><h6 id="类型强制转换"><a href="#类型强制转换" class="headerlink" title="类型强制转换"></a>类型强制转换</h6><p>整型与浮点型</p><h6 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h6><h6 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h6><ul><li>可以改变空间 用new</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">a[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><ul><li>在java里面数组得名字是一个地址变量（区别于c是地址常量）</li></ul><h2 id="三-java语言的对象与类"><a href="#三-java语言的对象与类" class="headerlink" title="三   java语言的对象与类"></a>三   java语言的对象与类</h2><h6 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h6><h6 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h6><h6 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h6><h6 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h6><ul><li>声明</li><li>实例化</li><li>初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[类型] 名称;</span><br><span class="line">名称 = <span class="keyword">new</span> 对象所属类的构造方法，如[类型]();</span><br></pre></td></tr></table></figure><h6 id="对象的回收"><a href="#对象的回收" class="headerlink" title="对象的回收"></a>对象的回收</h6><ul><li>当把一个对象没有引用指向它时，会被自动回收</li></ul><h6 id="类的构造方式"><a href="#类的构造方式" class="headerlink" title="类的构造方式"></a>类的构造方式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名(参数)</span><br><span class="line">&#123; ··· &#125;</span><br><span class="line"><span class="comment">//方法名必须与类名相同，不能带返回类型</span></span><br></pre></td></tr></table></figure><h6 id="类成员方法定义"><a href="#类成员方法定义" class="headerlink" title="类成员方法定义"></a>类成员方法定义</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modifiers&gt;&lt;return_type&gt;&lt;name&gt;</span><br><span class="line">([&lt;argument_list])[<span class="keyword">throws</span>&lt;exception&gt;]&#123;&lt;block&gt;&#125;</span><br><span class="line"><span class="comment">//传值，方法调用不改变参数的值</span></span><br><span class="line"><span class="comment">//但若参数是对象，参数的值是该对象的引用，故对象的内容可以在方法中被改变，但是对象的引用不会改变</span></span><br></pre></td></tr></table></figure><h6 id="数据的隐藏和分装"><a href="#数据的隐藏和分装" class="headerlink" title="数据的隐藏和分装"></a>数据的隐藏和分装</h6><ul><li>数据隐藏：private，保证对象中数据的一致性</li><li>封装<ul><li>隐藏类中具体实现的细节</li><li>强迫使用统一接口访问数据</li><li>使代码可维护性好</li></ul></li></ul><h6 id="this-引用"><a href="#this-引用" class="headerlink" title="this 引用"></a>this 引用</h6><ul><li>指向当前的对象本身</li></ul><h6 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h6><ul><li>在同一个类中一个方法名被用来定义多个方法</li><li>参数必须不同</li><li>返回类型、修饰符可相同</li></ul><h6 id="激活重载的构造方法"><a href="#激活重载的构造方法" class="headerlink" title="激活重载的构造方法"></a>激活重载的构造方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;name1&gt;(para1, para <span class="number">2</span>)</span><br><span class="line">    &#123; ··· &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;name1&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">this</span>.(a, b); <span class="comment">//这里就在调用之前同名的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h6><ul><li>有父类全部的属性和自己新定义的属性</li><li>带private修饰符的不可被继承</li><li>构造方法不能被继承但可以调用，调用自己的用this()，调用父类的用super()</li><li>extends</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> &lt;<span class="title">father_name</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123; ··· &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> &lt;<span class="title">son_name</span>&gt; <span class="keyword">extends</span> &lt;<span class="title">father_name</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123; ··· &#125;</span><br></pre></td></tr></table></figure><ul><li>java中任何一个子类的实例化都可以作为父类的实例使用，可以调用父类具有的方法 -&gt; 所以一个类数组的每一个单元的类型可以是各种子类</li><li>单继承，即extends后面只有一个类名</li></ul><h6 id="多态-1"><a href="#多态-1" class="headerlink" title="多态"></a>多态</h6><ul><li>引用类型 + 实例化类型</li><li>父类对象的变量作为子类对象的变量使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;father_name&gt; &lt;name&gt; = <span class="keyword">new</span> &lt;son_name&gt;();</span><br></pre></td></tr></table></figure><h6 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h6><ul><li>子类可以改变从父类继承的行为，被重写方法的返回值、方法名、参数列表要与父类中的方法完全一样</li><li>如果不一样，那叫多态</li><li>方法的访问权限不能缩小</li></ul><h6 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h6><ul><li>抽象类不能直接用来生成实力，一般可通过定义子类进行实例化</li></ul><h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><ul><li>interface</li><li>所有成员方法都是抽象的，并且只能定义static final成员变量</li><li>接口的继承（？ 用implements，该子类中必须实现接口（及其超类）中的所有方法</li><li>extends和implements同时存在时，就按这个顺序写：extends &lt;&gt; implements &lt;&gt;</li><li>可以通过实现接口实现多重继承：一个类可只继承一个父类，并实现多个接口 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;&gt; <span class="keyword">extends</span> &lt;&gt; <span class="keyword">implements</span> &lt;&gt;&lt;&gt;···&lt;&gt; </span>&#123; ··· &#125;</span><br></pre></td></tr></table></figure><h6 id="静态变量类型"><a href="#静态变量类型" class="headerlink" title="静态变量类型"></a>静态变量类型</h6><ul><li>static / class variable</li></ul><h6 id="静态类方法"><a href="#静态类方法" class="headerlink" title="静态类方法"></a>静态类方法</h6><ul><li>可以直接被调用，而不需要生成任何实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> &lt;&gt;()</span><br><span class="line">&#123; ··· &#125;</span><br></pre></td></tr></table></figure><h6 id="final"><a href="#final" class="headerlink" title="final"></a>final</h6><ul><li>被定义成final的类不能被继承（不能有子类）</li><li>成员方法不能被重写，成员变量不能被改变，一般用大写表示，是常量</li></ul><h2 id="四-java包与访问控制、例外处理"><a href="#四-java包与访问控制、例外处理" class="headerlink" title="四   java包与访问控制、例外处理"></a>四   java包与访问控制、例外处理</h2><p>包与访问处理可以和using namespace std类比</p><h6 id="类分组"><a href="#类分组" class="headerlink" title="类分组"></a>类分组</h6><ul><li>语句：package 包名</li></ul><h6 id="高级访问控制"><a href="#高级访问控制" class="headerlink" title="高级访问控制"></a>高级访问控制</h6><ul><li>不针对类，以类为单位</li><li>应用于class或type层次</li></ul><h6 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> //只在包容类中调用 </span>= 不能被任何其他类访问，只能自己访问，作为类的一个成员使用</span><br><span class="line">&#123; ··· &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>wrapper：将基本类型表示成类，可调用MIN_VALUE和MAX_VALUE，还有valueOf和toString实现字符串与数字之间的转化</li></ul><h6 id="collection-API-集合类"><a href="#collection-API-集合类" class="headerlink" title="collection API 集合类"></a>collection API 集合类</h6><ul><li>set<ul><li>不能包含重复元素</li><li>HashSet</li><li>TreeSet</li></ul></li><li>list<ul><li>有序集合，元素可重复</li></ul></li><li>string</li></ul><h6 id="捕捉与例外处理"><a href="#捕捉与例外处理" class="headerlink" title="捕捉与例外处理"></a>捕捉与例外处理</h6><ul><li>try，后面必须跟随一个catch或者finally语句块</li><li>catch</li><li>finally</li><li>抛出：throw</li><li>获得例外并处理：connectMe</li></ul><h2 id="五-I-O"><a href="#五-I-O" class="headerlink" title="五   I/O"></a>五   I/O</h2><ul><li>设备、DMA</li></ul><h6 id="流式I-O"><a href="#流式I-O" class="headerlink" title="流式I/O"></a>流式I/O</h6><ul><li>按输入源头<ul><li>node stream</li><li>filter stream</li></ul></li><li>字节流<ul><li>input stream<ul><li>甚至可以skip</li></ul></li><li>output stream<ul><li>void write * 3</li><li>void flush()  //强行写，保证写进去了</li></ul></li></ul></li><li>reader: int read()</li><li>writer: int write()</li><li>grep</li><li>管道流：把一个线程的输出连接到另一个线程的输入<ul><li>倒排字典 押韵 -&gt; 好背  lol</li><li>单词逆序 -&gt; 排序 -&gt; 然后再逆回来</li></ul></li><li>过滤流：从原始流成块读入，或将数据累计到一个大数据块儿后再成批输出</li></ul><h6 id="大作业-orz"><a href="#大作业-orz" class="headerlink" title="大作业 orz"></a>大作业 orz</h6><h2 id="六-AWT及Applet编程"><a href="#六-AWT及Applet编程" class="headerlink" title="六   AWT及Applet编程"></a>六   AWT及Applet编程</h2><ul><li>AWT 抽象窗口工具集</li><li>Java.awt包</li></ul><h6 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h6><ul><li>所有组件都必须放在容器内（如窗口）</li><li>frame / panel / layout manager（如比较古早的网页布局设计方法）</li><li>events 描述不同类型的用户动作</li><li>component<ul><li>支持基本的drawing</li><li>paint(), update(), repaint()</li></ul></li></ul><h6 id="applet"><a href="#applet" class="headerlink" title="applet"></a>applet</h6><ul><li>html 标志方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献阅读week_2</title>
      <link href="/2022/02/04/week-2/"/>
      <url>/2022/02/04/week-2/</url>
      
        <content type="html"><![CDATA[<h2 id="week-2"><a href="#week-2" class="headerlink" title="week 2"></a>week 2</h2><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><h3 id="题目：面向服务的制造系统中制造服务供需匹配研究综述与展望"><a href="#题目：面向服务的制造系统中制造服务供需匹配研究综述与展望" class="headerlink" title="题目：面向服务的制造系统中制造服务供需匹配研究综述与展望"></a>题目：面向服务的制造系统中制造服务供需匹配研究综述与展望</h3><h3 id="笔记："><a href="#笔记：" class="headerlink" title="笔记："></a>笔记：</h3><ul><li>制造服务供需匹配：<ul><li>供应：以服务形式存在的各类制造资源</li><li>资源：通过配置整合成为能力</li><li>服务：资源和能力通过一定的感知与接人、虚拟化、服务化等处理后以制造服务的形式存在从而可以通过网络被聚合、检索、调用等，并为社会化的用户提供面向产品全生命周期的各类应用</li><li>需求：全生命周期过程中涉及的所有与生产相关或与产品相关的任务以及其他服务需求的集合</li><li>资源+需求配置，结果得到制造服务和制造服务需求的映射关系</li><li>资源配置：需要哪些制造服务、怎么用，来解决某个服务需求</li><li>需求配置：是什么需求、任务按什么顺序被某个服务执行</li><li>包括静态预调度和动态再调度的双重决策</li><li>分类：<ul><li>从匹配的实质出发：包括供需对象匹配和供需数量匹配</li><li>从实现匹配的主体出发：包括企业供需匹配和系统供需匹配</li></ul></li><li>未来研究展望：<ul><li><strong>社会化</strong>制造服务供需的<strong>动态</strong>匹配</li><li>大数据的应用：演化、统计、挖掘与预测</li><li>供需匹配与企业协作及其价值创造的相互映射与影响</li><li>SOM系统／服务平台的完善及其与工业物联网的融合</li></ul></li></ul></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>本文是一篇综述型文章。为推进制造业的信息化发展，本文发展面向服务的制造系统进行了现状讨论与趋势分析。其供需匹配在于资源配置和需求配置，目的是得到制造服务和制造服务需求的映射关系。其中供需匹配的研究模型分为供需静态、需求动态、供应动态、供需动态和过程动态。供需匹配问题的实现方法，从匹配依据的角度包括成本类、能耗类、时间类、质量类、风险类和其他评估指标；从技术手段分为点对点式、基于中介器和基于系统/服务平台的供需匹配；从求解方法分为基于模板／本体和关键字、基于流程驱动的方法、基于人工智能和规划的方法、基于图论的方法、基于中介器的方法、基于服务组合的方法、基于供应链的方法、基于智能体的方法、基于服务质量优化的方法等。其仍有不少展望值得继续探究。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><h3 id="题目：面向服务的制造系统中制造服务供需匹配研究综述与展望-1"><a href="#题目：面向服务的制造系统中制造服务供需匹配研究综述与展望-1" class="headerlink" title="题目：面向服务的制造系统中制造服务供需匹配研究综述与展望"></a>题目：面向服务的制造系统中制造服务供需匹配研究综述与展望</h3><h3 id="笔记：云制造典型特征、关键技术与应用"><a href="#笔记：云制造典型特征、关键技术与应用" class="headerlink" title="笔记：云制造典型特征、关键技术与应用"></a>笔记：云制造典型特征、关键技术与应用</h3><ul><li>典型技术特征：制造资源和能力的物联化、虚拟化、服务化、协同化、智能化</li><li>关键技术：<ul><li>物联化技术<ul><li>自适应适配器技术，以及制定接口规范和标准传输协议</li></ul></li><li>虚拟化技术<ul><li>涉及各类“虚拟器件”模板或镜像的创建、发布、存储技术以及将物理环境迁移到虚拟环境的技术等</li><li>需要建立规范化的虚拟资源和能力描述模型，能够灵活管理“物理一虚拟器件”之间的映射关系</li></ul></li><li>智能化技术</li><li>云安全是一个共性的、十分重要的问题，限于篇幅，本文并未专门论述</li></ul></li><li>应用案例：<ul><li>面向航天复杂产品的集团企业云制造服务平台</li><li>面向轨道交通装备的集团企业云制造服务平台</li><li>支持企业业务紧密合作的中小企业云制造服务平台</li><li>支持产业集群协作的中小企业云制造服务平台</li><li>（以上均从五个技术特征分析）</li></ul></li><li>总结展望：<ul><li>在落实阶段</li><li>系统建设和技术/产品发展相互促进</li><li>建造云制造技术研究队伍</li><li>重视自主云制造产业</li></ul></li></ul><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>本文总结了云制造的典型技术特征，即制造资源和能力的物联化、虚拟化、服务化、协同化、智能化；以及实现云制造的关键技术，即物联化技术、虚拟化技术、智能化技术、以及本文并未展开的安全技术。同时，本文展示了当前云制造的一些应用案例。而对于未来云制造的发展，本文提出应该在云制造系统建设和技术/产品发展相互促进的良性循环中，通过建造云制造技术研究队伍，并重视自主云制造产业的方式进行进一步工作。</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><h3 id="题目：云制造及相关先进制造模式分析"><a href="#题目：云制造及相关先进制造模式分析" class="headerlink" title="题目：云制造及相关先进制造模式分析"></a>题目：云制造及相关先进制造模式分析</h3><h3 id="笔记：-1"><a href="#笔记：-1" class="headerlink" title="笔记："></a>笔记：</h3><ul><li>制造的服务化、基于知识的创新能力，以及对各类制造资源的聚合与协同能力、对环境的友好性，已成为构成企业竞争力的关键要素和制造业信息化发展的趋势</li><li>与云制造相关的先进制造模式<ul><li>敏捷制造<ul><li>有点推式制造的感觉？需要快速反应。纹理给出了三种别人的解释，想必他们自己也没有很好的辨析清楚（笑）。</li><li>这种模式下诞生了虚拟企业（只关注其具有核心竞争能力的功能业务，将非核心业务进行虚拟化/当市场出现新机遇时，不同公司为了共同的竞争目标，以网络为基础所组成的临时性动态联盟）</li><li>这个虚拟企业有趣！</li></ul></li><li>网络化制造<ul><li>是敏捷制造等模式的延续和发展</li><li>通过网络实现分散计算资源的共享与优化配置</li></ul></li><li>面向服务的制造</li></ul></li><li>云制造<ul><li>对比敏捷制造<ul><li>平台更开放</li><li>协作联盟范围更广</li><li>资源种类数量更丰富</li><li>企业间有更持久的业务过程经验和知识积累</li><li>涉及业务范围更广</li></ul></li><li>对比网络化制造</li><li>对比面向服务的制造<ul><li>云制造是面向服务制造理念的一种体现，通过产品与服务、制造与服务的融合，实现以向用户提供专业化及社会化的服务为目的。</li><li>云制造理念丰富了面向服务制造的内涵，如强调了制造能力的服务化、资源的按需使用及动态协同等。</li></ul></li></ul></li><li>总结：<ul><li>云制造借鉴了已有先进制造模式的成果，并在理念、模式、组织实施、技术架构等多方面进行了拓展。</li><li>模式、技术及应用仍有展望</li></ul></li></ul><h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>为了更好的理解云制造的特点和内涵，本文列举了现有的先进制造模式：敏捷制造、网络化制造与面向服务的制造，并一一与云制造的理念嗯应用模式对比，找出区别与联系。从中可见云制造拥有更加广阔的平台和丰富的资源，同时更加体现了制造的服务化、对各类制造资源的聚合与协同能力，实现以向用户提供专业化及社会化的服务。</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><h3 id="题目：云制造模式下制造能力建模关键技术"><a href="#题目：云制造模式下制造能力建模关键技术" class="headerlink" title="题目：云制造模式下制造能力建模关键技术"></a>题目：云制造模式下制造能力建模关键技术</h3><h3 id="笔记：-2"><a href="#笔记：-2" class="headerlink" title="笔记："></a>笔记：</h3><ul><li><p>制造能力是云制造服务平台中最重要和核心的服务内容之一，通过智力资源的引入，能够将上述资源进行有效集成并以能力的形式对外提供</p></li><li><p>云制造模式下制造能力概念模型与分类</p><ul><li>制造能力概念模型<ul><li>制造能力：在某一具体活动过中产生，体现了一种对制造资源配置和整合的能力</li><li>包括四个部分：资源(Resource，R)、过程(Process，P)、任务(Task，T)和知识(Knowledge，K)，即制造能力的RPT-K模型</li></ul></li><li>分类<ul><li>制造能力层次结构：为资源级(单元级)、业务级(流水线级)、企业级和产业级</li><li>制造能力需求：制造资源租用/产品业务购买方式</li><li>制造能力组成：基本能力和增值能力</li></ul></li></ul></li><li><p>制造能力多维信息描述模型：包括要素描述、关系描述、和评估指标</p><ul><li>（这里也有离散的感觉！） </li><li>主体资源</li><li>产品／业务信息描述</li><li>人力资源</li><li>过程知识</li></ul></li><li><p>制造能力描述框架（上面是 是什么，这里是 怎么描述，也就是语言）</p><ul><li>离散！！！！离散啊啊啊啊！</li></ul></li><li><p>制造能力管理及应用技术</p><ul><li>制造能力封装发布、智能匹配、动态组合、制造能力协同、制造能力综合评估及演化等</li><li>采用“一次搜索、二次推荐”的方法来实现</li></ul></li><li><p>本文通过前面给出的制造能力的相关理论分析，设计开发了一款制造能力服务化原型系统。该系统主要针对三种资源(硬件加工设备、软件、智力资源)及能力进行服务化封装发布。</p></li></ul><h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><p>本文对云制造模式下制造能力概念模型进行了描述（RPT-K模型），并提出了针对制造能力层次结构、制造能力需求和制造能力组成的分类。根据要素描述、关系描述、和评估指标建立制造能力多维信息描述模型和描述框架。制造能力管理及应用技术在于制造能力封装发布、智能匹配、动态组合、制造能力协同、制造能力综合评估及演化等。同时，本文通过制造能力的相关理论分析，设计开发了一款制造能力服务化原型系统。该系统主要针对三种资源（硬件加工设备、软件、智力资源）及能力进行服务化封装发布。    </p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><h3 id="题目：云制造特征及云服务组合关键问题研究"><a href="#题目：云制造特征及云服务组合关键问题研究" class="headerlink" title="题目：云制造特征及云服务组合关键问题研究"></a>题目：云制造特征及云服务组合关键问题研究</h3><h3 id="笔记：-3"><a href="#笔记：-3" class="headerlink" title="笔记："></a>笔记：</h3><ul><li><p>制造云服务组合是提高云制造资源利用率、实现制造资源增值的关键途径之一</p></li><li><p>而云制造系统中云服务的多样性、复杂性、规模性等特点，使得以上方法不能直接用于云服务组合的实现。</p></li><li><p>云制造的典型特征：</p><ul><li>面向服务和需求</li><li>不确定性</li><li>用户参与</li><li>透明和集成（计算机意义下的透明）</li><li>主动（订单主动寻找制造方/云服务主动寻找租户）</li><li><strong>按需使用和付费</strong></li><li>低门槛、外包式制造</li><li>敏捷化</li><li>专业化</li><li>基于能力共享与交易</li><li>基于知识</li><li>基于群体创新（维基百科式）</li><li>绿色低碳（是云制造目标之一）</li></ul></li><li><p>概念辨析</p><ul><li><p>制造资源</p><ul><li>一切能在制造全生命周期中发挥作用的所有软硬件资源、人、知识等的总称</li><li>可描述出相应的制造能力</li><li>经虚拟化封装成制造云服务</li></ul></li><li><p>制造云服务</p><ul><li>建成云服务</li><li>与云计算服务相对应</li><li>把云制造资源和云制造能力基于知识进行虚拟封装，接入智能平台，通过网络想用户提供高度虚拟化的云端资源/服务的过程</li></ul></li><li><p>制造云</p><ul><li>云服务按照一定规则聚合形成</li><li>云服务资源池</li></ul></li><li><p>针对按需分配和使用资源的特点，需要云服务组合</p></li></ul></li><li><p>云服务组合</p><ul><li>主要模型（图4）</li><li>关键问题<ul><li>云服务组合建模、描述、一致性检查、可执行模型转换</li><li>云服务组合关联关系</li><li>云服务组合柔性管理</li><li>云服务组合网络及动力学特性</li><li>云服务组合综合评估及优选</li></ul></li></ul></li></ul><img src="/2022/02/04/week-2/image-20220204085628392.png" class="" title="image-20220204085628392"><ul><li>下一步：将对本文提到的云服务组合关键问题进行深入研究，提出相应的解决方法，并对云制造模式进行全方位研究。</li></ul><h3 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h3><p>云制造系统中云服务的多样性、复杂性、规模性等特点，使得一般制造方法不能直接用于云服务组合这一提高云制造资源利用率、实现制造资源增值的关键途径的实现。本文有限分析了云制造特点，辨析了制造资源、制造云服务、制造云三者的概念，提出云服务组合的重要性，并在此基础上对云服务组合全生命周期需求进行分析，阐述了云组合服务的关键问题：云服务组合建模／描述和一致性检查、云服务关联关系、云服务组合柔性、组合网络及其动力学特性、云服务组合建模与评估、组合优选等，为未来实现高效智能化的云制造服务管理提供理论支持。</p><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><h3 id="题目：制造云构建关键技术研究"><a href="#题目：制造云构建关键技术研究" class="headerlink" title="题目：制造云构建关键技术研究"></a>题目：制造云构建关键技术研究</h3><h3 id="笔记：-4"><a href="#笔记：-4" class="headerlink" title="笔记："></a>笔记：</h3><ul><li><p>概念介绍</p><ul><li>制造云服务</li><li>制造云<ul><li>制造公云</li><li>制造私云</li></ul></li></ul></li><li><p>制造云构建层次示意图</p></li><li><p>制造云构建的关键技术</p><ul><li>资源分类（同样的，还是资源形成能力）<img src="/2022/02/04/week-2/image-20220204094403945.png" class="" title="image-20220204094403945"><ul><li>定义属性：静态/动态</li></ul></li><li>资源虚拟化<ul><li>主要指云制造能力和资源的虚拟化</li><li>弱化物理依赖</li><li>包括资源感知和资源的虚拟接入</li><li>资源感知<ul><li>硬资源感知：物联网</li><li>软资源感知：对静态属性</li></ul></li><li>虚拟接入</li></ul></li><li>虚拟资源服务化<ul><li>把资源描述规范，以服务的形式发布到云平台</li><li>DMM[c=(Task，Resource，Participator，Knowledge)。</li></ul></li><li>云服务部署<ul><li>对制造云中的云服务进行集中、高效的管理</li><li>面向完全托管的部署</li><li>面向部分托管的部署</li></ul></li></ul></li><li><p>面向设计仿翼的云服务平台</p><ul><li>虚拟化支撑子系统 </li><li>云服务管理子系统</li><li>知识库管理子系统</li><li>面向云服务的复杂产品设计子系统</li></ul></li></ul><h3 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a>总结：</h3><p>本文围绕制造云的构建，研究了其过程与其中的关键技术。本文首先结合云制造模式的特点，对制造云及制造云服务进行了相关说明和层次展示，并对制造云构建过程中的关键技术依次做了详细阐述：资源分类、资源虚拟化、虚拟资源服务化与云服务部署。最后，结合已有成果，课题组初步开发了面向设计仿真的云服务平台原型，该平台主要针对产品全生命周期应用过程中设计、仿真阶段的各类资源，包括虚拟化支撑、云服务管理、知识库管理和面向云服务的复杂产品设计四个子系统。同时，本文也展望未来，如云制造运行模式、平台标准规范等依旧是云制造研究中面临的问题，下一步将结合制造业实际需求对相关的问题做更深入的研究与探索，推进云制造落地。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务 云制造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献阅读week_1</title>
      <link href="/2022/01/25/week-1/"/>
      <url>/2022/01/25/week-1/</url>
      
        <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><h3 id="题目：基于BOM的节能减排评估系统研究水"><a href="#题目：基于BOM的节能减排评估系统研究水" class="headerlink" title="题目：基于BOM的节能减排评估系统研究水"></a>题目：基于BOM的节能减排评估系统研究水</h3><h3 id="笔记："><a href="#笔记：" class="headerlink" title="笔记："></a>笔记：</h3><p>这个BOM物料清单！这不是经管考点嘛。<br>目标：节能减排，到转变经济增长方式，合理利用资源，优化企业生产结构的目的，从而建设一个资源节约型、环境友好型社会。<br>以使节能减排评估与企业现有信息化有机结合和无缝集成，从而在实现了企业节能减排评估设计的基础上，盘活了企业现有信息化系统，实现了企业的信息化增效。<br>目前，温室气体减排对于全面实施节能减排有重要意义，而有了产品生命周期温室气体排放评估，便可以计算产品碳足迹，在商品上添加碳标签，引导消费者购买更低碳的商品，实现减排。同时</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>本文提出一种基于BOM的节能减排评估方法，实现企业节能减排评估设计与信息化的有机结合。节能减排的两种方法——计算碳足迹，添加碳标签以引导消费者购买更低碳的商品、把二氧化碳排放权作为一种商品，形成的二氧化碳排放权交易，都依赖于对产品生命周期温室气体排放的评估。于是本文提出基于物料清单的节能减排评估，其结构包括应用层、核心功能层和数据支撑层，其中应用层包括用户管理、节能减排数据采集与统计、节能减排指标评价与分析、节能减排设计和结果可视化；核心功能层负责链接应用层和数据支撑层；数据支撑层负责存放用户和企业数据以及减排的指标。其运作流程如下：完善企业减排基础数据库；对产品生命周期建模；基于BOM对产品生命周期模型中各个环节进行属性添加；计算各个环节的能耗和排放数据，进行节能减排评估；对照标准判定模型可用性，迭代得到最优方案。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><h3 id="题目：基于OWL—P的产品开发过程共享信息语义描述"><a href="#题目：基于OWL—P的产品开发过程共享信息语义描述" class="headerlink" title="题目：基于OWL—P的产品开发过程共享信息语义描述"></a>题目：基于OWL—P的产品开发过程共享信息语义描述</h3><h3 id="笔记：-1"><a href="#笔记：-1" class="headerlink" title="笔记："></a>笔记：</h3><p>为缩短开发时间，提高企业的竞争力，复杂产品开发的许多阶段都由分布在不同地点、实现不同功能的学科团队合作完成，这就需要产品开发过程中的各种信息能够被顺畅地交换和共享。<br>本体作为“共享概念模型的明确的形式化规范说明”，提供了形式化描述知识的基础，使系统之间的知识级共享和集成成为可能。<br>太硬了太硬了啊啊啊…我看不懂了……这充满了离散数学的逻辑……</p><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>为缩短复杂产品的开发时间，提高企业的竞争力，企业需要对交换的静态结构信息（各个原件的概念、属性等）和动态特征信息（不同组件的连接顺序、内部数据流关系、对外接口、装配顺序等）进行语义化描述。故本文提出利用面向过程的Web本体描述语言，构造产品共享信息模型。在OWL语法基础上定义语义、关系以及运算规则，建立了一个逻辑运算系统，提出了可以同时描述静态结构和动态特性的OWL—P语言，满足复杂产品的抽象、产品的知识共享、以及产品的知识推理。</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><h3 id="题目：基于云制造平台企业合作演化仿真系统的设计与实现"><a href="#题目：基于云制造平台企业合作演化仿真系统的设计与实现" class="headerlink" title="题目：基于云制造平台企业合作演化仿真系统的设计与实现"></a>题目：基于云制造平台企业合作演化仿真系统的设计与实现</h3><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p>云制造：云制造是为降低制造资源的浪费，借用云计算的思想，利用信息技术实现制造资源的高度共享。建立共享制造资源的公共服务平台，将巨大的社会制造资源池连接在一起，提供各种制造服务，实现制造资源与服务的开放协作、社会资源高度共享。企业用户无需再投入高昂的成本购买加工设备等资源，咨询通过公共平台来购买租赁制造能力。<br>在理想情况下，云制造将实现对产品开发、生产、销售、使用等全生命周期的相关资源的整合，提供标准、规范、可共享的制造服务模式。这种制造模式可以使制造业用户像用水、电、煤气一样便捷地使用各种制造服务。</p><p>但由于市场的开放性，会有很多因素影响交易的进行。<br>为应对云制造服务平台的不稳定性，进行仿真系统的设计。<br>其结构如下：</p><ul><li>记录每个企业的基本信息+交易信息，其中包括可调节的服务质量和服务时间</li><li>管理线程：交易频率+交易对象+交易状态<br>结果：</li><li>产生可视化交易网格</li><li>将不同规则约束下的仿真中交易发生的频率对比实际，得到演化后企业利润</li><li>同时可以通过此仿真模型来调整平台的规则，避免个体、团体垄断出现，平衡平台中企业利润的分配</li></ul><h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>此文以利用云计算的思想，使制造资源的高度共享，以降低制造资源浪费的云制造平台为背景，介绍了一个企业合作演化仿真系统。该系统结构包括两个部分，资源池和其上的仿真管理平台，其中资源池中记录每个企业的可调的基本信息与变动的交易信息，而仿真管理平台又分为线程管理（即交易频率、交易对象、交易状态）、交易过程管理（此次交易的现金流、对质量的评价等）及规则接口管理（以一定规则对交易对象进行排序，如企业位置、服务价格、服务时间、服务质量等）三个主要模块。（注：这里原文的实际写作顺序和概括性话语的顺序不一样。）该仿真平台可调整的参数包括：线程数量的随机程度，企业的位置、服务质量、服务时间，交易的服务时间误差，交易排序规则。其用途体现在，其一，仿真结果可以将不同规则约束下的仿真中交易发生的频率对比实际，得到演化后企业利润；其二，可以通过此仿真模型来调整平台的交易规则，避免个体、团体垄断出现，同时平衡平台中企业利润的分配。</p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>大概是我境界不够或者文章有些年头了？<br>感觉这篇文章起在了一个我并不了解的地方，确实有其用处，但这个模型过于粗糙了。<br>首先，一上来我就没有看懂文章里写的云计算是什么意思。因为他真的没有突出云制造和现在的交易市场的区别在哪里——交易对象是放眼到整个世界中算出来的。或者说，他这个论文太短了，什么都没说清就过去了。<br>其次，这个变量也太多了，如何贴合实际的进行调整，本人认为这不应该是交由人类来做的事情，文章也没有说，只是提出了这么一个平台的概念。这个规则到底由不由平台制定，由谁制定，这都很难说。特别是这样的云制造，它会涉及国家之间的贸易往来，那请问这个模型是否还有其他意义？或者，这个规则还能怎么制定？所以本人认为，这个模型建立的非常粗糙，看似用了很多随机数模拟真实情况（但有没有考虑中心极限定理哇！），但有些脱离实际。而且，这个交易本身也是被抽象出来的，实际上的交易可能涉及链状等复杂情况，也可能涉及诸多感性联系的影响，很难模拟。<br>并且，至于他到底多有用，也没有一个用于评估价值的系统与之呼应（满脑子loss函数了属于是），最后只给了我三张只写了一个图注的图，让我来猜他们是什么意思。所以它的用途也仍有待考究。<br>总结一下，就是面向的问题太大太广，提出的方法太模糊，成品太粗糙。</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><h3 id="题目：面向产品全生命周期的制造资源优选及组合方法研究"><a href="#题目：面向产品全生命周期的制造资源优选及组合方法研究" class="headerlink" title="题目：面向产品全生命周期的制造资源优选及组合方法研究"></a>题目：面向产品全生命周期的制造资源优选及组合方法研究</h3><p>将服务分为两类：单一资源服务需求任务和多资源服务需求任务<br>目标问题：服务的优选<br>服务属性：前端属性是指该类服务处在制造全生命周期的后一个制造环节，被其他制造资源调用时所用到的匹配属性；后端属性是指该类资源处在制造全生命周期的前一个环节时，调用其他服务所用到的匹配属性。连续型；离散型。正向属性是指当某类属性的取值变大时，制造代价也变大；负向属性反之。</p><ul><li><p>解决方法：</p><ul><li><p>单服务：</p></li><li><p>使用权值计算法，对服务属性进行加权，用公式 $ Price(s) = \frac{1}{\sum_{n}^{i=1} {w(a_i)}}\sum_{n}^{i=1} {w(a_i)a_i} $ ，但若此时约束条件不为0，则$ Price = +\infty$</p></li><li><p>约束条件包括：</p><p>$<br>status =<br>\begin{cases}<br>0,  &amp; \text{资源可用} \<br>1, &amp; \text{资源不可用}<br>\end{cases}<br>$</p><p>$<br>加工精度 =<br>\begin{cases}<br>0,  &amp; \text{实际加工精度 &gt;= 用户期望} \<br>1, &amp; \text{资源不可用 &lt; 用户期望}<br>\end{cases}<br>$</p><p>$<br>服务类型系数 =<br>\begin{cases}<br>0,  &amp; \text{服务类型匹配} \<br>1, &amp; \text{服务类型不匹配}<br>\end{cases}<br>$</p><p>三者相加得到最终约束条件。</p></li><li><p>此时得到了所有服务的price，由低到高排序得到最佳匹配服务。</p></li></ul></li><li><p>多服务组合优选</p><ul><li>$ Price(service_i) = \sum_{正向因素} {r_ja_{ij}}  - \sum_{负向因素} {r_ja_{ij}}$ ，其中 $r_j$ 表示j个属性的权值，$ a_{ij}$ 表示第i个服务的j个属性大小</li><li>最优服务组合即最优个体相加得到</li></ul></li></ul><h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><p>此文运用云制造系统服务云池的理论，结合制造业产业链中产品全生命周期理论，对单一资源服务需求任务和多资源服务需求任务分别建立模型进行仿真。文章将服务的属性分为前端属性、后端属性；连续型、离散型；正向属性、负向属性。</p><p>对于单一资源服务，文章采用使用权值计算法，对服务属性进行加权，得到如下制造代价的公式：<br>$ Price(s) = \frac{1}{\sum_{n}^{i=1} {w(a_i)}}\sum_{n}^{i=1} {w(a_i)a_i} $ ，受到以下三个条件的约束：</p><p>$<br>status =<br>\begin{cases}<br>0,  &amp; \text{资源可用} \<br>1, &amp; \text{资源不可用}<br>\end{cases}<br>$</p><p>$<br>加工精度 =<br>\begin{cases}<br>0,  &amp; \text{实际加工精度 &gt;= 用户期望} \<br>1, &amp; \text{资源不可用 &lt; 用户期望}<br>\end{cases}<br>$</p><p>$<br>服务类型系数 =<br>\begin{cases}<br>0,  &amp; \text{服务类型匹配} \<br>1, &amp; \text{服务类型不匹配}<br>\end{cases}<br>$</p><p>三者相加得到最终约束条件。但若约束条件不为0，则$ Price = +\infty$。<br>由此此时得到所有服务的制造代价，由低到高排序得到最佳匹配服务。</p><p>而对于多服务组合优选的模型建立，本文采取个体相加得到组合最优的策略，运用加权公式$ Price(service_i) = \sum_{正向因素} {r_ja_{ij}}  - \sum_{负向因素} {r_ja_{ij}}$ 计算每个服务的代价 ，其中 $r_j$ 表示j个属性的权值，$ a_{ij}$ 表示第i个服务的j个属性大小。在多资源的任务中，每一个进程选择下一项服务时都通过对这种服务的制造代价由低到高排序得到下一步的最佳匹配服务，即转化为多个单环节服务优选模型组合构成。</p><p>此模型可以用于解决云制造系统基于产品全生命周期的制造资源和服务的选优和组合优化的问题，但未考虑时间对属性等因素的影响。</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><h3 id="题目：云制造资源服务能耗评估及应用"><a href="#题目：云制造资源服务能耗评估及应用" class="headerlink" title="题目：云制造资源服务能耗评估及应用"></a>题目：云制造资源服务能耗评估及应用</h3><h3 id="笔记：-2"><a href="#笔记：-2" class="headerlink" title="笔记："></a>笔记：</h3><p>本文利用物联网技术对制造硬资源(设备资源、物料资源、基础设施资源等)的能耗信息进行感知和采集，针对不同类型的硬资源，采取不同的物联网感知技术与适配技术，对已感知的能耗信息进行描述，满足云制造平台对资源粗耦合接入的需求，将异构的资源整合到统一的云基础架构中并实现标准化、服务化提供支持。</p><p>（这个文档有两页有问题，是白页）</p><h3 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h3><p>本文从考虑降低能耗的角度提出了一种基于物联网的云制造资源服务能耗综合评估框架和云制造服务能耗计算模型。其中，云制造资源服务能耗综合评估框架主要由物联网技术进行的数据采集、评估、以及用户接口来提供评估应用三个部分组成。而能耗计算模型面向服务的云制造模式，更注重过程，能耗问题研究主要在服务准备能耗、服务优化组合能耗、服务配置能耗、服务使用能耗、服务处置能耗和回收能耗等阶段。云制造服务能耗计算矩阵用于计算若干任务单位在正常载荷、空载、附加载荷 (或者是损失能耗) 状态下所消耗的某种一次能源、 二次能源及能耗工质；任务的综合耗能公式为能耗折煤量之和；服务的综合能耗为可定量的某类基本单位服务所需要的能耗。再由约束条件，可得出资源服务能耗的评估系统。由此模型可初步探索出如何加强制造资源的节能调度、进行全过程管理， 进一步推动云制造的研究。</p><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><h3 id="题目：云制造资源虚拟化研究"><a href="#题目：云制造资源虚拟化研究" class="headerlink" title="题目：云制造资源虚拟化研究"></a>题目：云制造资源虚拟化研究</h3><h3 id="笔记：-3"><a href="#笔记：-3" class="headerlink" title="笔记："></a>笔记：</h3><p>CPS是一个综合计算、网络和物理环境的复杂系统，通过3C技术(计算(Computation)、通信(Communication)和控制(Control))的融合，实现物理世界与虚拟世界的相互作用，提供实时感知、动态控制和信息反馈等服务.<br>物联网侧重于物与物之间的互联以达到世界万物的联通与感知，例如对于物流物品的跟踪监控；而CPS在物与物互联与感知的基础上，则更侧重于对物的反馈控制，实现人、机、物的融合与协作。</p><h3 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a>总结：</h3><p>本文在云制造基础上提出了云制造资源虚拟化的框架，主要分为制造资源、物联网／CPS基础设施、物理资源历、虚拟资源云池以及虚拟资源管理这五个层次。其中制造资源又分为硬制造资源和软制造资源，硬制造资源可在云计算概念下被虚拟化；虚拟资源云池建立物理（物理资源历）与虚拟制造资源之间的映射关系。在虚拟化支持下的云制造关键技术包括资源的智能感知与控制、服务环境的按需动态构建、动态调度、环境的高可靠协同运行与容错迁移、人机交互、及多级安全隔离和访问控制。云制造资源虚拟化可以使软硬资源共享更加全面深入，提高效率和安全性，实现节能降耗。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>helloworld</title>
      <link href="/2022/01/24/helloworld/"/>
      <url>/2022/01/24/helloworld/</url>
      
        <content type="html"><![CDATA[<h1 id="Yblog-的诞生"><a href="#Yblog-的诞生" class="headerlink" title="Yblog 的诞生"></a>Yblog 的诞生</h1><h3 id="一-拥有自己的github-page"><a href="#一-拥有自己的github-page" class="headerlink" title="一   拥有自己的github page"></a>一   拥有自己的github page</h3><ol><li>拥有一个github账号（并牢牢记住用户名和密码！！！）。</li><li>点击右上角加号，再点击new repository。<img src="/2022/01/24/helloworld/image-20220124203950430.png" class="" title="image-20220124203950430"></li><li>Repository name设为用户名.github.io，勾选Add a README file，点击创建。<img src="/2022/01/24/helloworld/image-20220124204325686.png" class="" title="image-20220124204325686"></li></ol><h3 id="二-安装Node-js"><a href="#二-安装Node-js" class="headerlink" title="二   安装Node.js"></a>二   安装Node.js</h3><p>安装选项全部默认。<br>测试：cmd中输入node -v和npm -v，出现版本号。</p><h3 id="三-安装Git"><a href="#三-安装Git" class="headerlink" title="三   安装Git"></a>三   安装Git</h3><p>安装选项全部默认。<br>测试：cmd中输入git –version，出现版本号。</p><h3 id="四-安装hexo"><a href="#四-安装hexo" class="headerlink" title="四   安装hexo"></a>四   安装hexo</h3><ol><li>在合适的地方新建一个文件夹，用来存放自己的博客文件。</li><li>在新建的文件夹中右键，选择Git Bash Here，打开git的控制台窗口</li><li>输入npm i hexo-cli -g，安装hexo<img src="/2022/01/24/helloworld/image-20220124204809173.png" class="" title="image-20220124204809173">测试：输入hexo -v，出现版本号。</li><li>初始化：输入hexo init初始化文件夹，接着输入npm install安装必备的组件。</li></ol><h3 id="五-关联github和本地"><a href="#五-关联github和本地" class="headerlink" title="五   关联github和本地"></a>五   关联github和本地</h3><ol><li>在git bash中输入git config –global user.name “用户名”</li><li>输入git config –global user.email “邮箱”</li><li>生成密钥SSH key：ssh-keygen -t rsa -C “邮箱<br>&lt; 一张不能对外显示的图片 &gt;<br>此时我们获得了一个很可爱的小方盒子。</li></ol><p>&lt; 一段不能对外显示的字符串 &gt;</p><ol start="4"><li>输入cat ~/.ssh/id_rsa.pub，将输出复制出来：</li></ol><p>&lt; 一段不能对外显示的字符串 &gt;</p><ol start="5"><li><p>打开github网页，点击自己的头像找到settings，然后找到SSH and GPG keys一栏，新建一个ssh key。把第4步复制出来的key粘贴到下面的key文本框中，title随便起一个就行。</p><img src="/2022/01/24/helloworld/image-20220124205724033.png" class="" title="image-20220124205724033"></li><li><p>测试：输入ssh -T <a href="mailto:&#103;&#105;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#109;">&#103;&#105;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#109;</a>。</p><img src="/2022/01/24/helloworld/image-20220124205918174.png" class="" title="image-20220124205918174"></li><li><p>打开博客根目录下的_config.yml<br>修改并扩充最后一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/用户名/用户名.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>修改/scaffolds/post.md中内容为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">top: false</span><br><span class="line">cover: false</span><br><span class="line">password:</span><br><span class="line">toc: true</span><br><span class="line">mathjax: true</span><br><span class="line">summary:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br></pre></td></tr></table></figure></li><li><p>由于这个博客用的是master这个branch，于是在项目页面下找到settings</p><img src="/2022/01/24/helloworld/image-20220124210633409.png" class="" title="image-20220124210633409"><p>然后就在options中使劲往下划，直到看到github pages的条目：</p><img src="/2022/01/24/helloworld/image-20220124210744886.png" class="" title="image-20220124210744886"><p>点击check it out here，修改sourse，并点击save。<img src="/2022/01/24/helloworld/image-20220124210907304.png" class="" title="image-20220124210907304"></p></li></ol><h3 id="六-发布文章！"><a href="#六-发布文章！" class="headerlink" title="六   发布文章！"></a>六   发布文章！</h3><p>终于到这里了！</p><ol><li>在根目录下打开git bash，输入npm i hexo-deployer-git。</li><li>新建文章：hexo new post “helloword”</li><li>在/source/_post/ 目录下可以找到helloword.md</li><li>这种时候用什么编辑都行了。</li><li>生成静态网页：hexo g</li><li>本地预览：hexo s</li><li>上传github：hexo d</li></ol><h3 id="七-美化"><a href="#七-美化" class="headerlink" title="七   美化"></a>七   美化</h3><p>建议直接搜索hexo theme，任君挑选。<br>我使用了 <a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a> 这个主题，<del>（butterfly就是辉人啊！）</del>，通过阅读他给出的readme.md即完成了配置。</p><ol><li><p>在博客根目录打开git base，输入npm i hexo-theme-butterfly</p></li><li><p>打开博客根目录下的_config.yml，找到里面的theme这一句，没记错的话在很靠下的地方，改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure></li><li><p>其实不需要这一步，但万一第二步失败了可以尝试。（这只蒟蒻是因为太心急了，还没刷新出来就以为失败了所以多做了一步）输入npm install hexo-renderer-pug hexo-renderer-stylus即可。</p></li></ol><p><strong>完美！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/24/hello-world/"/>
      <url>/2022/01/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
