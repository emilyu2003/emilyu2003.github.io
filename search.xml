<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>毕设文献笔记（一）</title>
      <link href="/2024/01/10/%E6%AF%95%E8%AE%BE%E6%96%87%E7%8C%AE%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/01/10/%E6%AF%95%E8%AE%BE%E6%96%87%E7%8C%AE%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="毕设文献笔记一">毕设文献笔记（一）</h1><h2 id="triangle-counting-in-large-networks-a-review">Triangle countingin large networks: a review</h2><p>综述型文章，介绍三角形计数的应用场景、常见方法。</p><h3 id="基础概念">基础概念</h3><h4 id="定义">定义</h4><p><code>G(V,E)</code>：简单连通无向图，无重边</p><p><code>d(u)</code>：度，最大为<span class="math inline">\(d_{max}\)</span></p><p><code>adj(u)</code>：和点u相邻的节点集合</p><p><code>inc(u)</code>：和点u连接的边</p><p><code>inc(e)</code>：和边e相连的点</p><p><code>triple(u, v, w)</code>：以点v为中心的三元组，（形如u-v-w则为开放的，形成三角形则为封闭的）</p><p><code>triangle</code>：由三个封闭的三元组组成</p><p><span class="math inline">\(\Pi_v\)</span>：以v为中心的三元组的集合，全集为<span class="math inline">\(\Pi\)</span></p><p><span class="math inline">\(\Lambda\)</span>：三角形的集合</p><p><code>t(G)</code>：G中三角形数量</p><p><span class="math inline">\(\gamma(G)\)</span>：传递度，封闭的三元组数量 /三元组数量，即<span class="math inline">\(t(G) =\frac{1}{3}\gamma(G)|\Pi|\)</span></p><h4 id="metropolis-hastings-algorithm">Metropolis-HastingsAlgorithm</h4><p>Markov Chain Monte Carlo 采样的变体，结合参考资料第一篇才能看懂</p><p><img src="image-20231226171744114.png" alt="image-20231226171744114" style="zoom:50%;"></p><h4 id="importance-sampling">Importance Sampling</h4><p>重要性采样的基本思想是对概率函数密度高的区域尽量多采样，对概率密度值低的区域少采样。</p><h3 id="文章结构">文章结构</h3><p><img src="image-20231226172939492.png" alt="image-20231226172939492" style="zoom:150%;"></p><h3 id="三角形准确计数-随机访问">三角形准确计数 + 随机访问</h3><p>假设：可O(1)获取点的临边，adj(u)有序（于是可以O(logN)用二分回答是否存在特定边，但由于最坏情况才到对数级，且平均度数一般都是常数，所以也可以视作常数时间；或者用hash也可以O(1)）</p><h4 id="只计数">只计数</h4><ol type="1"><li>邻接矩阵的乘法</li></ol><ul><li><span class="math inline">\(A^3[i, i]\)</span> =从i到i走三步的方法数</li><li>所以如果有三角形，会被算两次（顺逆时针各一次），而且三个顶点还会各算一遍</li><li>于是一个三角形反映到<span class="math inline">\(A^3\)</span>的迹上会被算6次，即<span class="math inline">\(t(G) = \frac{1}{6}Tr(A^3)\)</span></li><li>复杂度<span class="math inline">\(O(n^3)\)</span></li></ul><ol start="2" type="1"><li>AYZ（文章在念经，一定是这样）</li></ol><ul><li>定义$Δ = m^{(ω − 1)/(ω + 1)} <span class="math inline">\(，其中\)</span>m$为边数</li><li>高度数：度数 &gt; <span class="math inline">\(\Delta\)</span>，低度数反之</li><li>对于低度数的顶点，可以遍历每一条边(u,v)，如果v是低度数顶点，再遍历v的邻接边，所以复杂度为<span class="math inline">\(O(m\Delta)\)</span>，可计算出所有包含了低度数顶点的三角形</li><li>对于高度数的顶点，上一步没有统计到的三角形三个顶点一定都高度数的，所以先用这些顶点构建生成子图，再用上面的邻接矩阵乘法求三角形数量，复杂度为<span class="math inline">\(O(|高度数顶点个数|)^\omega\)</span>，其中高度数顶点个数小于<span class="math inline">\(2m/\Delta\)</span></li><li>二者相加，总时间复杂度为<span class="math inline">\(O(m^{2ω/(ω +1)})\)</span></li></ul><h4 id="既计数又列举">既计数又列举</h4><ol type="1"><li>Itai and Rodeh 的古早方法</li></ol><ul><li>找到一个生成树，对于生成树中的每条边(u,v)，寻找u的前驱是否在图中，在则说明构成了一个三角形，对v同理</li><li>然后把该边删去，重新构建生成树</li><li>重复上述步骤，直到图中没有边了</li><li>每次检查需要O(m)的时间，最多<span class="math inline">\(O(\sqrt{m})\)</span>次，所以总时间复杂度是<span class="math inline">\(O(m^{\frac{3}{2}})\)</span>，但是数据结构耗时很多</li></ul><ol start="2" type="1"><li>Node Iterator Algorithm</li></ol><ul><li>上一种的改版</li></ul><ol start="3" type="1"><li>Edge Iterator Algorithm<img src="image-20231226194603051.png" alt="image-20231226194603051" style="zoom:67%;"></li></ol><ul><li>复杂度是<span class="math inline">\(O(m \cdot d_{max})\)</span></li></ul><h4 id="关于上界">关于上界</h4><p>前提：避免重复计数 + 边存在性可以O(1)检查</p><p><img src="image-20231226195114862.png" alt="image-20231226195114862" style="zoom:50%;"></p><p>懒得翻译了，挺清晰的。</p><h3 id="近似三角形计数-随机访问">近似三角形计数 + 随机访问</h3><p>（一些上学期的痛苦回忆涌向了我）</p><h4 id="基于稀疏化的方法">基于稀疏化的方法</h4><ul><li>取边的子集，在稀疏图上数准确的三角形数（所以复杂度都受这个限制），然后推算出原图的三角形数</li><li>可以视作一种均匀取样</li></ul><ol type="1"><li>DOULION</li></ol><ul><li>生成稀疏图<span class="math inline">\(G_s\)</span>：以p概率保留边，1-p去掉边，所以一个三角形被保留的概率为<span class="math inline">\(p^3\)</span></li><li>获得准确的<span class="math inline">\(t(G_s)\)</span></li><li>所以估计值为<span class="math inline">\(\hat{t}(G_s) =\frac{1}{p^3}t(G_s)\)</span></li></ul><ol start="2" type="1"><li>colorful triangle counting</li></ol><ul><li>对每个点随机染一个颜色（1-N），只保留两端点颜色相同的边。和DOULION很相似，只不过这里的<span class="math inline">\(p =\frac{1}{N}\)</span>，三角形被保留的概率为<span class="math inline">\(p^2\)</span>（如果一个三角形被保留两边，那么三个点同色，第三边一定也在）</li><li>获得准确的<span class="math inline">\(t(G_s)\)</span></li><li>所以估计值为<span class="math inline">\(\hat{t}(G_s) =\frac{1}{p^2}t(G_s)\)</span></li><li>准确性较DOULION更好</li></ul><ol start="3" type="1"><li>Etemadi et al.的方法</li></ol><ul><li>和DOULION相似，同样以p概率保留边，1-p去掉边，不过在数生成图中的三角形时会检查生成图中开口三角形的第三边原图中有没有，即三角形被保留的概率为<span class="math inline">\(p^2\)</span></li><li>所以估计值为<span class="math inline">\(\hat{t}(G_s) =\frac{1}{p^2}t(G_s)\)</span></li><li>准确性较DOULION更好</li></ul><h4 id="基于三元组采样的方法">基于三元组采样的方法</h4><ul><li>对传递度的无偏估计，需要均匀的分布，最简单的方法是随机取一点，然后在该点的相邻节点集中随机取两点，这样会导致高度数点的三元组采样不足，低度数点的三元组采样过度</li><li>采样一些三元组，计算其中封闭的三元组占所有采样的比例</li></ul><ol type="1"><li>Schank and Wagner 的采样方法</li></ol><ul><li>按以该点为中心的三元组数量为比例，对点进行采样，然后随机返回其中一个三元组</li></ul><ol start="2" type="1"><li>Schank et al. 和 Kolda et al. 的方法</li></ol><ul><li>用上面的采样方法，近似计算了传递度</li><li>用Hoeffding Bound证明了近似error bound</li></ul><ol start="3" type="1"><li>Al Hasan 的方法</li></ol><ul><li>即使在不均匀的采样下可能得到传递度的无偏估计</li><li>重要性采样</li></ul><h4 id="边或点采样的近似计数">边或点采样的近似计数</h4><ol type="1"><li>Rahman and Al Hasan 的方法（他刚出现过）</li></ol><ul><li>先对点采样，然后取其中的占比为p的一部分，数三角形，最终答案就是sum/p</li><li>还证明了对边采样的准确度更好</li><li>虽然对三角形的采样不是均匀的，但依旧是无偏的</li></ul><h4 id="基于线性代数的方法">基于线性代数的方法</h4><ul><li>回到一开始的矩阵相乘方法，由于是无向图，所以A是实对称的-&gt;特征值都是实数</li><li>准确计数需要计算准确的特征值来获得<span class="math inline">\(Tr(A^3)\)</span>，太慢了</li><li>这里虽然不知道为什么，但是文章说现实的网络服从幂律，所以邻接矩阵是歪的（skewed），特征值也是歪的，也服从幂律【大大的问号】</li></ul><ol type="1"><li>EigenTriangle algorithm</li></ol><ul><li>只要前k个特征值</li><li>【不太小的问号】</li><li>时间和准确度的平衡不好</li><li>（tolerance parameter）不能保证准确性</li></ul><h3 id="限制访问下的三角形计数">限制访问下的三角形计数</h3><ul><li>最适合基于随机游走的近似方法</li><li>Rahman and Al Hasan 提供了一堆随机游走的方法（又是他们）</li></ul><h4 id="在点上随机游走">在点上随机游走</h4><ul><li>前面提到了随机采样一个点，然后随机采样以这个点为中心的三元组的方法</li><li>这里的随机游走就是用来第一步采样点的，要求是采样的分布使三角形计数无偏</li><li>最简单的方法就是随机的从邻居节点中取下一个节点，这样不是无偏的，所以需要利用重要性采样</li></ul><ol type="1"><li>Vertex-MCMC</li></ol><ul><li>没有用IS，用的是MH找到稳定分布<span class="math inline">\(\pi \sim\left( \begin{matrix} d(\cdot) \\ 2 \end{matrix}\right)\)</span>，其中<span class="math inline">\(d(·)\)</span>是点的度数</li><li><img src="image-20231227161513884.png" alt="image-20231227161513884" style="zoom:50%;"></li></ul><h4 id="在三元组上随机游走">在三元组上随机游走</h4><ul><li>直接采样三元组，不采用上面两步走的策略</li><li>还是这两位，Rahman and Al Hasan 又提供了一堆随机游走的方法</li></ul><ol type="1"><li>triple-MCMC</li></ol><ul><li>在三元组的集合上定义了一个邻居图，什么样的都行，这二位把它定义成有两个点一样的三元组为邻居</li><li>从任意的三元组开始，每次随机的找和当前三元组有一个节点不同的节点作为下一步</li><li>但用在数三角形时，这样不能保证是均匀的采样，于是用MH算法添加一个接受率</li><li>当然也可以用IS做采样得到传递度的无偏估计，但要求总三元组数是已知的</li></ul><h3 id="流数据的三角形计数">流数据的三角形计数</h3><ul><li>边顺序任意的流</li></ul><ol type="1"><li>Bar-Yossef et al. 的古早方法</li></ol><ul><li>基于stream-reduction（我的中文失灵了）的方法</li><li>为了理论而，不实用</li></ul><ol start="2" type="1"><li>Buriol et al. 的方法们</li></ol><ul><li>基于边的流</li><li>过三趟流的算法<ul><li>第一趟记录点的数量n和边的数量m</li><li>第二趟随机取一条边和一个点，获得一个三元组（不需要三个点都是连通的）</li><li>第三趟看这个三元组是不是个三角形，是则把随机变量<span class="math inline">\(\beta\)</span>记为1，否则记为0</li><li><span class="math inline">\(E(\beta) = \frac{3T_3}{T_1 + 2T_2 +3T_3} = \frac{3T_3}{m\cdot (n-2)}\)</span>，其中<span class="math inline">\(T_1\)</span>是不连通的三元组数量，<span class="math inline">\(T_2\)</span>是开口的三元组数量，<span class="math inline">\(T_3\)</span>是三角形的数量，用边的数量可推此式</li><li>所以可以跑多次这个算法，获得平均的<span class="math inline">\(\beta\)</span></li><li>用切诺夫界证明了近似结果的可能性界</li></ul></li><li>过两趟流的算法<ul><li>第一趟：上一个算法的1+2，其中采样的时候采用reservoirsampling，即把见到的第一个存下来，之后遇到的第i个有1/i的概率把它替换</li><li>第二趟：上一个算法的3</li></ul></li><li>一趟算法<ul><li>如果被暂存的点和边之间的两条边流过了，那么把对应的变量设为1，如果流完后发现对应两条边的变量都为1，那么把随机变量<span class="math inline">\(\beta\)</span>记为1，否则记为0，代表是否采样到过一个三角形</li><li>但是这时<span class="math inline">\(E(\beta) = \frac{T_3}{T_1 + 2T_2+ 3T_3} = \frac{T_3}{m\cdot(n-2)}\)</span>，因为只有当被暂存的边在被暂存的点和其之间的两条边流过之前流过才有可能采样到这个三角形，这个概率是1/3</li></ul></li></ul><ol start="2" type="1"><li>Jha et al. 的方法</li></ol><ul><li><p>一趟流</p></li><li><p>定义<span class="math inline">\(\{G_t\}_{1 \leq t \leqm}\)</span>是t时刻由已经流过的边（共m条）形成的图，每来一条边就更新一次估计</p></li><li><p>用两个reservoir序列列，一个存边的采样，一个存三元组的采样</p></li><li><p>每有一条新边到来，检查它能与多少三元组的采样形成封闭的三角形，然后更新两个序列（按一定概率插入第一个存边的采样，插入成功再按一定的比例把该边和边采样中结合形成的连通的三元组插入存三元组的采样）</p></li><li><p>后面看不懂啦【不太大的疑问】</p></li><li><p><img src="image-20231227170346281.png" alt="image-20231227170346281" style="zoom:50%;"></p></li><li><p>生日悖论：看起来离谱但是是对的的事件</p></li></ul><h3 id="分布式和并行的三角形计数">分布式和并行的三角形计数</h3><ul><li>使用MapReduce框架</li></ul><ol type="1"><li>Suri and Vassilvitskii. 的方法</li></ol><ul><li>第一轮从边集中并行生成//图中所有长度为2的路径</li><li>第二轮计算在第一轮生成的长度为2的路径中有多少条在图中有闭合边</li><li>还可以基于图的分治做，并行地对每个子任务跑准确计数</li><li>Park and Chung 发现了这个方法中的冗余，提出了下面的方法</li></ul><ol start="2" type="1"><li>Triangle Type Partitioning</li><li>Pagh and Tsourakakis 的方法</li></ol><ul><li>在边采样的基础上提出的并行方法，所以是近似计数</li></ul><ol start="4" type="1"><li>Arifuzzaman et al. 的方法</li></ol><ul><li>基于分布式存储的并行算法，使用消息传递接口</li><li>用连通分量对图进行划分，并从节点子集及其邻域生成导出子图</li><li>每个导出子图都分别在一个机器上跑，计数并相加</li></ul><ol start="5" type="1"><li>Kim et al. 的方法</li></ol><ul><li>基于磁盘的架构，使用多核CPU</li><li>根据两个相邻节点各自的邻居列表是否都在内存里划分为内部三角形和外部三角形（只有一个在）</li><li>（不是很有趣，我只是想找个理由不翻译了）</li></ul><ol start="6" type="1"><li>Shun and Tangwongsan 的方法：</li></ol><ul><li>多核并行算法</li><li>第一步对每个节点按程度进行排序，并行地生成每个节点的邻接表，邻接表中只包含比当前节点排名高的节点</li><li>第二步从每个节点的排序邻接表中对三角形进行计数</li></ul><ol start="7" type="1"><li>Rahman and Al Hasan 的方法（又双叒叕）</li></ol><ul><li>多核并行算法：将节点/边的遍历算法分布在多核上</li></ul><h3 id="实验结果比较">实验结果比较</h3><ul><li>准确计数的实验对比Schank做过了</li><li>所以这篇文章只做了近似计数的方法的对比</li><li>数据集用的是KONECT，但是它给的网址和我搜到的网址都访问不了了，不知道怎么回事</li><li>结论：基于稀疏化的方法都需要更多的时间才能达到与其他近似方法一样高的精度，都不如直接采样</li></ul><h3 id="其他的计数问题">其他的计数问题</h3><ul><li>比如k团（糟糕的回忆再次涌来），BronKerbosch algorithm</li><li>Graphletcounting（不是我不翻译，是我不知道怎么翻译），可能是这个：<img src="image-20231227185728511.png" alt="image-20231227185728511" style="zoom:50%;"></li><li>看到最后我才翻到前面去看作者，我说怎么AlHasan这位一直出现，原来这篇综述他是一作hhh</li></ul><h3 id="存在的问题">存在的问题</h3><ol type="1"><li>这段什么意思</li></ol><p><img src="image-20231227191604142.png" alt="image-20231227191604142" style="zoom:50%;"></p><ol start="2" type="1"><li>stream-reduction 如何理解？</li></ol><blockquote><p>Owing to the stringent requirements of efficiency in the streamingmodel, designing efficient algorithms via reductions turns out to be arather delicate matter. For example, consider a hypothetical streamingreduction R from problem A to problem B that works as follows: uponreading each data item in an instance (a stream) of problem A, thereduction R outputs a polynomially long sequence of data items toproduce an instance (a stream) of problem B.</p></blockquote><p>来源文章：<a href="https://dl.acm.org/doi/pdf/10.5555/545381.545464">Reductions inStreaming Algorithms, with an Application to Counting Triangles inGraphs</a></p><ol start="3" type="1"><li>这里是割点还是连通分量？</li></ol><p><img src="image-20231227191700446.png" alt="image-20231227191700446" style="zoom:50%;"></p><p>嗯，都不是，他只是随便分割了一下…见这里<a href="https://dl.acm.org/doi/pdf/10.1145/2505515.2505545">PATRIC: AParallel Algorithm for Counting Triangles in MassiveNetworks</a>，大概4.2章的位置</p><hr><p>关于这个领域的第一篇文章，大概对现有的方法有了点了解吧，看起来有的方法看起来还挺“简单”的，竟然这么有效…这是否也是一种生日悖论呢？</p><p>马尔科夫蒙特卡洛：https://zhuanlan.zhihu.com/p/143016455、https://zhuanlan.zhihu.com/p/619564589 、马尔科夫的一些补充：https://www.zhihu.com/question/46539491/answer/2266717985重要性采样：https://zhuanlan.zhihu.com/p/601619247</p><p>三角形准确计数AYZ：https://www.zhihu.com/question/36652212</p><p>数据集，以后可能有用？：https://blog.csdn.net/qq_24059779/article/details/85939043</p><p>图网络的结构信息概述：https://zhuanlan.zhihu.com/p/261418085</p><h2 id="how-to-count-triangles-without-seeing-the-whole-graph">How toCount Triangles, without Seeing the Whole Graph</h2><ul><li>第一个可证明的亚线性算法</li><li>getting estimates within 5% relative error by looking at 3% of thenumber of edges，开幕雷击啊</li></ul><h3 id="问题简述">问题简述</h3><h4 id="目标">目标</h4><p>设计一个三角形计数的<span class="math inline">\((\epsilon,\delta)-estimator\)</span>，意为算法在至少<span class="math inline">\(1-\delta\)</span>的概率下能输出<span class="math inline">\(\overline{T}\)</span>，使得<span class="math inline">\((1-\epsilon)T \leq \overline{T} \leq (1 +\epsilon)T\)</span></p><h4 id="随机游走访问模型">随机游走访问模型</h4><p><img src="image-20231228145711183.png" alt="image-20231228145711183" style="zoom:50%;"></p><ul><li>只能在已访问过的节点中进行度和边的查询</li><li>不知道图中总点、边数</li></ul><h4 id="均匀的点边采样">均匀的点/边采样</h4><ul><li>这篇文章的方法用不了</li><li>“the existing literature is surprisingly quiet”</li></ul><h4 id="复杂度指标">复杂度指标</h4><ul><li>虽然时间效率也挺好但不考虑时间问题</li><li>目的是减少查询的次数</li><li>一些数据集：soc-orkut(3M vertices, 213M edges), soc-siaweibo (59Mvertices, 523M edges), soc-twitter(42M vertices, 2.4B edges),socfriendster(66M vertices, 3.6B edges)</li></ul><h4 id="triangle-estimation-through-random-incidence-sampling">TriangleEstimation Through Random Incidence Sampling</h4><ul><li>本文的方法</li><li>基于团的计数方法</li><li>采样比例：边的低度数端点的度</li><li>很好，特别好，别人的都不行</li></ul><h4 id="引理3.1-d_e-sigma_e-in-ed_e-omalpha">引理3.1 <span class="math inline">\(d_E = \Sigma_{e \in E}d_e =O(m\alpha)\)</span></h4><ul><li>Degeneracy, or the maximum core number, is the smallest integer k,such that for every subgraph in the input graph, there is a vertex ofdegree at most k<br></li><li>用<span class="math inline">\(\alpha\)</span>表示输入图的degeneracy</li></ul><h4 id="用chernoff-bound分析本文算法">用Chernoff Bound分析本文算法</h4><h3 id="tetris">TETRIS</h3><ul><li>输入：随机游走的长度r、子采样的数量l、估计混合时间（马尔科夫链到达平稳分布的时间，回忆MCMC）</li><li>随机选一个点开始，走r步，把经过的边存下来，计算每个边的度（两个端点的度更小的那一个），然后以边的度为权重进行采样，共采样l条边</li><li>对于采样得到的边e，TETRIS再从他的邻居节点中（是度数更小的端点的邻点集）均匀随机的取一个点w，用边查询检查w和e能否构成三角形</li><li>如果可以形成三角形，检查这个三角形是否被指定到的是这条边（对点先按度数，次按字典序进行排序，一个三角形被指定到前两个顶点所连边上）</li></ul><p><img src="image-20231228155655008.png" alt="image-20231228155655008" style="zoom: 67%;"></p><ul><li>为了统计总共的三角形数量，需要估计总共的边的数量</li></ul><p><img src="image-20231228155736836.png" alt="image-20231228155736836" style="zoom:67%;"></p><ul><li>证明看不懂，alg2也没看懂，求助gpt，gpt说它看不了文章，很好，放着吧，TAT</li><li>文章说alg2的保证是 Probabilistic computations: Toward a unifiedmeasure of complexity这篇文章的直接推论，但…我更看不懂了</li><li>不过我大概理解了一下，按我的参考资料第一篇，“从<span class="math inline">\(x_0\)</span>出发，经过t步后采样一个点，再经过t步采样下一个点。也就是说采样<span class="math inline">\(x_t, x_{2t},\dots\)</span>。这样是能保证采样结果是依据平稳分布的，因为相当于把每次采一个点的算法重复了n次”，也就是第三行在干的事情</li><li><span class="math inline">\(Y_i\)</span>就是从采样中随便拿两条边出来，他们冲突的比例的倒数</li><li>哦！可以看附录里面的证明</li><li><img src="image-20231228191539441.png" alt="image-20231228191539441" style="zoom: 50%;"></li><li>重读代码，发现for循环这句被我省略了…所以一直看不懂第六行，所以这个算法相当于通过多次采样，以边重复的概率估计整体边集的大小</li><li>已知从一个大小为m的集合里有放回的取两个边，两个边一样的概率为<span class="math inline">\(\frac{m}{m \cdot m} =\frac{1}{m}\)</span>，所以第五行是那样的倒数</li><li>所以回过头来看算法1的12行，是在说总共的三角形数是估计的边数除以随机游走的路径长度再乘上采样的多重集的度这么多倍的采样到的三角形数，但这个怎么来的…后面倒是有不少对它是<span class="math inline">\((\epsilon,\delta)-estimator\)</span>的证明，但我目前还没有直观地理解</li></ul><h3 id="理论分析">理论分析</h3><p>天书</p><h3 id="实验评估">实验评估</h3><ol type="1"><li>以最小的参数化实现了对所有数据集的高精度</li><li>不一致性小，收敛</li><li>在大多数数据集上，始终优于其他基准算法</li><li>初始节点的选择不影响算法准确性</li></ol><h3 id="参考资料">参考资料</h3><p>混合时间（甚至还是马尔科夫链的东西）：https://zhuanlan.zhihu.com/p/143016455?utm_source=wechat_session&amp;utm_id=0</p><p>成对碰撞：https://zhuanlan.zhihu.com/p/142177195</p><h2 id="accelerating-triangle-counting-on-gpu">Accelerating TriangleCounting on GPU</h2><p>代码：https://github.com/pkumod/accelerating-TC</p><h3 id="概述">概述</h3><ul><li>北大的文章，之前在确定题目的时候搜到过，但是有关硬件的东西俺实在是调不来，所以当时只用来了解了一下三角形计数的概念</li><li>在不改变原来使用GPU的三角形技术方法的实现和数据结构的算法的情况下提出一种新的轻量级的图预处理方法</li><li>考虑 <code>workload</code> 的平衡和 <code>resource</code>的平衡</li><li>主要关注预处理</li></ul><ol type="1"><li>Edge Directing</li></ol><ul><li>这个文章说无向图会先辈转成有向图再进行三角形计数，这是我没有在前面的文章里看到的内容</li><li>分为基于编号和基于度数的</li><li><code>A-direction</code></li></ul><ol start="2" type="1"><li>Vertex Ordering</li></ol><ul><li><code>A-ordering</code></li></ul><h3 id="预备知识">预备知识</h3><h4 id="gpu">GPU</h4><ol type="1"><li>软件</li></ol><ul><li>CUDA语言采用block作为最小可编程单元</li></ul><ol start="2" type="1"><li>硬件</li></ol><ul><li>流多处理器（SM）</li><li>大但是慢的全局存储</li><li>小但是快的共享存储</li><li>一个block会被分配给一个SM</li><li>所以如果一个block中的任务们对资源的需求各不相同，就可以很好的并行</li><li>而且如果访问的存储区域一致，也能提高效率</li></ul><h4 id="相关工作">相关工作</h4><ol type="1"><li>GPU实现的三角计数</li></ol><ul><li>核心是workload平衡</li></ul><ol start="2" type="1"><li>CPU实现的三角计数</li></ol><ul><li>三类：点迭代、边迭代和前向算法</li><li>当然还有图化简和矩阵乘法的方法</li></ul><ol start="3" type="1"><li>LIst Intersection</li></ol><ul><li>列表中的交集？</li><li>两类方法：二分查找和排序-归并，二分查找更好</li><li>还有一些其他的合并方法</li></ul><h4 id="三角形计数中的同步">三角形计数中的同步</h4><ol type="1"><li>bisson的工作</li></ol><ul><li>太困了，看不懂</li><li>大概去一个点的两个邻点的邻点的交集（我故意的），总之这样就能形成一个三角形</li><li>也就是u-v-w型的三元组，可以通过在u的邻接点集合里二分查找w来优化</li></ul><h3 id="分析模型">分析模型</h3><ul><li>块内同步和二分搜索两种模型</li><li>看到最后的conclusion才明白，就是这篇文章首先提出了这样一个analyticmodel，基于这个模型中的两种处理方法（快内同步 /二分查找）提出了两种预处理（edge-directing / graph ordering）方法</li></ul><h4 id="块内批量同步并行">块内批量同步并行</h4><ul><li>Intra-block BSP(Bulk Synchronous Parallel) Model</li><li>每个superstep的运行时间取决于工作负载最大的线程</li><li>即需要平衡每个节点的邻点列表的大小</li><li>把无向图变成有向图，然后计算每个点的出度，使得$ () = _{u V()}{|d_o(u) - {d_o}|}$ 最小</li><li><span class="math inline">\(\mathcal{P}\)</span>就是选取的算法</li><li>NP-Hard</li></ul><h4 id="资源平衡模型">资源平衡模型</h4><ul><li>Resource Balance Model</li><li>在计算成本和内存访问成本之间平衡工作负载</li><li>合理的任务分配应该将具有不同工作负载特征(即内存密集型或计算密集型)的任务分组在一起，并将它们分派到一个块中</li><li>节点的排序（度数相近的放一起）很重要，A=order策略最好</li><li>排序后相邻的几个节点放到同一个桶里，一个桶分配给一个block</li><li><img src="image-20240109194754121.png" alt="image-20240109194754121" style="zoom:80%;"></li></ul><h4 id="二者的联系">二者的联系</h4><p>块内BSP模型的目的是实现块内更好的工作负载平衡，而顶点排序模型的目的是实现块间更好的资源利用。</p><h3 id="边的方向">边的方向</h3><h4 id="hardness-analysis">hardness analysis</h4><ul><li>我对<code>hardness</code>的理解只有hardness ofapproximation是不可近似性的意思，所以hardness…到底什么意思…太模糊了</li><li>是对<code>块内批量同步并行</code>中提到的把无向图转有向图的算法的分析</li><li>换成了0-1整数线性规划，这是NP-hard的</li><li><img src="image-20240109192050075.png" alt="image-20240109192050075" style="zoom:67%;"></li><li>其中要求得到的有向图没有任何长度为3的有向环（文章说这样的有向环不会被计数，所以要避免）</li></ul><h4 id="近似算法">近似算法</h4><ul><li>因为是NP-hard的，所以开发了一种<code>A-direction</code>策略</li><li>定义core vertex为 <span class="math inline">\(d(u) \geq \bar{d_o} =\frac{|E|}{|V|}\)</span>，否则为非核心节点</li><li>取舍边的过程：<ul><li>core - non core：<span class="math inline">\(v_n \rightarrowv_c\)</span></li><li>non core - non core：任意</li></ul></li><li>可以证明此方法不会比其他方法差</li><li><img src="image-20240109193348442.png" alt="image-20240109193348442" style="zoom:80%;"></li><li>不断地“削去”度数比当前threshold小的节点</li><li>根据𝑝𝑟𝑖𝑜𝑟𝑖𝑡𝑦和𝑟𝑢𝑛𝑡𝑖𝑚𝑒𝐷𝑒𝑔𝑟𝑒𝑒,边优先从早被削去的点指向晚被削去的点，然后从拥有较小的𝑟𝑢𝑛𝑡𝑖𝑚𝑒𝐷𝑒𝑔𝑟𝑒𝑒的顶点指向较大𝑟𝑢𝑛𝑡𝑖𝑚𝑒𝐷𝑒𝑔𝑟𝑒𝑒的顶点</li></ul><h4 id="近似比">近似比</h4><p><del>熟悉的痛苦经历，看不懂啊</del></p><ul><li>使用了符合幂律的图配置模型—ACL model</li><li>还有真实的数据集it2004、cit-Patent、com-lj、kron-log21</li></ul><h3 id="图中点的排序">图中点的排序</h3><ul><li>graph ordering</li><li>是针对<code>资源平衡模型</code>部分的公式(3)的分析</li></ul><h4 id="hardness-分析">hardness 分析</h4><ul><li>NP-hard</li><li>对于公式(3)，取特殊值（两个桶，<span class="math inline">\(b = 2,\lambda = 1\)</span>），目的是找到是否有一个对点的分配使得<span class="math inline">\(C_1 = M_1, C_2 = M_2 \; and \; C_1 \leq C_{max},C_2 \leq C_{max}\)</span>，其中名词：computational cost 𝐶𝑖 和 memoryaccess cost 𝑀𝑖，把这个算法成为<code>DP</code></li><li>首先<code>DP</code>算法一定属于NP，因为这样的分配可以在多项式时间内被验证</li><li>然后就是证明原问题可以在多项式时间内被归约到<code>DP</code>，且<code>DP</code>问题的解是原问题的解</li><li><code>DP</code>是NP-complete，所以原问题NP-hard</li></ul><h4 id="解决方法">解决方法</h4><ul><li>采用启发式的算法，贪心</li><li>把点以在邻接点集中二分查找时对存储的需求和计算的需求的多少，划分为存储主导和计算主导的两类</li><li>存储主导的点扔到内存资源需求最少的桶里（好怪）</li><li><img src="image-20240109200137789.png" alt="image-20240109200137789" style="zoom:80%;"></li><li><span class="math inline">\(𝑂(|𝑉|𝑙𝑜𝑔|𝐵|)\)</span> ，<span class="math inline">\(|B| &lt;&lt; |V|\)</span></li></ul><h4 id="参数的确定">参数的确定</h4><ul><li>computing intensity 𝑐 (or 𝐹𝑐)、memory intensity 𝑚 (or𝐹𝑚)：<img src="image-20240109200437799.png" alt="image-20240109200437799" style="zoom:67%;"></li><li>𝜆 ：<ul><li>做实验估计</li><li>平衡点：计算和存储资源充分利用</li><li>没太看懂，总之通过找平衡点找到了𝜆的取值</li></ul></li></ul><h3 id="实验">实验</h3><ul><li>数据集：<ul><li>现实的真实数据：SNAP、HPEC graph challenge、WebGraph</li><li>人造的数据集：Kronecher generator、SNAP</li><li>用upscaling的方法放大真实的图</li></ul></li><li>对比的GPU三角计数算法：<ul><li>Gunrock</li><li>TriCore</li><li>Fox的方法</li><li>Bisson的方法：匹配计算资源和负载</li><li>Hu的方法</li></ul></li></ul><ol type="1"><li>Edge directing</li></ol><ul><li>bassline：D-direction</li></ul><ol start="2" type="1"><li>Graph ordering</li></ol><ul><li>现有的方法对比：<ul><li>DFS</li><li>BFS-R</li><li>SlashBurn</li><li>GRO</li><li>他们的预处理时间都太长了</li></ul></li><li>bassline：原顺序，即不做预处理</li><li>degree-based反而是最慢的</li></ul><ol start="3" type="1"><li>两种方法结合</li></ol><!--很强，所有的表现都比其他方法优-->]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电子舞曲手册读书笔记（一）</title>
      <link href="/2024/01/09/%E7%94%B5%E5%AD%90%E8%88%9E%E6%9B%B2%E6%89%8B%E5%86%8C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/01/09/%E7%94%B5%E5%AD%90%E8%88%9E%E6%9B%B2%E6%89%8B%E5%86%8C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="电子舞曲手册">电子舞曲手册</h1><h2 id="压控振荡器vco">压控振荡器（VCO）</h2><h3 id="正弦波">正弦波</h3><ul><li>只有基频</li><li>没有谐波分量</li></ul><h3 id="方波">方波</h3><ul><li>模拟电路最容易生成的波形</li><li>这种波形只有奇次谐波，因此音色柔和而空洞</li><li>方波特别适合用来模仿木管乐器，为弦乐和 Pad音色增加宽度，或制作深邃宽广的贝司音色</li></ul><h3 id="脉冲波">脉冲波</h3><ul><li>脉冲波可以调整高低电平的宽度，从而改变声音的谐波成分</li><li>除了宽广柔和的方波音色之外，还能制作出类似簧管的轻薄音色。</li></ul><h3 id="锯齿波">锯齿波</h3><ul><li>锯齿波能够产生连续的奇次和偶次谐波，这种明亮的音色非常适合制作很“铜管”、很粗糙的音色</li><li>它还适合制作明亮且有质感的主奏以及脏贝司音色</li><li>由于其丰富的谐波，因此制作人往往把它添加到音色中并进行滤波</li></ul><h3 id="三角波">三角波</h3><ul><li>三角波形拥有两条线性斜率线，由于只包含奇次谐波（分波），所以没有锯齿波的谐波丰富</li><li>这种波形往往和正弦波、方波或脉冲波混合在一起，为音色增加明亮生动的感觉</li><li>三角波还常常用在Pad音色中增加质感</li></ul><h3 id="噪声波">噪声波</h3><ul><li>噪波与其他 5种波形都不同，因为它产生的是全频带的随机混合，没有实际音高</li><li>根据混合频率的能量分布，噪波可以分为“粉红噪声”和“白”噪声<ul><li>白噪声在全频带范围内具有相等的能量，类似于收音机中的杂讯</li><li>粉红噪声在每个倍频程内具有相同的能量，因此产生出更厚重的嘶声</li></ul></li></ul><h2 id="滤波器">滤波器</h2><ul><li>低通</li><li>高通：去低频，只剩谐波（trance的lead）</li><li>带通：薄</li><li>带阻：将声音变薄的同时完好无损地保留基频，这样制作出的音色既有明显的音高分别，又不含有很高能量的谐波成分</li><li>梳状：在很多模拟和DSP建模合成器中，如果把共鸣值调得足够高就会产生回授....(Feedback)。随着回授信号的增加，直到信号越来越多最终达到自激。这种自激能产生与截止频率相等的正弦波信号，而这个正弦波往往要比由振荡器产生的更纯净。由于这个原因，自激滤波器往往用来制作下潜深厚且力度十足的超低音，特别适合Drumn’Bass和说唱风格。</li><li>音高跟随</li></ul><h2 id="放大器">放大器</h2><img src="01/09/%E7%94%B5%E5%AD%90%E8%88%9E%E6%9B%B2%E6%89%8B%E5%86%8C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/image-20240108090540075.png" class title="image-20240108090540075"><h2 id="调节器">调节器</h2><h3 id="lfo">LFO</h3><ul><li>低频振荡器</li><li>1-10hz（人听不到）</li><li>比如，如果把 LFO频率设置得较高例如5Hz，并用来调制VCO的音高参数，那么振荡器的音高将根据LFO波形的速度和形状上下起伏，产生一种类似颠音的效果。如果 LFO的波形是正弦波，那么将会产生出类似警笛呼啸的效果。或者，如果同样的LFO用来调制滤波器的截止点，那么滤波器就将根据LFO的速度交替开关，而如果用来调制振荡器的音量，那么音量的上下起伏就将制造出震音的效果。</li></ul><h2 id="压缩器">压缩器</h2><ul><li>阈值（threshold）</li><li>压缩比（ratio）</li><li>attack / release</li><li>拐点（soft / hard knee）</li><li>峰值 / 平均值（peak / RMS）</li><li>侧链</li><li>无论压缩器拥有哪些控制参数，在录音时的设置都相对简单。在开始时将压缩比设置为4:1，然后慢慢降低闻值使信号最响部分的增益衰减保持在-8dB~10dB。把开启时间设置到最快并以释放时间设置为约500ms。在此基础上，进一步调整以找到适合具体音色的设置方法。</li><li>gain pumping</li><li>此外，由于高于闽值的声音电平都将被衰减，因此低于闯值的信号将被提升。尽管这能够增加信号的整体电平，但压缩却无法分辨有用的乐音和无用的噪声。15dB的增益衰减不但会将峰值衰减15dB，也会将小信号。使用提升增益将峰值重新提升到标准电平(比如15dB)，则所有低于值的信号司样提升15dB。如果录音中本来就含有噪声，那么可能会更加明显。（这个好像是我之前遇到的问题）</li></ul><h2 id="混响">混响</h2><ul><li>干湿比（ratio / mix）</li><li>扩散</li><li>密度</li></ul><h2 id="移相phaser和镶边flanger">移相（phaser）和镶边（flanger）</h2><p>移相和镶边都使用了低频振荡器来调制移相和延时。原始信号与延时信号之间的相位差会产生一连串的相位抵消。得到的效果是移相效果器会在声音上产生一连串谐波相关(也就是与原始信号相位相关)的声陷;而由于使用了延时电路，镶边会产生持续变化的频率，因此镶边和移相具有相同的参数。它们都用速率参数来控制LFO的速度，用反馈(Feedback)参数来控制LFO的效果深度。注意，有些移相器只能使用正弦波做调制源，而大部分镜边器不仅能改变LFO的波形，还可以控制处理原始信号的征时数量。</p><h2 id="eq">EQ</h2><ul><li>均衡</li><li>从根本上讲，EQ是一种基于频率的音量音调控制，可以提升和衰减不同的频率。为了达到这个目的就需要3种参数<ul><li>频率参数用来选择需要调整的频率</li><li>“Q”值参数决定中央频率两侧有多少频率需要调整</li><li>增益参数控制所选频率需要提升或衰减的量</li></ul></li></ul><h2 id="音色">音色</h2><h3 id="pad">pad</h3><p>要制作适合扫频的谐波丰满的声音，锯齿波、三角波、噪声波和方波能够得到最好的结果，但有些情况下也可以用正弦波来增加一些底部的基垫。对于Pad而言，可以使用两个锯齿波、三角波或脉冲波振荡器相互失谐3音分或5音分。这就在振荡器之间产生了轻微移相的效果，使音色更宽更悦耳。进一步强调这种失谐，可以用锯齿波、三角波、正弦波或噪声波低频振荡器调制其中一个振荡器，产生更模拟的感觉，同时也能防止基本音色过于死板。</p>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电子舞曲制作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity3D工具链安装笔记</title>
      <link href="/2023/12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/"/>
      <url>/2023/12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="一些调研">一些调研</h1><h3 id="unity3d">Unity3D</h3><p>好上手、生态好、C#、移动端</p><h3 id="ue5">UE5</h3><p>学习曲线陡、渲染更好、C++、主机端高画质</p><img src="12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/image-20231226092222296.png" class title="image-20231226092222296"><p>占50G，而且优势是渲染好，我自己电脑本身就没什么性能，所以暂时不考虑了</p><h3 id="godot">Godot</h3><p>基于节点的用户界面 -&gt;新手更友好、C++、2D小成本，以创意迭代和快速做完为优先，godot有优势、资料少、免费开源</p><h3 id="cocos">Cocos</h3><p>国产、2d比较简单、做小游戏很方便，但看网上的描述好像比较简陋</p><p>所以我看了一圈，觉得还是得U3D。UE我电脑应该带不动，Godot教程太少，我这种制造bug体制可能会浪费很多时间在解决奇怪的问题上，而且还得花时间造轮子，对于我这种还没有想法只是想学学游戏引擎的人来说还是U3D好一点。如果未来有制作2d游戏的想法，那可以用Godot。主要担心还是U3D的精神状态，希望用起来没事（我看网上都说U3D封禁账号非常快，如果以后进团队用公司的U3D团队账号开发，它会把个人的情况都查一遍，用了破解版的就封禁且不解封…所以我还是谨慎一点，用免费的个人版吧）。</p><h1 id="unity相关工具链安装">Unity相关工具链安装</h1><h2 id="unity-hub">Unity Hub</h2><p>网址：https://unity.cn/releases</p><p>下载Hub管理员身份运行后按步骤安装即可。</p><img src="12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/image-20231226085830965.png" class title="image-20231226085830965"><p>暂时先把editor跳过了。就进入了激活许可证的环节：</p><img src="12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/image-20231226090154371.png" class title="image-20231226090154371"><p>这样就进入了hub的主界面，可以在设置里看到license已经设置好了：</p><img src="12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/image-20231226090303819.png" class title="image-20231226090303819"><p>他这个license只能持续几天…得登录刷新…所以我真的用着很担心…</p><p>记得修改安装位置！（projects、installs和下面的Plastic SCM Disk）</p><img src="12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/image-20231226094435541.png" class title="image-20231226094435541"><h2 id="安装unity">安装Unity</h2><p><strong>先重启！</strong></p><p><strong>先重启！</strong></p><p><strong>先重启！</strong></p><p>现在来安装editor。看准LTS，手抖了一下但是2022应该可以吧…有问题再退回2021。鉴于VS占空间太大，故考虑在Rider上开发（我喜欢jetbrains！这个配置后面写），VSCODE也可以，用这个：https://code.visualstudio.com/docs/other/unity，故选择DEV TOOLS就跳过了，按个人需求吧。</p><img src="12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/image-20231226094622503.png" class title="image-20231226094622503"><p>我反正把安卓平台、中文、文档都选了。</p><p>漫长的等待——</p><img src="12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/image-20231226102122372.png" class title="image-20231226102122372"><p>没关系，再来一次。然后又fail了。但我在点了retry之后才意识到之前的文章提醒我要重启，等会儿试试。重启了之后发现安装任务没了，得重新下载再安装…虽然东西都在，但它不能覆盖…，所以安装前一定要<strong>先重启先重启先重启</strong>！重启完就顺利安装了。</p><h2 id="运行unity3d">运行Unity3D</h2><p>请跳过下面这一段</p><hr><p>在hub里新建项目即可，会帮你下载PlasticSCM（版本管理工具）</p><img src="12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/image-20231226124416809.png" class title="image-20231226124416809"><p>但他好像会给你直接下到C盘…所以我最后还是选了manualinstallation，下载成功后打开，登录U3D的账号，并创建一个新的repository。在之前注册U3D账号的时候就已经整了一个“组织”，现在直接用就行，要不然就去U3D官网上建一个自己的组织。</p><img src="12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/image-20231226125939781.png" class title="image-20231226125939781"><p>这时再打开hub，就可以找到刚刚建立的云端的仓库了。</p><img src="12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/image-20231226130017723.png" class title="image-20231226130017723"><p>然后创建项目：</p><img src="12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/image-20231226130108851.png" class title="image-20231226130108851"><p>但我依旧遇到了让我再次下载Plastic SCM的问题：</p><img src="12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/image-20231226130403444.png" class title="image-20231226130403444"><p>由于一直尝试不成功，我突然意识到明明惯于用git为什么要下这个版本管理工具…遂卸载。</p><hr><p>在创建项目处取消对enable version control的打钩，直接创建项目。</p><img src="12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/image-20231226131115332.png" class title="image-20231226131115332"><h2 id="rider配置">Rider配置</h2><p>下载：https://www.jetbrains.com/zh-cn/rider/download/#section=windows</p><p>安装（别忘记改目录）：</p><img src="12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/image-20231226100851836.png" class title="image-20231226100851836"><p>（然后进行一个破解的操作）</p><p>安装好Rider并创建了U3D项目后，在Edit - Preferences - ExternalTools中修改Editor为Rider：</p><img src="12/26/Unity%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/image-20231226131411936.png" class title="image-20231226131411936"><h2 id="配置git">配置Git</h2><p>这两步默认其实是对的（所以可以忽略）：</p><ol type="1"><li>Services - General Settings - Version Control</li></ol><p>Mode设为Visual Meta Files。</p><ol start="2" type="1"><li>Services - Project Settings - Editor</li></ol><p>Asset Serialization Mode 选项 选择“Force Text”</p><p>然后就可以创建git仓库啦！</p><p>这里可以新建一个.gitignore文件，把不需要管理的文件加进去（比如我抄了一份）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Library/</span><br><span class="line">Temp/</span><br><span class="line">*.sln</span><br><span class="line">*.csproj</span><br><span class="line">*.sln</span><br><span class="line">*.userprefs</span><br><span class="line">*.unityproj</span><br><span class="line">*.DS_Store</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>复杂性类</title>
      <link href="/2023/05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/"/>
      <url>/2023/05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="复杂性类">复杂性类</h1><!--真是让人无法下手…--><p>是一堆语言的集合！不是一堆算法！</p><h2 id="图灵机">图灵机</h2><h3 id="形式语言">形式语言</h3><p>你的形式语言学到哪里去了！！</p><p>字母表 + 开始状态 + 终止状态 +转移函数，是一些符合规则的字符串集合，只研究语法，不关心语义。</p><p>也就是说，图灵机就是用来识别语言的工具。那语言又是干什么用的？</p><h3 id="tm">TM</h3><p>用自己的话来描述，图灵机就是根据一定的规则，依据读入来控制读写头移动与操作的机器。要素有字母表、状态集合、转移函数。其中，一定的读入可以让图灵机停机并产生输出，输出为1则这样的输入属于该图灵机决定的“语言”。</p><p>图灵机运行的时候，时刻对它拍照就能得到<strong>格局</strong>：纸带样子+ 状态集合 + 读写头位置</p><h3 id="dtm-ndtm">DTM &amp; NDTM</h3><p>参考dfa和nfa，大概就是转移函数变了，可以有同一个字符对应多个转移状态。</p><p>看下去，有张图很形象，这里不太清晰！</p><h3 id="ptm">PTM</h3><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530111248285.png" class title="image-20230530111248285"><p>在NDTM上随机地选转移函数。</p><h3 id="通用图灵机">通用图灵机</h3><p>一开始把这里跳过了，后来发现这个东西很重要…</p><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530105029266.png" class title="image-20230530105029266"><p><del>俗称，编译器。</del></p><p><del>或者更贴切的而说，套娃。</del></p><p>长这样：</p><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530105147941.png" class title="image-20230530105147941"><p>Mα denotes the TM represented by α，这句话我暂时没有理解。但是看到PPT上的红字encoding，感觉有机可图。</p><p>考虑对符号和状态用01串进行编码（怎么编不管了，反正就是不会有冲突），并参考了这里：https://zhuanlan.zhihu.com/p/260512272.就可以把TM变成一串码。所以通用图灵机需要的其实是一个图灵机的输入和他的编码！</p><h3 id="停机">停机</h3><p>输入为不属于这个语言的字符串时：</p><p><strong>识别</strong>：要么停机且处于拒绝状态，要么永远不停机；</p><p><strong>判定</strong>：能停机且拒绝，不能不停机。</p><h2 id="语言">语言</h2><p>一些补充，因为我真的真的非常困惑：</p><p>NP问题是多项式时间内可以判定一个解对不对，但同时他也是运行在多项式时间的NDTM上的判定语言的复杂度类，这两个概念我无法对应上，也就是说，我卡在语言到底是个什么上了。</p><p>翻阅形式语言的教材，我发现：</p><blockquote><p>因此 , 一个问题 , 如果它的语言是递归的 , 则 称 此 问 题 是 可 判 定的 ( decidable ) ; 否 则 , 称 此 问 题 是 不 可 判 定的(undecidable)。</p></blockquote><p>这又是什么？</p><p>形式语言的教材给了我另一个收获，也就是前面我的疑惑其实是概念上的混淆：</p><ul><li><blockquote><p>NP 表示不确定的图灵机在多项式时间 (步数 )内可判定的语言类。</p></blockquote></li><li><blockquote><p>这些语言对应的问题称为 NP类问题(class of NP )，这种语言称为非确定性多项式可判定的</p></blockquote></li></ul><p>很好，那什么叫语言对应的问题？</p><p>判定一个句子是否属于一个语言 =判定一组解是否能满足SAT，或者说（定义）是在非确定的图灵机上多项式步骤内判定一个句子是否属于一个语言=（实际应用）给定图G和回路L，判断是否存在比L的长度更短的回路，这很抽象…我再思考一下能不能用数学语言描述，不行的话就意会吧。</p><h2 id="时间复杂度">时间复杂度</h2><h3 id="dtime">DTIME</h3><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230529165913125.png" class title="image-20230529165913125"><p>其中D代表deterministic.</p><h3 id="ntime">NTIME</h3><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230529222052399.png" class title="image-20230529222052399"><p>其中N代表none-deterministic.</p><h3 id="bptime">BPTIME</h3><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530111225099.png" class title="image-20230530111225099"><p>得和PTM对应着看。</p><h3 id="rtime">RTIME</h3><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530113353363.png" class title="image-20230530113353363"><p>这块儿，我觉得书里写错了…下面一行应该是 <span class="math inline">\(Pr[M(x)=0]=1\)</span>.</p><h3 id="ztime">ZTIME</h3><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530114359431.png" class title="image-20230530114359431"><p>有点抽象，但是他和前面几个时间复杂度类的区别在于，它不限制算法必须在多项式时间内跑完——他是一个期望为多项式时间的NTIME类（我自己的理解），因为它一定返回正确的结果。</p><h2 id="空间复杂度">空间复杂度</h2><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230529214806139.png" class title="image-20230529214806139"><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230529214817732.png" class title="image-20230529214817732"><p>所以，<img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230529215102175.png" class title="image-20230529215102175"></p><p>因为格局数目至多为 <span class="math inline">\(2^{O(S(n))}\)</span>。</p><h2 id="dtm">DTM</h2><h3 id="p">P</h3><p><img src="image-20230529165930561.png" alt="image-20230529165930561" style="zoom:67%;"></p><p>在多项式时间内确定一个可以解决问题的图灵机。</p><p>例子：上下文无关文法。</p><h2 id="ndtm">NDTM</h2><h3 id="np">NP</h3><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230529170312435.png" class title="image-20230529170312435"><p>在多项式时间内验证一个解是否正确。但如果从“复杂性类”是一群语言的集合角度出发，怎么理解呢？这里主要的理解问题在于整个定义里面充斥着exists…</p><p>我重新思考了一下，发现对于NP，其实定义没说它是运行在多项式时间的NDTM上的判定问题（除非从NTIME出发），如果给出在DTM在每一步上选什么（certificate）那确实可以再多项式时间内判定这个语言，但这样NDTM也就衰退成为DTM了（怎么衰退的），所以同样在DTM上运行的判定算法，如果能在多项式时间内自己找到答案那就是P类语言，需要按一个多项式长度的01串走并停机的就是NP类语言。</p><p>这里的<span class="math inline">\(p(|x|)\)</span>我理解为：与<span class="math inline">\(x\)</span>长度有关的多项式。</p><p>这里的证书也可以写成<code>witness</code>.</p><p>例子：最大独立集（INDSET）、TSP、线性规划、连通性</p><p>那我再细化一下自己的问题，就是NDTM上的判定问题和给出一个序列在DTM上运行的判定问题怎么等价了（上文问怎么衰退处）？通过看书我解决了这个问题：</p><blockquote><p>NDTM has two transition functions δ0 and δ1, and a special statedenoted by q_accept.</p></blockquote><p>也就是说，DTM是自动的，它根据q_start，读入，移动，换状态，读入，移动，换状态，直到停机；NDTM多一个选择转移函数的过程。</p><p>放个图：</p><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530094750649.png" class title="image-20230530094750649"><p>所以P是在DTM上多项式步骤内可以停机的语言类，NP是在NDTM上多项式步骤内可以停机的语言类= 给出一个01序列，在DTM上可以停机的语言类 =给出一个解，可以判定这个解对不对（根据停机时的答案）的语言类。</p><h3 id="co-np">co-NP</h3><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530115703994.png" class title="image-20230530115703994"><p>区别就是存在变成任意了。我想了很久为什么NP的对偶问题不是”<span class="math inline">\(x \notin L\)</span> iff任意一个串u和一个多项式时间内运行的确定的图灵机，使得按串走，都能得到M(x,u)=0“，然后发现其实是一个意思，但没有人喜欢拧着说<span class="math inline">\(x \notin L\)</span>，其实就是多项式时间内证伪的意思。但说实话，感觉co-NP很强。</p><p><span class="math inline">\(p \subseteq NP \cap co-NP\)</span>.</p><h3 id="归约">归约</h3><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530104011396.png" class title="image-20230530104011396"><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530104023559.png" class title="image-20230530104023559"><h2 id="ptm-1">PTM</h2><h3 id="bpp">BPP</h3><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530111608218.png" class title="image-20230530111608218"><p>他这里比较迷惑的地方在于，这个2/3不但只需要是一个大于1/2的数就行，而且这个概率是针对随机抛币抛出来的一个多项式长度的r，按r走，判断x属于L正确的概率至少为2/3。好抽象，这是怎么构造的…</p><p>会有双边错误，即判断<span class="math inline">\(x\inL\)</span>时输出0的概率和判断<span class="math inline">\(x\notinL\)</span>时输出1的概率都大于2/3.</p><h3 id="rp">RP</h3><p><img src="image-20230530113404384.png" alt="image-20230530113404384" style="zoom:67%;"></p><p>单边错误，因为判断<span class="math inline">\(x\notinL\)</span>时一定输出0，但判断<span class="math inline">\(x\inL\)</span>时输出1的概率大于2/3.</p><p>我感觉可以这样理解，就是把PTM的各个转移函数化成一棵树，有两种分支，一种走到头（图灵机停机）返回1（可接受），另一种返回0（不可接受）。对于RP，这个PTM的分支返回结果都是真的，判断<span class="math inline">\(x\notinL\)</span>时就一定不会走到可接受的分支上去，但判断<span class="math inline">\(x\inL\)</span>时有大于2/3的概率走到可接受的分支上。</p><h3 id="co-rp">co-RP</h3><p>反过来定义另一边的单边错误，即判断<span class="math inline">\(x\inL\)</span>时一定输出1，但判断<span class="math inline">\(x\notinL\)</span>时输出0的概率大于2/3.</p><p><code>Monte Carlo</code>属于是BPP类，包括两种单边错误RP类和co-RP类.</p><h3 id="zpp">ZPP</h3><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530114412772.png" class title="image-20230530114412772"><p>无错误，但是运行时间只是期望为多项式时间，可能一直不停机。</p><p>但他真的很神奇，因为ZPP = RP ∩ co-RP ：首先 <span class="math inline">\(ZPP \subseteq RP\)</span> 并且 <span class="math inline">\(ZPP \subseteq co-RP\)</span>是很显然的（<strong>大错特错！</strong>期望时间和保证在多项式时间内停机完全不同！），所以<span class="math inline">\(ZPP \subseteq RP \cap co-RP\)</span>；反过来的话：</p><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530131821912.png" class title="image-20230530131821912"><p>但我还有个疑问，就是<code>Monte Carlo</code>保证<span class="math inline">\(x\notin L\)</span>不错，那为什么在<span class="math inline">\(M_L\)</span>输出yes的时候接受这个yes？哦！因为前面自己也说了，<code>Monte Carlo</code>保证了分支的结果一定是对的，只不过上哪个分支比较随机，所以如果以大于2/3的概率被接受了那一定是对的（两个概念）。</p><p>弥补前面的错误（还没证完）：</p><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530131937241.png" class title="image-20230530131937241"><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530131943467.png" class title="image-20230530131943467"><p>这里区别于<span class="math inline">\(P \subseteq NP \capco-NP\)</span>，因为这里不能换成等于号（目前还悬而未决）。</p><p><code>Las Vegas</code>算法属于ZPP类。</p><h2 id="总结">总结</h2><p>至此，我们解决了我能看懂的部分——</p><img src="05/30/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%B1%BB/image-20230530133103896.png" class title="image-20230530133103896"><p>再接再厉！</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>random_alg_0</title>
      <link href="/2023/05/28/rand_Alg_Note_1/"/>
      <url>/2023/05/28/rand_Alg_Note_1/</url>
      
        <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><h2 id="randqs">RandQS</h2><p>在快速排序算法中，考虑随机的取用来划分分治问题的pivot。</p><h3 id="算法思路">算法思路</h3><ul><li>在<span class="math inline">\(S\)</span>中随机取<span class="math inline">\(y\)</span></li><li>比较<span class="math inline">\(S\)</span>中每个元素和<span class="math inline">\(y\)</span>的大小，比y小扔到<span class="math inline">\(S_1\)</span>中，否则扔到<span class="math inline">\(S_2\)</span>中</li><li>分治<span class="math inline">\(S_1\)</span>和<span class="math inline">\(S_2\)</span>，返回<span class="math inline">\(S_1y S_2\)</span></li></ul><h3 id="时间">时间</h3><p>比较次数：</p><p>设 <span class="math inline">\(i,j\)</span> 为下标，<span class="math inline">\(X_{ij}\)</span>表示 <span class="math inline">\(S_i\)</span> 和 <span class="math inline">\(S_j\)</span> 发生了比较，<span class="math inline">\(p_{ij}\)</span>为概率。所以期望 <span class="math inline">\(E_{ij} = p_{ij}\times 1 + (1-p_{ij})\times 0 =p_{ij}\)</span> ，</p><p>那么，总体的比较次数期望 <span class="math inline">\(E[\Sigma_{i =1}^n \Sigma_{j&gt;i} X_{ij}] = \Sigma_{i = 1}^n \Sigma_{j&gt;i}E[X_{ij}]\)</span>。</p><p>现在考虑把取数的过程化成一棵二叉树，根即为 <span class="math inline">\(y\)</span>，那么不同子树中的两个数一定没有比较</p><p>-&gt; 对于一个节点，只有其祖先节点会和它发生比较</p><p>-&gt; 在此之前这两个节点被划分到了同一棵子树中</p><p>-&gt; 考虑一个这棵二叉树的中序遍历 <span class="math inline">\(\pi\)</span>，如果对<span class="math inline">\(S\)</span>排序后 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 之间的一个下标 <span class="math inline">\(k \in (i, j)\)</span> 对应的 <span class="math inline">\(S_k\)</span> 比 <span class="math inline">\(S_i\)</span> 或 <span class="math inline">\(S_j\)</span> 出现位置靠前，则 <span class="math inline">\(S_i\)</span> 和 <span class="math inline">\(S_j\)</span> 会被分在以 <span class="math inline">\(S_k\)</span> 为公共祖先的两棵子树中，即 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 之间不会发生比较</p><p>-&gt; 所以对于序列 <span class="math inline">\(S_i, S_{i+1}, S_{i+2},\dots , S_{j}\)</span> ，在 <span class="math inline">\(\pi\)</span>中只能是 <span class="math inline">\(S_i\)</span> 或 <span class="math inline">\(S_j\)</span> 出现位置最早，这样的概率为 <span class="math inline">\(\frac{2}{j-i+1} = p_{ij}\)</span></p><p>带入总体比较次数：<span class="math inline">\(\Sigma_{i=1}^n\Sigma_{j&gt;i} p_{ij} = \Sigma_{i = 1}^n \Sigma_{j&gt;i}\frac{2}{j-i+1} =(k=j-i)= \Sigma_{i=1}^n \Sigma_{k=1}^{n-i}\frac{2}{k+1} &lt; 2\Sigma_{i=1}^n \Sigma_{k=1}^{n} \frac{1}{k} =2nH_n\)</span></p><p>又有<span class="math inline">\(H_n\)</span>~ <span class="math inline">\(ln(n) +\Theta(1)\)</span>，所以<code>RandQS</code>时间复杂度为<span class="math inline">\(O(nlog(n))\)</span>.</p><h3 id="辨析">辨析</h3><p>随机化算法运行时间与输入无关，只于<em>随机</em>的选择有关。</p><h2 id="min-cut">Min-Cut</h2><h3 id="前置补充">前置补充</h3><img src="05/28/rand_Alg_Note_1/image-20230527160321549.png" class title="image-20230527160321549"><h3 id="问题定义">问题定义</h3><blockquote><p>考虑一个可以有重边的图 <span class="math inline">\(G\)</span>，找最小割。</p></blockquote><h3 id="算法思路-1">算法思路</h3><ul><li>contraction：每次随机选取两个点，移除它们之间的边，合并</li><li>重复合并操作，直到只剩下两个点，此时两点间的边数即为<code>Min-Cut</code>的候选值</li></ul><p>解释一下，在每步合并操作后，一定不会得到更小的<code>Min-Cut</code>，因为当前的图中的cut一定能在原图中找到对应的cut。</p><h3 id="正确性">正确性</h3><p>设<code>Min-Cut</code>大小为<span class="math inline">\(k\)</span>，则有<span class="math inline">\(n\)</span>个点的图中一定有至少<span class="math inline">\(kn/2\)</span>条边，否则一定存在一个点，度数小于<span class="math inline">\(k\)</span>，使得最小割小于<span class="math inline">\(k\)</span>。</p><p>设事件<span class="math inline">\(\epsilon_i\)</span>代表第<span class="math inline">\(i\)</span>步合并时没有选<span class="math inline">\(C\)</span>边，那么<span class="math inline">\(Pr[\epsilon_1] &gt;= 1-\frac{k}{\frac{kn}{2}} =1-\frac{2}{n}\)</span>，此时还剩<span class="math inline">\(k(n-1)/2\)</span>条边，那么<span class="math inline">\(Pr[\epsilon_2 | \epsilon_1] &gt;=1-\frac{k}{\frac{k(n-1)}{2}} = 1-\frac{2}{n-1}\)</span>.</p><p>推广到还剩两个节点时，<img src="05/28/rand_Alg_Note_1/image-20230527162422388.png" class title="image-20230527162422388"></p><p>所以找到正确的最小割的概率略大于<span class="math inline">\(\frac{2}{n^2}\)</span>.</p><p>可知，<span class="math inline">\((1-\frac{2}{n^2})^{\frac{n^2}{2}}&lt;\frac{1}{e}\)</span>，所以运行此算法<span class="math inline">\(\frac{n^2}{2}\)</span>次后出错的概率很低。</p><h2 id="las-vegas-monte-carlo">Las Vegas &amp; Monte Carlo</h2><h3 id="定义">定义</h3><p><strong>LasVegas</strong>：正确，但运行时间变化</p><p><strong>Monte Carlo</strong>：不一定正确，但可以用时间换正确性</p><h3 id="todo">TODO</h3><h2 id="binary-planar-partitions">Binary Planar Partitions</h2><h3 id="定义-1">定义</h3><p>嗯，没查到好的翻译，只能查到<code>Binary SpacePartitions</code>(BSP，二叉空间划分)，于是不妨把<code>BPP</code>视作“二叉平面划分”。</p><figure><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/81/Binary_space_partition.png/300px-Binary_space_partition.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>In <a href="https://en.wikipedia.org/wiki/Computer_science">computerscience</a>, <strong>binary space partitioning</strong>(<strong>BSP</strong>) is a method for <a href="https://en.wikipedia.org/wiki/Space_partitioning">spacepartitioning</a> which <a href="https://en.wikipedia.org/wiki/Recursively">recursively</a>subdivides a <a href="https://en.wikipedia.org/wiki/Euclidean_space">Euclidean space</a>into two <a href="https://en.wikipedia.org/wiki/Convex_set">convexsets</a> by using <a href="https://en.wikipedia.org/wiki/Hyperplane">hyperplanes</a> aspartitions. This process of subdividing gives rise to a representationof objects within the space in the form of a <a href="https://en.wikipedia.org/wiki/Tree_(data_structure)">tree datastructure</a> known as a <strong>BSP tree</strong>.</p></blockquote><h3 id="问题定义-1">问题定义</h3><blockquote><p>40个房间，40个醉汉随机挑一个进去睡觉，问有多少个人恰好进入了自己的房间。</p></blockquote><p>设事件 <span class="math inline">\(X_i\)</span> 为第 <span class="math inline">\(i\)</span>个醉汉是否进入了对应房间，所以最终的答案为 <span class="math inline">\(E[\Sigma_{i=1}^{40}X_i] =\Sigma_{i=1}^{40}E[X_i]=\Sigma_{i=1}^{40}\frac{1}{40}=1\)</span>.神奇！</p><blockquote><p>（与图形学有关）给出一些不相交线段集合<span class="math inline">\(S\)</span>，找到一个“二叉平面划分”，s.t.每个区域内最多有一个线段（或一个线段的一部分）。</p><img src="05/28/rand_Alg_Note_1/image-20230527221212070.png" class title="image-20230527221212070"></blockquote><p><strong>Painter's Algorithm</strong>：由远及近的画画。</p><h3 id="randauto">RandAuto</h3><h4 id="算法思路-2">算法思路</h4><ul><li>把<span class="math inline">\(S\)</span>中的线段延长为直线，记为<span class="math inline">\(l(s_i)\)</span></li><li>随机取一个<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>的全排列，记为<span class="math inline">\(\pi\)</span></li><li>如果当前的区域有多条线段，那么就用 <span class="math inline">\(\pi\)</span> 中最靠前能划分区域的直线进行划分</li></ul><p>会有一个后果，就是可能存在一个线段在两个区域的交界上，这种时候就随便分给一个区域。</p><h4 id="时间复杂度">时间复杂度</h4><p>设 <span class="math inline">\(index(u,v)\)</span>代表在原图中 <span class="math inline">\(l(u)\)</span> 在碰到 <span class="math inline">\(v\)</span> 时一共穿过的线段 <span class="math inline">\(\{u_1, u_2, \dots, u_{i-1}, v\}\)</span>数量（这里 <span class="math inline">\(index(u, v)=i\)</span>）。不相交则赋值为<span class="math inline">\(\infty\)</span>。这里我猜穿越顺序是按照原线段向两侧延伸时候伸长的顺序。</p><p>记事件 <span class="math inline">\(u \dashv v\)</span>代表在算法得到的划分结果中 <span class="math inline">\(v\)</span> 被<span class="math inline">\(l(u)\)</span> 切割了。同理，这就要求 <span class="math inline">\(u\)</span> 比 <span class="math inline">\(\{u_1,u_2, \dots, u_{i-1}, v\}\)</span> 在 <span class="math inline">\(\pi\)</span> 中出现的更早，这样的概率为 <span class="math inline">\(\frac{1}{index(u,v)+1}\)</span></p><p>记指标变量 <span class="math inline">\(C_{u,v}\)</span> 代表事件<span class="math inline">\(u \dashv v\)</span> 是(<span class="math inline">\(=1\)</span>)否(<span class="math inline">\(=0\)</span>)发生，所以<span class="math inline">\(E[C_{u,v}]=PR[u \dashvv]\leq\frac{1}{index(u,v)+1}\)</span>.</p><p>==这里没有理解为什么要加n……==</p><p>总之，最终选取的划分的大小应该<span class="math inline">\(=n+\)</span>交点数量<span class="math inline">\(=n+E[\Sigma_{u}\Sigma_{v}C_{u,v}]\)</span><span class="math inline">\(=n+\Sigma_{u}\Sigma_{v\neq u}PR[u \dashv v]\leqn+\Sigma_{u}\Sigma_{v\neq u}\frac{1}{index(u,v)+1}\)</span></p><p>又因为（很简单的道理，我怎么看了这么久！）对于<span class="math inline">\(\forall i \in [1, n]\)</span>和固定的 <span class="math inline">\(u\)</span>，最多只会存在一对<span class="math inline">\(v, w\)</span>（直线的两个延伸方向上的）使得<span class="math inline">\(index(u,v)=index(u,w)=i\)</span>（想象一下，直线只有两个方向+穿过的直线数量单调递增），所以上面的式子可以接着$n + <em>{u}</em>{i=1}^{n-1} n + 2nH_n$.</p><p>又有<span class="math inline">\(H_n\)</span>~ <span class="math inline">\(ln(n) +\Theta(1)\)</span>，所以<code>RandAuto</code>时间复杂度为<span class="math inline">\(O(nlog(n))\)</span>.</p><h4 id="正确性-1">正确性</h4><h2 id="a-probabilistic-recurrence">A Probabilistic Recurrence</h2><p>没想好怎么翻译，加上文章让我这个初读者omit，那我就欢快的跳过了！</p><h2 id="计算模型和复杂性类">计算模型和复杂性类</h2><p>痛苦！之前看<em><u>Computational Complexity_A ModernApproach</u></em>也没坚持完第一章，看看考研完以后能不能以这样记笔记的形式逼着自己读懂。所以这个部分在这本书的笔记里也找个借口略写一下。</p><h3 id="图灵机与rams">图灵机与RAMs</h3><blockquote><img src="05/28/rand_Alg_Note_1/image-20230528103203268.png" class title="image-20230528103203268"></blockquote><p><strong>unit-cost RAM</strong>：允许直接使用乘法</p><p><strong>log-cost RAM</strong>：运行时间与 <span class="math inline">\(log(操作数)\)</span> 成比例</p><p>==没有明白TM和RAM模型的区别==，感觉是一个东西，但RAM的描述更实用一点（？</p><h3 id="复杂性类">复杂性类</h3><p>这个我单独整理一下，这本书部不主要讨论这个，感觉没有PPT里详细。（摆）</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_LAB0</title>
      <link href="/2022/03/28/BUAA-OS-LAB0/"/>
      <url>/2022/03/28/BUAA-OS-LAB0/</url>
      
        <content type="html"><![CDATA[<h2 id="一实验思考题">（一）实验思考题</h2><h4 id="thinking-0.1">Thinking 0.1</h4><blockquote><p>使用 cat Modified.txt ，观察它和第一次 add 之前的 status一样吗，思考一 下为什么？</p></blockquote><p>Untracted意为未跟踪，通过gitadd变为可跟踪未修改的文件，也就是stage里面所见的newfile，此时如果修改这个文件，就会变成已修改的文件，如Modified中显示的样子。</p><p>在最开始和最末取得的gitstatus之间，git跟踪了该文件，同时该文件也被修改了，所以两次的status一定不同。</p><h4 id="thinking-0.2">Thinking 0.2</h4><blockquote><p>仔细看看这张图，思考一下箭头中的 add the file、stage the file 和commit 分别对应的是 Git 里的哪些命令呢？</p></blockquote><p>add the file：git add stage the file：git add（修改之后重新add）commit：git commit</p><h4 id="thinking-0.3">Thinking 0.3</h4><blockquote><p>深夜，小明在做操作系统实验。困意一阵阵袭来，小明睡倒在了键盘上。等到小明早上醒来的时候，他惊恐地发现，他把一个重要的代码文件printf.c删除掉了。苦恼的小明向你求助，你该怎样帮他把代码文件恢复呢？</p></blockquote><p>这里工作区的printf.c文件被删除了。使用：<code>git checkout --printf.c</code>从仓库恢复，然后gitadd。</p><blockquote><p>正在小明苦恼的时候，小红主动请缨帮小明解决问题。小红很爽快地在键盘上敲下了gitrmprintf.c，这下事情更复杂了，现在你又该如何处理才能弥补小红的过错呢？</p></blockquote><p>这里在暂存区的printf.c文件被删除了。使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD --printf.c</span><br><span class="line">git checkout --printf.c</span><br></pre></td></tr></table></figure><blockquote><p>处理完代码文件，你正打算去找小明说他的文件已经恢复了，但突然发现小明的仓库里有一个叫Tucao.txt，你好奇地打开一看，发现是吐槽操作系统实验的，且该文件已经被添加到暂存区了，面对这样的情况，你该如何设置才能使Tucao.txt在不从工作区删除的情况下不会被gitcommit指令提交到版本库？</p></blockquote><p>已进入暂存区，但还没有push上去，所以选择使用：<code>git rm --cached printf.c</code></p><h4 id="thinking-0.4">Thinking 0.4</h4><p>首先，先按教程完成三次提交。</p><img src="03/28/BUAA-OS-LAB0/image-20220309201900053.png" class title="image-20220309201900053"><img src="03/28/BUAA-OS-LAB0/image-20220309202044749.png" class title="image-20220309202044749"><img src="03/28/BUAA-OS-LAB0/image-20220309202146198.png" class title="image-20220309202146198"><img src="03/28/BUAA-OS-LAB0/image-20220309202254700.png" class title="image-20220309202254700"><img src="03/28/BUAA-OS-LAB0/image-20220309202254700-16473025327461.png" class title="image-20220309202254700-16473025327461"><p>由此，可以看出来head是一个“指针”，指向当前的版本。同时每个版本都有一个hash值，用来标记不同版本并回退/回到未来。使用gitreset --hard HEAD^即退回到上个版本，在这里即comment为“2”的提交，使用gitreset --hard &lt;Hash-code&gt;即去往HashCode标记的版本。</p><h4 id="thinking-0.5">Thinking 0.5</h4><blockquote><ol type="1"><li>克隆时所有分支均被克隆，但只有HEAD指向的分支被检出。</li></ol></blockquote><p>git官方文档说道，clone的功能是：</p><p>“Clones a repository into a newly created directory, createsremote-tracking branches for <strong>each branch</strong> in the clonedrepository (visible using git branch --remotes), and creates and<strong>checks out an initial branch</strong> that is forked from thecloned repository’s currently active branch.“</p><p>​</p><blockquote><ol start="2" type="1"><li>克隆出的工作区中执行 git log、git status、git checkout、gitcommit等操作不会去访问远程版本库。</li></ol></blockquote><p>证据来自git官方文档：</p><ul><li>git-status - Show the <strong>working tree</strong>status，对工作区进行查看，无需访问remote。</li><li>git-checkout - Switch branches or restore <strong>workingtree</strong> files，对工作区进行查看，无需访问remote。</li><li>git-commit - Record changes to the<strong>repository</strong>，对本地仓库进行更新操作，无需访问remote。</li><li>git-log - Show commit logs，或者详细一点，List commits that arereachable by following the parent links from the given commit(s), butexclude commits that are reachable from the one(s) given with a ^ infront of them.所以是用来记录之前的commits的，同样不需要访问远程版本库。</li></ul><blockquote><ol start="3" type="1"><li>克隆时只有远程版本库HEAD指向的分支被克隆。</li></ol></blockquote><p>并不，和第1问矛盾。</p><blockquote><ol start="4" type="1"><li>克隆后工作区的默认分支处于master分支。</li></ol></blockquote><p>是的，默认分支就是master分支。因为大多数开发团队均已master为核心，围绕master进行开发。</p><h4 id="thinking-0.6">Thinking 0.6</h4><blockquote><p>执行如下命令,并查看结果</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo first</span><br><span class="line">echo second &gt; output.txt</span><br><span class="line">echo third &gt; output.txt</span><br><span class="line">echo forth &gt;&gt; output.txt</span><br></pre></td></tr></table></figure><p>echo是回显，所以第一行结束我们会看见一个first的输出。如果是重定向到文件，则单右尖括号是写入覆盖，故两次操作后文件里分别由单独的second和单独的third组成。双右尖括号为继续写入，故最后output.txt中的内容是两行：third。</p><p>当然这里有个问题，就是forth有一定可能性是拼错了。</p><h4 id="thinking-0.7">Thinking 0.7</h4><p>command.sh内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span> </span><br><span class="line">echo echo Shell Start... &gt; test</span><br><span class="line">echo echo set a = 1 &gt;&gt; test</span><br><span class="line">echo a=1 &gt;&gt; test</span><br><span class="line">echo echo set b = 2 &gt;&gt;test</span><br><span class="line">echo b=2 &gt;&gt; test</span><br><span class="line">echo echo set c = a+b &gt;&gt; test</span><br><span class="line">echo c=\$[\$a+\$b] &gt;&gt; test</span><br><span class="line">echo echo c = \$c &gt;&gt; test</span><br><span class="line">echo echo save c to ./file1 &gt;&gt;test</span><br><span class="line">echo echo \$c\&gt;file1 &gt;&gt;test</span><br><span class="line">echo echo save b to ./file2 &gt;&gt;test</span><br><span class="line">echo echo \$b\&gt;file2 &gt;&gt;test</span><br><span class="line">echo echo save a to ./file3 &gt;&gt;test</span><br><span class="line">echo echo \$a\&gt;file3 &gt;&gt;test</span><br><span class="line">echo echo save file1 file2 file3 to file4 &gt;&gt;test</span><br><span class="line">echo cat file1\&gt;file4 &gt;&gt;test</span><br><span class="line">echo cat file2\&gt;\&gt;file4 &gt;&gt;test</span><br><span class="line">echo cat file3\&gt;\&gt;file4 &gt;&gt;test</span><br><span class="line">echo echo save file4 to ./result &gt;&gt;test</span><br><span class="line">echo cat file4\&gt;\&gt;result &gt;&gt;test</span><br></pre></td></tr></table></figure><p>这里需要注意的是，所有需要被打印到test里面的符号都需要转义，否则无法输出，会当做指令去操作。</p><p>result文件中内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><code>echo echo Shell Start</code> 与<code>echo 'echo Shell Start'</code>没有区别，都是输出<code>echo echo Shell Start</code>。</p><p>而对于<code>echo echo \$c&gt;file1</code> 与<code>echo 'echo \$c&gt;file1'</code>的效果，如图（忽略第一行）：</p><p>首先是<code>echo 'echo \$c&gt;file1'</code>，显然他只是在打印字符串</p><img src="03/28/BUAA-OS-LAB0/image-20220321232133765.png" class title="image-20220321232133765"><p><code>echo echo \$c&gt;file1</code> 的结果：</p><img src="03/28/BUAA-OS-LAB0/image-20220321232223350.png" class title="image-20220321232223350"><p>它还同时产生了一个空的file1文件。</p><p>但本人在一开始做lab0的时候，印象中这里是`xxx'这样形状的两个引号，看起来是打错了。不过两个``，即两个反引号形成的串是要执行的命令，echo``是用来输出执行结果的。</p><h2 id="二实验难点">（二）实验难点</h2><p>个人在 Exercise 0.3 中稍有卡顿，并在 Exercise 0.4中遭遇较大挫折。</p><h4 id="sedawkgrep等字文本处理命令的使用">sed、awk、grep等字文本处理命令的使用</h4><h6 id="sed">sed</h6><p>sed是一个文件处理工具，可以将数据行进行替换、删除、新增、选取等特定工作。这里用到的是提取第8行的命令：<code>sed -i '8p' $1 &gt; $2</code></p><h6 id="awk">awk</h6><p>awk是一种处理文本文件的语言，是一个强大的文本分析工具。本实验中用到的命令：awk -F[待分割的符号] '{print$[分割后要保留这一行的第几项][可以用逗号分割多个项]}' [输出文件]</p><h6 id="grep">grep</h6><p>grep是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。简单来说，grep命令可以从文件中查找包含pattern部分字符串的行，并将该文件的路径和该行输出至屏幕。</p><p>可以使用<code>grep -r [待查找的函数/文件/前缀/类型名字] [位置，比如*]</code>来在整个项目目录中查找某个函数名、变量名等特定文本。</p><p>用法：<code>grep [选项]... PATTERN [FILE]...</code></p><p>这个实验中用到了管道，用grep将包含一定pattern的行提取出来，交给awk去分割答案：<code>grep -n $2 $1 | awk -F: '&#123;print $1&#125;' &gt; $3</code></p><h4 id="makefile-初见面">Makefile 初见面</h4><p>根据自己两周以来对于makefile的接触，本人发现其功能极为强大也非常好用，统一编译，统一删除，非常有灵活性和工程管理能力，由于头一次接触这种大型工程类项目，对于每个文件夹内都有Makefile，接受统一调度这件事感到非常新奇。</p><p>但相应的，本人在编写Makefile文件时也遭受了许多挫折，比如看不懂，无法下手，不知道多个文件夹中的Makefile应该怎么相互作用。</p><p>最后还是运用了http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor这个教程，一步一步的尝试写出了Exercise 0.4。</p><p>一些要点：</p><ul><li>在Makefile开头可以写一些宏，用[宏]=[要表示的东西]这样的格式，调用的时候用<code>$(宏名)</code>即可。可以很方便的把所有要编译的文件，或者是需要include的头文件都写在一起，直接调用！</li><li>Makefile文件的第一个process可以直接用make命令调用，所以可以把编译写在第一个，其他的就用make+ ProcessID调用</li><li>一些奇怪的符号<ul><li><code>$$</code>：Shell本身的ProcessID</li><li><code>$?</code>：最后运行的命令的结束代码（返回值），在考试中用到了，可惜死在了别的地方上</li><li><code>$*</code>：所有参数列表，也就是目标</li><li><code>$@</code>：所有参数列表，但是相比于<code>$*</code>有别的功能，即可以当数组用</li><li><code>$#</code>：shell的输入参数的个数</li><li><code>$^</code>：代表所有的依赖对象</li><li><code>$&lt;</code>：代表第一个依赖对象</li></ul></li></ul><p>其实看懂了这些符号之后就比较能上手了。后来本人在子文件夹中详细写了编译和makeclean的方法，父级目录只需要把自己的编译和清楚写成调用子文件夹中的make方法即可。</p><p>在这个子文件夹的Makefile文件中，本人根据教程运用了很多宏，但当时对这些语法非常不熟悉，导致调了很久才成功的不再报错而运行了起来。但宏的运用应该能很好的降低大型工程的复杂度，也方便修改。</p><p>子文件夹中的Makefile：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">IDIR = ../<span class="keyword">include</span></span><br><span class="line">_DEPS = fibo.h</span><br><span class="line">DEPS = <span class="variable">$(<span class="built_in">patsubst</span> %,<span class="variable">$(IDIR)</span>/%,<span class="variable">$(_DEPS)</span>)</span></span><br><span class="line"></span><br><span class="line">ODIR = ./</span><br><span class="line">_OBJ = fibo.o main.o</span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %,<span class="variable">$(ODIR)</span>/%,<span class="variable">$(_OBJ)</span>)</span></span><br><span class="line"></span><br><span class="line">EDIR = ../</span><br><span class="line"></span><br><span class="line"><span class="variable">$(ODIR)</span>/%.o: %.c <span class="variable">$(DEPS)</span></span><br><span class="line">        gcc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span> -I<span class="variable">$(IDIR)</span></span><br><span class="line"></span><br><span class="line"><span class="section">fibo: <span class="variable">$(OBJ)</span></span></span><br><span class="line">        gcc -o <span class="variable">$(EDIR)</span><span class="variable">$@</span> <span class="variable">$^</span> -I<span class="variable">$(IDIR)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm <span class="variable">$(OBJ)</span></span><br></pre></td></tr></table></figure><p>虽然确实比较丑陋，但还是有种学到了的成就感。</p><h2 id="三思考感悟">（三）思考感悟</h2><p>作为第一次，或者第零次实验，本人是从下午上机的时候才开始写的，在课上写到了Exercise 0.3 的后半部分，但可惜在 Exercise 0.4卡了很久，最后在下午快结束的时候连滚带爬的撑过了测试。</p><p>这次在做题的时候，完全就是各种地方找资料，查基础概念，使劲研读，在各种地方建tmp文档，尝试看到的那些命令们，学习shell、linux基本命令、Makefile的用法，以及git怎么操作等基础知识。有了跳板机，不用自己配置虚拟机环境，这一点对于快速上手来说还是很友好的。</p><p>指导书起到了巨大的帮助，基本上所有的问题都能在指导数中找到答案，可惜有些地方本人的领悟能力还是太差，所以依旧借助了大量互联网的力量才读明白。</p><h2 id="四遗留问题">（四）遗留问题</h2><p>是上机的时候遇到的。</p><p>本人在运行一个.c文件编译后的执行文件时，要往其中填入输入。</p><p>于是本人分别采取了<code>echo $1 &gt; test</code>、<code>echo $1 &gt; ./test</code>、<code>echo $1 | test</code></p><p>但本人万万没想到应该是<code>echo $1 | ./test</code>，这样写。</p><p>当然，没有采用./的方式运行确实是自己的疏漏，但本人现在不明白的地方在于为什么必须用管道而不是重定向，虽然在跑oo的自动评测的时候就接触了PIPE，但本人依稀记得以前一直在用c语言的freopen这样的重定向操作进行文件的读入，不过或许这两种重定向的机制不一样？</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OO_U1</title>
      <link href="/2022/03/28/BUAA-OO-U1/"/>
      <url>/2022/03/28/BUAA-OO-U1/</url>
      
        <content type="html"><![CDATA[<h1 id="buaa_oo_u1_summary">BUAA_OO_U1_Summary</h1><h3 id="一-架构设计">一 / 架构设计</h3><hr><h4 id="题目解析">1.0&gt; 题目解析</h4><ol type="1"><li>给出一个最多嵌套一层括号的表达式，进行展开与同类项合并。表达式里的运算有<code>+ - * **</code>，变量是<code>x</code>。</li><li>新增函数：三角函数、求和函数（出现变量<code>i</code>）、自定义函数（出现变量<code>y</code><code>z</code>）。</li><li>括号可嵌套多层。</li></ol><h4 id="hw1">1.1&gt; HW1</h4><h5 id="做法分析">1.1.1&gt; 做法分析</h5><p>​ 整个过程中，我需要做的就是<strong>展开表达式</strong>。</p><p>​表达式有三种，一种是只有加法的，一种是又有加法又有乘法的，另一种是套着括号的。套着括号的又有两种，一种是只有加法的，一种是又有加法又有乘法的。所以在这里，我们发现了一个loop：表达式-&gt; 项 -&gt; 带括号的表达式 -&gt; 表达式 -&gt; ···</p><p>​一开始，看到这个题目，本人首先想到的是用表达式树去做。但是看到题目中“不推荐使用栈”以及training的代码提供的框架后，蒟蒻也去搜寻了一下<strong>递归下降</strong>的思想。</p><p>​ 如果化用到这道题目里，那大概是这样的：</p><p>这里涉及到一些分类：</p><ul><li><strong>表达式</strong>：由<strong>加号</strong>连接的算式</li><li><strong>项</strong>：由<strong>乘号</strong>连接的算式-<strong>因子</strong>：最小元，在第一次作业里即为<strong>幂函数</strong>（把常数也是一种特殊的幂函数）或者括号。</li><li><strong>括号</strong>：剥开来又是<strong>表达式 </strong></li></ul><p>​所以，这里用到的计算顺序就是从整体的表达式开始，一点点下降到项，再到因子，从因子返回计算好的答案，回到项使之返回答案，回到表达式，返回最终答案。</p><h5 id="表示方法">1.1.2&gt; 表示方法</h5><p>​蒟蒻采取了一些偷懒的办法，因为她发现，无论是表达式，还是项，亦或是因子，他们都可以称之为<strong>多项式</strong>：货真价实的多项式/ 单项式 /比较小巧的单项式。所以全程本人均采用一个多项式（polynomial）对象进行加法或者乘法的运算，因子也是它，项也是它，表达式也是它。</p><h5 id="合并方法">1.1.3&gt; 合并方法</h5><p>​由于需要应对性能分的重压，所以我们需要对多项式进行合并使得表达式尽量短。所以我们可以在每个多项式类用一个<strong>HashMap</strong>存多项式中的每个单项式，其中<strong>key代表次数</strong>，<strong>value代表系数</strong>。</p><h5 id="预处理">1.1.4&gt; 预处理</h5><p>​为了适应lexer，方便其分词，所以使用了非常繁杂的预处理（指预处理了6次）。其中涉及到的环节是去除连续的<code>+-</code>号，把减法变成加上一个负数，把所有的乘方变成乘法。</p><p>​看起来是很符合常理的方法，但是，蒟蒻却采用了非常程设的for循环方法，导致她在debug的时候总是因为少了半拉括号，丢了一点符号，两个符号连在一起了而感到无助。</p><p>​ 就比如进行乘方消失术的时候：</p><p>​在这里我们需要知道的是：对谁求n次方，n是多少。方法即检测是否有连续出现的*，如果是连续出现的，由于题目限制，这里有两种情况：一，前面是x，这是幂函数；二，前面是个括号，需要拆开。所以还需要两个“指针”，在循环中不断记录最新的左括号和右括号位置，这里也是由于题目限制，只有一层括号所以可以这么做（言下之意，没有可扩展性）。等一路循环到**这里，两个“指针”记录的就是最后面的括号了。</p><p>​好，现在分析出了需要n次方的对象，那么我们要把这个对象取出来。这很好办，要么是x，要么是整个括号。然后把这个子串拼到生成的串后面，两两之间添加*号即可。</p><p>​n的求法更加简便，由于前面可能存在一个符号，故先把符号判断掉，如果没有符号就while(Character.isdigit(c))循环下去，和快读的样子差不多。当然，这道题里限制了符号只能是+，位数也不可能超过1，所以可以有适当的省略。</p><p>​其中要注意的就是这个记录当前判断位置的“指针”来回跳转的位置，特别是需要跳过后面的n次方的数字，精准的抵达下一个处理的字符处。还有就是0次方1次方这种恼人的东西。所以在实现中，本人每次都在StringBuilder后面append字符，如果遇到各种次方，就把刚刚append上去的需要次方的子串删掉，再按数量拼接上去。</p><p>​ 可见非常麻烦，也容易出现各种疏漏。</p><h5 id="分词">1.1.5&gt; “分词"</h5><p>​这里完全借鉴了training里面的Lexer类，用的相同的方法，一点一点的读。所分的“词”有两种：<strong>因子</strong>（带符号的整数或者<code>x</code>）/各种<strong>运算符</strong>（<code>+*()</code>）。</p><p>​ 每次都往下读下一个可返回的“词”并返回，用于计算。</p><h5 id="计算方法">1.1.6&gt; 计算方法</h5><p>​经过预处理之后，表达式已经变成了<strong>只有加法和乘法</strong>的样子。所以再借用递归下降的思路和多项式的对象存储，我们就可以开始计算表达式了！</p><ul><li><p><strong>表达式层</strong>：目标是全部变成加法，获得所有项的和。所以如果发现了+号，则往表达式内添加项；否则去往项层。</p></li><li><p><strong>项层</strong>：目标是全部变成乘法，获得所有因子的乘积。所以如果发现了*号，则往项内添加因子；否则去往括号/因子层。</p></li><li><p><strong>括号/因子层</strong>：括号即另一个表达式，同样需要进行加法操作。所以如果发现了(，则去往表达式层，如果是因子则直接返回因子对象，回退至项层，直至项层计算完毕，回退至表达式层，直至表达式计算完毕，输出结果。</p></li><li><p><strong>加法</strong>：利用HashMap的特性，找到<strong>幂次相同</strong>的元素使系数直接相加，否则直接添加这个项。</p></li><li><p><strong>乘法</strong>：直接<strong>系数相乘，幂次相加</strong>即可。</p></li></ul><p>​所以通过“分词器”遍历一次表达式，我们便可以计算出表达式展开后的结果，同时进行化简。</p><h5 id="代码构架">1.1.7&gt; 代码构架：</h5><img src="03/28/BUAA-OO-U1/HW1.png" class title="HW1"><ul><li><strong>Main</strong>：负责读入并串联所有的方法，最后输出表达式。</li><li><strong>Initiate</strong>：负责<strong>预处理</strong>表达式，精简连续的符号，把减法全部变成加法，拆开所有乘方，删去所有前导零。</li><li><strong>Lexer</strong>：分词。</li><li><strong>Handler</strong>：<strong>递归下降</strong>的主体，拥有表达式层、项层、因子层和括号层，使每层各司其职，自上向下调用，自下向上返回展开+化简结果。</li><li><strong>AddOperator</strong>：即前文所述表达式层，得到所有的项并使之相加。</li><li><strong>MulOperator</strong>：即前文所述项层，得到所有的因子并使之相乘。</li><li><strong>Unit</strong>：其实叫Monomial更好，存了一个幂函数的系数和指数，便于封装，在HW1里面显得有一点点多余。</li><li><strong>Polynomial</strong>：HashMap里面存放Unit的集合，也就是用来存放各种算式的<strong>多项式对象</strong>，贯穿于整个计算过程。</li></ul><h4 id="hw2">1.2&gt; HW2</h4><p>​同样的，整个过程中，我需要做的就是<strong>展开表达式</strong>。只不过，这次新增了很多函数。​自封的第一单元最痛苦的一次作业！</p><h5 id="迭代开发">1.2.1&gt; 迭代开发</h5><p>​首要的问题是，我如何继续利用之前的架构，在之前的架构上进行迭代以避免在一个自认为性能还可以的架构上进行大面积重构。也就是说，我需要考虑这些<strong>新增的要求需要对HW1的哪些设计做出变更</strong>。</p><ul><li><strong>三角函数</strong>：是一种新出现的因子！所以之前的把幂函数作为最小元的存储方式失效。</li><li><strong>自定义函数和求和函数</strong>：是一种分词不能处理的语言！所以之前的预处理不足以满足之后的处理。（对，在第二次作业这里蒟蒻只想到了要对预处理进行变更，格局暂未打开。）</li><li><strong>化简方式</strong>：三角函数涉及到的化简就多了，什么和差化积两倍角三倍角各种技巧，但这些都暂时不在蒟蒻的考虑范围之内，毕竟正确才是首要的。</li></ul><p>​ 在明晰了需要变更的地方之后，蒟蒻开始了新的征程。</p><h5 id="表示方法-1">1.2.2&gt; 表示方法</h5><p>​多项式依旧还是之前的<strong>多项式</strong>，只不过HW1中显得多余的<strong>Unit</strong>可以被利用上了。这时，最小元变成了形如$ a * x ^ b * [sin(Expr) ^ c] * [cos(Expr) ^ d] $ 的样子的项。<span class="math inline">\([ \space ]\)</span>的意思是这是一个一群三角函数相乘得到的表达式。这里稍微产生了一点点先见，在三角函数中存储的是<strong>一整个表达式</strong>，而非仅为题目描述的幂函数或者常数。</p><p>​最小元的样子确定了，但为了维持之前<strong>计算和简化同时进行</strong>的策略，我们也需要对Polynomial对象中的HashMap存储的内容进行更改。这里本人遇到了两个难题：</p><ol type="1"><li>如何<strong>存储所有的三角函数</strong>，毕竟一个项里面可以有很多相乘的不能合并的三角函数，这就和在乘法时可合并的幂函数区分开了。所以为了维护每个项中的三角函数，需要一个HashMap来存储这些相乘的三角函数。</li><li>如何<strong>存储所有的项</strong>，也就是Polynomial对象里面的单项式们改如何被堆放在一起，成了第二个问题。这里的关键矛盾在于，把什么作为key，什么作为value，才能在保证<strong>完成存储任务的情况下尽量实现合并同类项的功能</strong>。</li></ol><p>​经过四天的冥想和讨论学习（致使蒟蒻狂赶ddl才交上去），最终的解决方法：</p><ol type="1"><li>在Unit中，用一个HashMap存储所有的三角函数，<strong>三角函数类</strong>（详见不太后的后文）<strong>作为key</strong>，这个三角函数的<strong>指数作为value</strong>，完成存储同时在相乘时实现同类项的合并。</li><li>而Polynomial只需要将Unit存放在一块儿即可。存储问题解决。为了实现合并同类项，本人同样使用了一个HashMap容器，<strong>Unit作为key</strong>，这个Unit的<strong>系数</strong>单独拿出来<strong>作为value</strong>，在相加和相乘的时候便于合并。</li></ol><p>​同时，这次的作业更加强调了需要对<strong>因子进行分类</strong>，分别建立对象，让他们自己处理自己的事情的能力。下面对本人在这次作业中分的类进行一些阐述，这一部分也是相较HW1的增量：</p><ul><li><strong>TriX</strong>：三角函数的集合，属性为三角函数的类型和括号中的多项式。</li><li><strong>Func</strong>：自定义函数，属性为名字，参数列表以及表达式。内部封装好了分割表达式并通过传入函数的调用获得替换参数后表达式的方法。</li><li><strong>Sum</strong>：求和函数，属性为求和下界、上届以及求和表达式。内部封装好了把求和表达式展开成为加法连接的表达式的方法。</li></ul><h5 id="合并方法-1">1.2.3&gt; 合并方法</h5><p>​ 这里分为两个部分：</p><ul><li>对于<strong>三角函数</strong>的合并：当合并相乘的三角函数时，通过重写三角函数类的equals和hashCode使得只有当类型和内部储存的多项式相同的情况下才会判定两个三角函数相等，此时对指数进行加和。</li><li>对于<strong>Unit</strong>的合并：重写Unit的equals和hashCode，判断x的幂次，三角函数列表是否相同，不判断系数<ul><li>合并两个相加的Unit：如果二者按重写后的方法判定为相等，则系数相加</li><li>合并两个相乘的Unit：直接进行暴力乘法，然后通过相加每一项的方式合并同类项</li></ul></li></ul><p>​之后所有的运算都可以通过扩展Unit（或者说Monomial）为Polynomial得到。</p><h5 id="预处理-1">1.2.4&gt; 预处理</h5><p>​可以说，通过第一次互测本人学习到了很多别人的优秀方法，或者是自己劣质的for循环程设式冗长繁杂意识流难以捉虫的初始化终究是败下了阵来，这次我对于初始化这一部分进行了翻新，利用正则表达式而非一次次for循环的操作直接replaceAll。当然这样也要求逻辑清晰，有条理有顺序的处理，否则会较容易被hack到（详见后文）。</p><p>​但是对于乘方的处理，本人除了运用大家都想到了把<code>**</code>的替换成为<code>^</code>的方法以外，并没有运用他人在handler里面直接处理的方式，而还是在预处理中通过for循环进行了展开，但实现了拆除多层乘方嵌套的递归方法。功能强大了一些，但是在这里初始化与在handler里一同处理掉的效率差距是明显的：需要多遍历一次而且会把表达式展开成为非常冗长的串，再进行分词、读取、处理。由于时间不足，来不及进一步优化，所以就把这一部分留给了HW3去解决。</p><h5 id="代码构架-1">1.2.5&gt; 代码构架</h5><p>​在这次开发之前，本来想借用对于表达式层、项层和因子层均采用不同类型进行对象包装的方法来构架代码，但越改越错，本人对于类型互相转换的能力实在是有欠缺，不得不悬崖勒马，即使停手。所以整个代码依旧是没有任何继承、实现关系的“面向过程”模式。</p><img src="03/28/BUAA-OO-U1/HW2.png" class title="HW2"><ul><li><p><strong>Main</strong>：同上，负责读入并串联所有的方法，最后输出表达式。</p></li><li><p><strong>Initiate</strong>：负责<strong>预处理</strong>表达式，精简连续的符号，把减法全部变成加法，拆开所有乘方，删去所有前导零。</p></li><li><p><strong>Lexer</strong>：分词。</p></li><li><p><strong>Handler</strong>：<strong>递归下降</strong>的主体，拥有表达式层、项层、因子层和括号层，使每层各司其职，自上向下调用，自下向上返回展开+化简结果。</p></li><li><p><strong>AddOperator</strong>：即前文所述表达式层，得到所有的项并使之相加。</p></li><li><p><strong>MulOperator</strong>：即前文所述项层，得到所有的因子并使之相乘。</p></li><li><p><strong>Sum</strong>：求和函数，可<strong>返回加法表达式</strong>，不能直接返回求和结果。</p></li><li><p><strong>Func</strong>：自定义函数，可<strong>返回替换后的表达式</strong>，不能直接返回调用的结果。</p></li><li><p><strong>Unit</strong>：其实叫Monomial更好，存了一个幂函数的系数和指数，便于封装，在HW1里面显得有一点点多余。</p></li><li><p><strong>Polynomial</strong>：HashMap里面存放Unit的集合，用来存放各种算式的<strong>多项式对象</strong>，贯穿于整个计算过程。</p></li></ul><h4 id="hw3">1.3&gt; HW3</h4><p>​同样的，整个过程中，我需要做的就是<strong>展开表达式</strong>。只不过，这次可以嵌套括号了！</p><p>​ 勉强封它一个第一单元最轻松的作业！</p><h5 id="迭代开发-1">1.3.1&gt; 迭代开发</h5><p>​比起努力实现HW3的功能，更多的是在为之前写的很多补具扩展性的方法买单。</p><p>​同样，从<strong>新增的需求</strong>下手：函数调用时参数可以是其它函数，三角函数内部可以是表达式。而因为这次没有新增需要分类的对象，没有新增运算符，所以对于之前的分类和每种类型对象的属性都不需要修改，故极大的减小了工作量。</p><p>​那这里，本人需要修改的功能就是对函数的预处理部分。其实，修改一词不如换成删除。在HW2时，由于没有思路缺乏格局，所以表达式一律通过<strong>替换</strong>得到，也没有继续递归下去实现多层嵌套的替换，所以只能处理最简单的调用方式。所以这一次，需要对函数进行<strong>建模</strong>，认为它是由<code>&lt;名称&gt;(Expr1, Expr2, Expr3)</code>构成的，方能继续处理。这里可能涉及的问题就是括号如何匹配，如何知道当前的括号是整个函数的一部分，在紧后的嵌套括号章节中会进行阐述。</p><p>​由此，在之前的分层架构当中，需要把自定义函数和求和函数也加进去，变成新的层次：</p><p>​在这张图里，同时也出现了一个新的面孔：<strong>Power层</strong>。这一层即在HW2中所述，之前的预处理法存在诸多问题待改善，于是在HW3终于得到了解决。解决方法即为每得到一个因子时都对其后面的符号进行判断，如果是乘方符号（预处理替换成<code>^</code>）则直接读次数，然后相乘，返回乘积。这不比展开成一大片简洁多了！</p><h5 id="嵌套括号">1.3.2&gt; 嵌套括号</h5><p>​其实，运用了<strong>递归下降</strong>的架构，一切嵌套括号的问题早已迎刃而解。遇到括号，我们会认为里面的内容是表达式，再按照递归调用的方法，不断地进入下一层括号，直到遇见第一个<code>)</code>，Handler就知道了，要开始返回计算结果给上一层了作为因子处理了，正如压栈-处理-弹栈一样，通过递归解决掉了括号匹配的问题。</p><p>​那么，如果括号属于函数怎么办呢？那就<strong>判断</strong>一下是否是函数以及函数的类型，是自定义函数就按自定义函数的模型进行读取内容和表达式展开，是求和函数就按求和函数的方式替换<code>i</code>并计算加和。</p><h5 id="代码构架-2">1.3.3&gt; 代码构架</h5><p>​在这次的实现中，并未进行太多的改动，依旧<strong>沿用了HW2的框架</strong>，除了其中预处理的一些部分拿到了Handler类中别无二致，所以不再进行UML类图的展示了。</p><h5 id="化简方法">1.3.4&gt; 化简方法</h5><p>​ 由于三次的化简并无太大区别所以放在一起阐述了。</p><p>​本人的化简直接渗透在计算的过程中，是多项式中的HashMap的存储结构使然。在第一次作业中，这样的做法很有效，但是由于本人没有去处理让第一个符号尽量是正号使其可以被忽略以省去一个符号的优化（唯手懒尔），导致性能分有一点损失。在后两次作业中，我也没有继续对三角函数的特性进行化简，一是因为不知道如何快速判断多项式中存在可以化简的两项，二是不好确定化简后的长度会变短。</p><p>​在互测和研讨课中，蒟蒻也学习到了他人的化简方法：最简单的方式就是在实现正项尽量提前的功能后，把可以提出sin中的负号，扔掉cos中的负号。（但是这样有一定产生虫子的风险。可见后文互测回顾部分。）其余的方式涉及直接用字符串替换掉$ sin(Expr))^2 $ 为 $ 1 - cos(Expr)^2 $，然后将得到的表达式再计算一遍，得到最终化简结果。（这样有超时的风险。）还有对于二倍角的处理，这个相对简单，但是容易发生化简后长度更长的现象。</p><p>​但是本质上，所有的化简都遵从这样一个框架：从因子开始，保证局部最简，然后使得项最简，表达式最简。</p><p>​经过大量被遗弃的性能分的洗礼，蒟蒻也清醒的认识到自己的化简只是最最基础的化简，仍有大量优化空间。</p><h3 id="二-测试设计">二 / 测试设计</h3><hr><h4 id="在python中调用jar包">2.1&gt; 在python中调用jar包</h4><h5 id="打jar包">2.1.1&gt; 打jar包</h5><p><img src="image-20220304192220223.png" alt="image-20220304192220223" style="zoom:50%;"></p><p>​ 所有设置完毕后，在顶栏选择build，点击build artifact -build即可。</p><h5 id="python调用jar包">2.1.2&gt; python调用jar包</h5><p>运行jar：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jarDir = <span class="string">&quot;D:\\...\\xxx.jar&quot;</span></span><br><span class="line">process = subprocess.Popen([<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;-jar&#x27;</span>, jarDir], stdin=PIPE, stdout=PIPE, stderr=PIPE)</span><br></pre></td></tr></table></figure><p>​ 输入并获得输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stdout, stderr = process.communicate(strInput.encode())</span><br></pre></td></tr></table></figure><p>​由于这样得到的stdout只能输出一行，即，所以在取用结果的时候，可能需要进行如下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret = []</span><br><span class="line">ret += stdout.decode().split(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​这里专门说明的原因是stdout必须先<strong>decode</strong>才能从byte类型变成str类型，反之则需要<strong>encode</strong>，如上面的输入<code>strInput.encode()</code>。</p><p>​ 同时，如果使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process = subprocess.Popen(parserStudentWin64Dir, stdin=PIPE, stdout=PIPE, stderr=PIPE)</span><br><span class="line">stdout, stderr = process.communicate(strInput.encode())</span><br><span class="line">process.kill()</span><br></pre></td></tr></table></figure><p>​则可以给那些使用了<strong>预解析读入</strong>的代码跑测试，即第一行运行的是exe文件，Popen里第一个参数即exe文件的位置，得到的stdout可以直接作为下一次communicate的输入，无需解码。</p><h4 id="评测姬初尝试">2.2&gt; 评测姬初尝试</h4><p>​通过运用python强大的库文件<strong>sympy</strong>、<strong>Xeger</strong>和<strong>subprocess</strong>，我完成了以下三个任务：造随机样例，喂给程序并获得输出，对比输出和答案（可能是小伙伴的对拍结果，也可能是sympy处理后的结果）。subprocess的文档令蒟蒻读得异常痛苦，基本上用了一整天的时间到处搜集资料才终于调通了程序。</p><p>​样例的制造过程比较暴力。首先<strong>对表达式进行划分</strong>：我们有幂函数、常数、运算符、括号表达式、三角函数、求和函数等（蒟蒻没有写自定义函数的自动化测试，因为她感觉这是在用python造java实现过的功能），故每种都定义一个建造方法，然后随机的把他们用运算符拼接在一起。</p><p>​答案比较的过程只需要<strong>用sympy</strong>就可以解决，但是后两次作业涉及到三角函数，直接化简然后比较在本人这里会报错，所以本人采取了标答和自己的答案相减，通过结果是否为0判定答案的正确性。但由于sympy无法处理含有前导零的表达式，所以这个可以运行随机无前导零的数据并检验结果是否正确。这种时候只能通过对拍来解决了，否则相当于我又在python里面写了一遍java写完了的HW。</p><p>​但是这样的评测姬效果并不明显，自己的bug没有被跑出来（别人的bug跑出来的比读代码慢得多）而且概率实在是太小了。所以若非<strong>明显错误</strong>或者比较常出现的错误，这样随机的方法<strong>并不显优势</strong>，而且费电脑，费风扇，在冬天倒是可以提供不少热量。</p><h4 id="手动数据构造">2.3&gt; 手动数据构造</h4><p>​鉴于随机的效果不够明显，本人也针对了各种边界条件进行了数据的构造，如使用2147483648去测试是否正确使用了BigInteger；用各种连续的符号，如<code>+++</code>，<code>(-+</code>，<code>*-</code>等进行针对预处理的测试；用00000或者00001对前导零的处理进行测试；用大量嵌套在一起的括号对架构进行测试（指没有爆栈也不会TLE）等。</p><p>​如果有更多三角函数的优化，也应该做详细的测试。但本人只替换掉了所有的<code>sin(0)</code>和<code>cos(0)</code>，所以只是检测了一下他们的输出是否正确。</p><p>​ 更多的数据制造将在bug分析部分进行阐述。</p><h3 id="三-度量分析">三 / 度量分析</h3><hr><h4 id="代码行数">3.1&gt; 代码行数</h4><img src="03/28/BUAA-OO-U1/image-20220324005653941.png" class title="image-20220324005653941"><img src="03/28/BUAA-OO-U1/image-20220324005754651.png" class title="image-20220324005754651"><img src="03/28/BUAA-OO-U1/image-20220324005959176.png" class title="image-20220324005959176"><p>​相对来说，总体工程量不大，但是对于刚刚接触面向对象的本人来说还是有些许难度。</p><p>​可见在第三次的修改中，代码行数反而比第二次少了，所以不重复造轮子，让Handler类尽其值应该是有效之举。同时，观察Initiate类，发现其行数在第三次的修改中是行数变少的主力，其中用于输出信息调试的注释也变少了很多，故把Power单独作为一层在计算中处理而不是预处理时包里展开的做法，可以印证上句提出的观点。</p><p>​ （而本人一向到处留空行的习惯也被数据发掘了。）</p><h4 id="metrics分析">3.2&gt; metrics分析</h4><p>​ 一点解释：</p><ul><li><p><strong>CogC</strong>：<strong>认知复杂性</strong>（？直译但有点奇怪），计算每个<strong>非抽象方法的认知复杂性</strong>。该度量与圈复杂度类似，但旨在明确度量可理解性，而可理解性可能与可测试性大不相同。每种控制结构的使用都会增加认知复杂度，嵌套控制结构越多，认知复杂度越高。</p></li><li><p><strong>ev(G)</strong>：<strong>基本复杂度</strong>，用来<strong>衡量程序非结构化程度</strong>。非结构成分降低了程序的质量，增加了代码的维护难度，使程序难于理解。因此，基本复杂度高意味着非结构化程度高，难以模块化和维护。实际上，消除了一个错误有时会引起其他的错误。</p></li><li><p><strong>Iv(G)</strong>：<strong>模块设计复杂度</strong>，用来<strong>衡量模块判定结构</strong>，即模块和其他模块的调用关系。软件模块设计复杂度高意味模块耦合度高，这将导致模块难于隔离、维护和复用。模块设计复杂度是从模块流程图中移去那些不包含调用子模块的判定和循环结构后得出的圈复杂度，因此模块设计复杂度不能大于圈复杂度，通常是远小于圈复杂度。</p></li><li><p><strong>v(G)</strong>：用来衡量一个模块<strong>判定结构的复杂程度</strong>，数量上表现为独立路径的条数，即合理的预防错误所需测试的最少路径条数，圈复杂度大说明程序代码可能质量低且难于测试和维护，经验表明，程序的可能错误和高的圈复杂度有着很大关系。</p></li></ul><p><img src="../../../%25E5%25AD%25A6%25E6%25A0%25A1/%25E5%258C%2597%25E8%2588%25AA/%25E5%25A4%25A7%25E4%25BA%258C/OO/U1/HW4/BUAA-OO-U1-Summary/image-20220324172123508.png" alt="image-20220324172123508"> <img src="03/28/BUAA-OO-U1/image-20220324172144720.png" class title="image-20220324172144720"></p><blockquote><p>HW1 metrics reloaded</p></blockquote><p>​可见红色的部分非常多，各种复杂度都处于很高的状态，特别是涉及初始化、输出的类和方法。但整体来看，e(v)即结构化程度还是相对较高的；但CogC也就是程序中的独立路径数量大（为了让输出最短需要各种特判+第一次作业中糟糕的for循环程设法初始化所致），模块之间高耦合，复杂程度高，明显是一份较为糟糕的代码。</p><img src="03/28/BUAA-OO-U1/image-20220325100834162.png" class title="image-20220325100834162"><figure><img src="../../../%25E5%25AD%25A6%25E6%25A0%25A1/%25E5%258C%2597%25E8%2588%25AA/%25E5%25A4%25A7%25E4%25BA%258C/OO/U1/HW4/BUAA-OO-U1-Summary/image-20220325100906594.png" alt="image-20220325100906594"><figcaption aria-hidden="true">image-20220325100906594</figcaption></figure><blockquote><p>HW2 metrics reloaded</p></blockquote><p>​从方法数量的角度看，增多了不少，四个评判标准下的复杂度平均值都有下降，其中iv(G)最为明显，说明耦合程度降低了。而通过优化输出方式，使输出分散到每种不同的因子，一点一点自底向上形成输出，使得输出的CogC降低了很多，剩余的圈复杂度基本上都落在初始化（乘方展开成乘法的步骤）上面了。相对，ev(i)平均值下降了但最大值上升了，这是因为我把去前导零的工作放在了初始化中而非分词的时候，现在回想起来还是应该在分词的时候做这项工作，反正粉刺的时候也要遍历，这样反而多循环一次。</p><p><img src="../../../%25E5%25AD%25A6%25E6%25A0%25A1/%25E5%258C%2597%25E8%2588%25AA/%25E5%25A4%25A7%25E4%25BA%258C/OO/U1/HW4/BUAA-OO-U1-Summary/image-20220325101505598.png" alt="image-20220325101505598"> <img src="../../../%25E5%25AD%25A6%25E6%25A0%25A1/%25E5%258C%2597%25E8%2588%25AA/%25E5%25A4%25A7%25E4%25BA%258C/OO/U1/HW4/BUAA-OO-U1-Summary/image-20220325101527310.png" alt="image-20220325101527310"> <img src="03/28/BUAA-OO-U1/image-20220325101541330.png" class title="image-20220325101541330"></p><blockquote><p>HW3 metrics reloaded</p></blockquote><p>​这张分析就更长了，因为分类的因子类型以及包装出来的方法确实很多。相对第二次，每一项平均的复杂度都降低了不少，从红色来看CogC降低了很多。原因在于把初始化中的拆乘方拿出去了，如果去前导零也拿出去可能还能降低不少（至少这个23不会存在了）。但相对应的，lexer的复杂度有所提升，这是难以避免、需要平衡的事情，毕竟他需要判断的符号又多了不少。</p><p>所以总体来看，复杂度以及最容易出错的部分就是初始化和输出了，捉到的虫子也很好的印证了这一点。</p><h3 id="四-捉虫大战">四 / 捉虫大战</h3><hr><h4 id="自我反省">4.1&gt; 自我反省</h4><h5 id="自测">4.1.1&gt; 自测</h5><ol type="1"><li><p>分割字符串。</p><p>​我们需要判断是否是空格或者是制表符，ascii码分别为32和9。于是让我想起了正则表达式里的，可以实现匹配**16进制**转义码。然后我就直接把<code>\\x32\\x09</code>写进去了，得亏还注意了一下这个位数必须为两位的问题，但忽略了这俩应该转换成16进制再写到。</p><p>​ 我测试的用例是2 + x * x，按理说极为简单，结果得到的结果是：</p></li></ol><img src="03/28/BUAA-OO-U1/image-20220325105632221.png" class title="image-20220325105632221"><p>​百思不得其解，为什么能分出这么奇怪的模样。直到我发现16进制，而因为过分巧合，0x32正好是数字2。</p><ol start="2" type="1"><li>各种少半拉括号，这个是前两次作业在拆乘方的时候容易出现的问题，特别是0次方，1次方和嵌套了乘方之处。</li><li>IDEAconsole的输入有时候会出问题，爆ZeroInput的错，这种时候如果重跑解决不了就是代码的处理出问题了。目前注意到的是不能先打一对儿括号上去，这样再回退到括号中间也没法输入了，有时候输入字符也是，但具体机制还没有研究明白。</li><li>在第二次作业，重写完两个类的equals之后，若在处理加法或者乘法时仍用HashSet存储多个待运算的Polynomial，会存在被equals和hashCode联手判断后认为相等于是覆盖的情况，需要替换成ArrayList才能不让x+x= x。</li></ol><h5 id="强测-互测">4.1.2&gt; 强测 + 互测</h5><h6 id="hw1-1">&gt; HW1</h6><p>​ 被hack数据：<code>5 * ( - + -01 + 7)</code>和<code>(--+2*x-x**+2*x*2)**2*2*2</code></p><p>​究其原因，就是左括号后面的加减号没有处理，再带上一个前导零就遇到问题了。</p><p>​大概2k组随机都没有跑出来。但这种bug存在的应该不少，所以之后的作业都换成了正则表达式，直接replaceAll，且捋清楚了初始化的顺序，重新组织了逻辑。</p><img src="03/28/BUAA-OO-U1/image-20220325111014437.png" class title="image-20220325111014437"><center>HW1互测结局</center><h6 id="hw2-1">&gt; HW2</h6><p>​ 第二次强测死的比较惨，原因是下列两个bug：</p><ol type="1"><li>没有考虑sum中计数起始和结尾两个数字的表式形式，把他们简单的理解为了单纯的数字，所以前导零可以处理，但是数字前面有符号的不可以，一旦遇到就报错，导致强测两个点RE了。</li><li>在第二次作业中，本人的多项式输出形式是幂函数*三角函数，但是没有处理掉有一个是1的情况，因为如果两个都是1，那么这项可能就剩下一个乘号了，由于逻辑想不通+没时间了就没改。但是蒟蒻忘记了她的三角函数中是一个多项式，所以会输出长这样会的三角函数：<code>cos(3*1)**2</code>，乍一看过去好像没什么问题，但是不符合形式化表达的判定。至此，蒟蒻又WA了两个强测点。互测中也是死在了这个输出格式的地方，在第三次作业中已经进行了修改。</li></ol><p>​ 幸亏这次互测中不能有针对sum的数据，否则我的数据将变得极为难看。</p><p><img src="image-20220325112428912.png" alt="image-20220325112428912" style="zoom: 33%;"></p><center>HW2互测结局</center><p>​从这次的bug来看，本人<strong>阅读指导书</strong>的精细度还是有待提高，两个问题都涉及到输入和输出的规则。</p><h6 id="hw3-1">&gt; HW3</h6><p>​第三次的代码对曾经出现bug的位置，如初始化和输出，都进行了改善，所以强测安稳地通过了。但是互测仍被挑出了bug，这个bug甚至还是我自己hack出来的：<code>sum(i, -01, +01, (-i**0))</code>。这也得怪在没好好<strong>阅读指导书</strong>。明明互测的时候很认真的读了发现i上面可以有指数，但是做题的时候偏偏就没注意，还自己思索了一下并坚定的认为i不需要带括号，这样少递归一层，免得出现爆栈的情况。当然，这个点报错的概率其实很大：</p><img src="03/28/BUAA-OO-U1/image-20220325113022724.png" class title="image-20220325113022724"><center>HW2互测过程截图</center><p>​但是强测并没有相关测试点，所以强测还是很安稳的通过了。互测也很刺激，当然也有<strong><font color="violet" size="3">大师</font></strong>吐槽我说你这个狂战士真是温文尔雅。</p><img src="03/28/BUAA-OO-U1/image-20220325113546760.png" class title="image-20220325113546760"><center>HW3互测结局</center><h4 id="互测他人问题总结">4.2&gt; 互测他人问题总结</h4><p>​共hack13次（但神奇的是下文总结出了14个bug）。而且喜欢合并提交，这样看起来成功率高一些（除了调动全房气氛以外没有任何用处）。</p><p>​ 互测中我主要使用自动评测机跑随机的数据，但效率不高。辅助以人工造样例+阅读代码（主要是预处理部分的逻辑问题和输出时的各种特判，因为这两个地方复杂度高，容易出错），效率较高但容易陷在一定的圈子之内。</p><h5 id="符号预处理">4.2.1&gt; 符号预处理</h5><p>​共两人次。都是消除连续三个符号的时候产生的<strong>预处理逻辑漏洞</strong>，通过<strong>读代码发现</strong>。</p><p>​大概可举例为，对于<code>+++</code>，经过第一次处理合并前两个加号，会变成<code>++</code>，然而没有第二次处理了，整个预处理过程就此结束。而同时又没有做有符号数的处理，所以遇到这种合并完前两个字符得到的结果和第三个字符的组合在前面处理过，后面不再处理的情况，就会报错，产生RE。</p><h5 id="为缩短表达式而进行了不当操作">4.2.2&gt;为缩短表达式而进行了不当操作</h5><p>​ 共两人次。</p><p>​首先是第一次作业中，碰到了一个较为难以理解的情况。输入<code>x**4-x</code>会输出<code>-xx**4</code>。</p><p>​通过阅读代码发现，作者将初步化简得到的表达式输出时，运用一个isHead的布尔值来判断是否是第一个项，这样可以忽略第一个正号的输出，可偏偏遗漏了第一项是-x时也要把isHead设为true的情况，导致上述图片中x**4被认为是第一个正项，从而省略了前面的正号，形成了两个x贴贴之势。</p><p>​其次是第三次作业中，对于sin(x)中符号的提取（这点蒟蒻本人确实没有想到）出现了一点点错误。如果sin中只有一项，那么此代码处理的天衣无缝。但若里面有多于一项且首项为负，则在提取负号的时候只会提取第一个负号，后面的符号均没有发生变化，于是产生了WA的错误。</p><p>​据说提取负号有TLE的风险，比如<code>sin(sin(sin(sin(sin(sin(sin((-1))))))))</code>这种样例，但蒟蒻当时也没想起来要测这种错误，于是就忽略掉了。</p><p>​ 所以，化简需谨慎哇！</p><h5 id="一些小细节本人未能理解原因的问题">4.2.4&gt;一些小细节+本人未能理解原因的问题</h5><ol type="1"><li><p>有代码挂在了<code>x*-1</code>这种输出上。打开代码一看，parser中虽然判断了这个因子前面是负号的情况，并使用了neg变量记录此情况，但定睛一看，neg是灰色的。所以仍需多做功能测试并好好使用IDEA强大的功能才行。</p></li><li><p>对于<code>(cos(x)*sin(x)+cos(x))**+2</code>，有代码会错误的将一部分sin和cos合并成同一种三角函数，但本人并未发现其中的缘由。</p></li><li><p>对于零的处理有误。第一个表现是输入0没有输出（显然是忘记处理了），第二个表现是计算过程中产生0则会报错。对于报错的猜测是和在处理过程中直接使用了删除最后一个正号但是没有特判表达式里是否有正号导致的越界而产生的报错。</p></li><li><p><code>-(1)**0</code>得到了+1。由于此份代码未使用递归下降法，本人也没有仔细阅读，故猜测问题为优先级顺序不正确所致。</p></li><li><p><code>sum(i, 2147483649, 2147483648, i)</code>，专门卡了使用int的同志。虽然战绩不佳，只卡到了一个人，说明大家都有用BigInteger的意识。</p></li><li><p>有份代码在处理<code>sum(i, -5, -2, i)</code>时会输出。阅读代码后发现，是因为sum中上下界的负数被转换成了正数去处理，所以变成了从5加到2。未能理解作者是如何想到这样处理的，但看起来也需要多造点功能测试的样例。</p></li></ol><p>​所以总结来看，需要多做测试，而首要的是<strong>功能测试</strong>，需要保证所有需要实现的功能都在掌握之中。其次就是<strong>边界测试</strong>，使得代码有足够的鲁棒性。还有就是仔细阅读指导书，拓展一下自己之前码代码时想到的输入的可能情况，毕竟任何时候，人的局限性都是存在的，自己想不到的情况自己自然难以处理。故互测时一个很有益的方式，可以让自己对题目要求的理解扩充为一整个房间内每个人题目要求的理解的并集。但如果代码足够<strong>鲁棒</strong>，结构足够清晰，有逻辑的按照一定规则执行，则很有可能在“无意识”的情况下少产生很多bug，这也是利用metricsreloaded等工具可以辅助我们写出更优秀的代码的原因。</p><h3 id="五-心得体会">五 / 心得体会</h3><hr><p>​在短短的一个pre之后，在开学第一天，我们就进入了码面向对象代码的阶段。拿到第一个题目的时候用了大量的时间读题，大量的时间思索，大量的时间学习使用什么样的架构和不那么大量的时间编码、测试。在第二和第三次作业的时候形成思维的速度稍有进步。在此之中，debug的能力也有一些提升。</p><p>​上学期的java课的大作业是在没有怎么理解面向对象机制的情况下乱诌的，pre的学习也并未让我对面向对象有更加深入的掌握，第一次的作业在结构化设计和层次分析上对我有很大的启导作用，但对于对象之间存在的关系的抽象本人未能格出来故也没有付与实践，毕竟本人很取巧的统一了所有的因子、项、表达式为多项式。也就是说，此次作业让本人学习到了如何分类，如何定义对象并设计他们的属性和行为。在pre中也学习到了如何利用继承及其优势。但是对于如何使用接口以减少代码的重复，什么是设计模式，如何运用工厂模式，本人的理解依旧非常微薄、浅显或是一窍不通。</p><p>​而关于代码的鲁棒性，经过metrics的洗礼，本人深刻的意识到了复杂度和鲁棒性之间的挂钩是真实存在的。复杂度高的地方就是容易被hack出bug的地方，因为复杂度高意味着要么情况真的很复杂，分支很多，要么就是逻辑不清晰，架构能力不好。故在以后的开发中本人也会尝试对代码逻辑进行更清晰的思考，如这次作业的输出部分，就有很多判断可以相互合并，简化代码并以降低发生错误的可能性。</p><p>​其次，关于代码的可扩展性，在三次作业的迭代中我也深有体会。比如一开始就使用了可以处理嵌套括号的层次设计，在第二次作业中就直接使用了多项式作为三角函数中的参数，这些都对减少后两次作业的修改量作出了卓越的贡献。而且，若可扩展性高，则存在一定的抗互测中奇怪数据的可能。</p><p>​需要补充的一点事，代码风格测试。它曾经是最令我抓狂的一件事。比如必须驼峰命名，方法行数不能超过60，不能用protected对象等等，需要改变一些自己的习惯才能得到一个好看的分数。但现在逐渐发现按照特定格式码代码是一件幸事。特别是方法长度的限定，使得可重复利用的部分都可以被抽象成新的方法，对阅读代码和bug定位都有很大好处。（所以在此也对之前胡乱的命名法则，不羁的空行和喜欢换行单独存在的左大括号表示诚挚的歉意。）</p><p>​ 看在这只蒟蒻扯了这么多话的份上，祝她顺利地挺过OO！</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oo_HW1</title>
      <link href="/2022/03/05/oo-HW1/"/>
      <url>/2022/03/05/oo-HW1/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译">题目翻译</h3><p>给我一个最多嵌套一层括号的表达式，让我展开。 合不合并看心情。</p><p>表达式里的运算有<code>+ - * **</code>，变量是x。</p><h3 id="蒟蒻思路">蒟蒻思路</h3><h4 id="section">2022/3/1 21:21</h4><h5 id="对象">对象</h5><p>虽说不用合并，但我可以把多项式作为整体，其中每个对象都是一段连续的多项式，遇到（）断掉，括号前、括号中、括号后分别为n个对象。</p><p>这是关于对象是什么。关于对象如何保存，在定义的操作类里使用一个ArrayList，里面塞进去所有的表达式，同时还需要一个ArrayList存储每个多项式中间的符号。</p><h5 id="方法">方法</h5><p>每个多项式类中都有一个hashmap，key是次数，value是系数，先对每个多项式都进行合并。</p><h5 id="树形">树形</h5><p>要我说，这个树形有点像由多项式组成的树。 二叉树。叶子是单独的一个项。每个节点都是多项式，从叶子向上是当前优先级最高的符号连接的两个多项式生成的新对象。这里有三种事儿要做，加、乘、和乘方。至于减，那好说。乘方就是乘，多整几层就行。所以优先级就是乘（乘方） &gt; 加（减）。于是从叶子开始，不断merge到一起，每层都是我设置的多项式对象，每层都根据两种操作（乘/加）进行合并，就可达到根，得到最终的结果。</p><h5 id="怎么得到对象">怎么得到对象</h5><p><del>看缘分。</del> 可我真的想不明白啊！反正是要把两个加号之间的，两个乘号之间的（3*x不用，但x*x需要），括号之间的多项式分开，得到的就都是叶子节点上的多项式对象了，在处理叶子层的handler对象的多项式对象集合中加入这些对象，并记录两两之间的符号。</p><p>然后应该把括号处理掉，把乘方处理掉，把乘号处理掉，就可以输出了。</p><h5 id="什么时候结束">什么时候结束</h5><p>发现符号数组空了。 但我真的没想明白……</p><h4 id="section-1">2022/3/2 13：53</h4><h5 id="架构">架构</h5><p>昨天晚上刚知道有个training，好不容易终于看懂了，决定把它的架构拿来用。和我干想的有点相似。</p><h4 id="section-2">2022/3/3 14:33</h4><h5 id="进行测试">进行测试</h5><p><code>- +1 + ( 1 + x ) ** 3 + 5 * 6 * x ** 2 - x * 3</code><code>( x * x * 3 * x ) ** 2 * x</code> <code>-3 * (x)</code><code>(x + 1)*(x + 2)</code> <code>-01 *x -     (-01*x )</code><code>+- +1+-(1+2)**1 * -1</code><code>+- -1 + -( 1 * x ** 2 + 1 ) ** +0 * -1</code><code>+- +1+-(1+2)**0 * -1</code><code>-+ +1 + -(-x*x**000*x**+03*-0010)**+002*-01</code><code>-(x-1)*(x-2)**+2*-1 + 10*x**4</code><code>-0*x**4*x**3*(1+2*3)-+x**2*3+0012*+0000*(x**+1*3)</code><code>-0*x**4*x**3*(1+2*3)-+x**2*3*+0012*+0000*(x**+1*3)</code><code>-0*x**4*x**3*(++0005423333333*0005423333333*x**0*x**0*x**+0+-x**+0*-0001*6++9223854775807*2333333323334666*x**0*x**0+-002147483647)-+x**2*3*+0012*+0000*(x**+1*3)</code><code>-0*x**4*x**3*(++0005*x**0*x**0*x**+0+-x**+0*-0001*6++9*2*x**0*x**0+-0021)-+x**2*3*+0012*+0000*(x**+1*3)</code><code>+- -1 + -( 1 * x ** 2 + x * -x * -x ) ** +0 * -02 + - +x ** 3</code><code>31*x +17*x   +-71-x   ** +3*+975-x ** 3--815-x  ** 3*+2+x ** +0+9-x  ** +1*-623-x   +268-x +33*x   ** +3+8+x  *+27-x  ** 3*+869+x  ** 0*+2*x   ** 1--492*x  ** +3--218+x ** +3*+19*x ** 3+21*x   ** 2-+7+x   *+58*x  *-456</code><code>31*x +17*x   +-71-x   ** +3*+975-x ** 3--815-x  ** 3*+2+x ** +0+9-x  ** +1*-623-x</code><code>-815-x  ** 3*+2+x ** +0+9</code><code>x -x ** 3-(x  *x )**2*(x ** 6*-+44)**+2+(x  ** 1*x   +x -x   *03462*6024189)**+1-x  ** 6*9463+(+-192766*x -x ** 2*x ** 5)**+2+(x   *--503394-++5767007832)**+2+-6145918*x</code></p><h5 id="变成">**变成*</h5><p>运用了大量程设的技巧和debug的技巧和眼睛。</p><p>在这里我们需要知道的是：对谁求n次方，n是多少。方法即检测是否有连续出现的*，如果是连续出现的，由于题目限制，这里有两种情况：一，前面是x，这是幂函数；二，前面是个括号，需要拆开。所以还需要两个“指针”，在循环中不断记录最新的左括号和右括号位置，这里也是由于题目限制，只有一层括号所以可以这么做（言下之意，没有可扩展性）。等一路循环到**这里，两个“指针”记录的就是最后面的括号了。</p><p>好，现在分析出了需要n次方的对象，那么我们要把这个对象取出来。这很好办，要么是x，要么是整个括号。然后把这个子串拼到生成的串后面，两两之间添加*号即可。</p><p>n的求法更加简便，由于前面可能存在一个符号，故先把符号判断掉，如果没有符号就while(Character.isdigit(c))循环下去，和快读的样子差不多。当然，这道题里限制了符号只能是+，位数也不可能超过1，所以可以有适当的省略。</p><p>其中要注意的就是这个记录当前判断位置的“指针”来回跳转的位置，特别是需要跳过后面的n次方的数字，精准的抵达下一个处理的字符处。还有就是0次方1次方这种恼人的东西。</p><p>所以在我的实现中，我每次都在StringBuilder后面append字符，如果遇到各种次方，就把刚刚append上去的需要次方的子串删掉，再按数量拼接上去。</p><p>麻烦。</p><h3 id="思路总结">思路总结</h3><p>整个过程中，我需要做的就是计算表达式。</p><p>表达式有三种，一种是只有加法的，一种是又有加法又有乘法的，另一种是套着括号的。套着括号的又有两种，一种是只有加法的，一种是又有加法又有乘法的。所以在这里，我们发现了一个loop：表达式-&gt; 项 -&gt; 带括号的表达式 -&gt; 表达式 -&gt; ···</p><p>于是我们采用这样一个方法：递归下降，从整体的表达式开始，一点点下降到项，再到因子。</p><p>具体过程如下：</p><ol type="1"><li>表达式层：目标是全部变成加法，获得所有项的和。所以如果发现了+号，则往表达式内添加项；否则去往项层。</li><li>项层：目标是全部变成乘法，获得所有因子的乘积。所以如果发现了*号，则往项内添加因子；否则去往括号/因子层。</li><li>括号/因子层：括号即另一个表达式，同样需要进行加法操作。所以如果发现了(，则去往表达式层，如果是因子则直接返回因子对象，回退至项层，直至项层计算完毕，回退至表达式层，直至表达式计算完毕，输出结果。</li></ol><p>全程我均采用一个多项式（polynomial）对象进行运算，因子也是它，项也是它，表达式也是它。其中的属性是一个hashmap，key为指数，value为系数，边计算边合并即可。</p><p>uml图：</p><img src="03/05/oo-HW1/image-20220305125229596.png" class title="image-20220305125229596"><p>由此可见这并不面向对象，这个poly或许应该按一个接口实现。</p><p>代码行数：</p><img src="03/05/oo-HW1/image-20220305125100485.png" class title="image-20220305125100485"><h3 id="问题合集">问题合集</h3><h4 id="好巧不巧">1 好巧不巧</h4><p>背景：分割字符串。我们需要判断是否是空格或者是制表符，ascii码分别为32和9。于是让我想起了正则表达式里的，可以实现匹配**16进制**转义码。然后我就直接把\x32\x09写进去了，得亏还注意了一下这个位数必须为两位的问题，但忽略了这俩应该转换成16进制再写到。我测试的用例是2 + x * x，按理说极为简单，结果得到的结果是：<img src="03/05/oo-HW1/image-20220301235203879.png" class title="image-20220301235203879">百思不得其解，为什么能分出这么奇怪的模样。直到我发现16进制，而因为过分巧合，0x32正好是数字2。只能说运气好也是一种实力。一种和wa还有2相伴相生的实力。</p><h4 id="各种zero-input">2 各种Zero Input</h4><p>大概是输入的时候出了问题，这种情况重跑一遍一般能解决。如果重跑解决不了就是处理出问题了。输出的时候注意不能先打一对儿括号上去，这样再回退到括号中间也没法输入了，有时候输入字符也是，目前还未发现其中缘故。</p><h4 id="以为是乱码的输出">3 以为是乱码的输出</h4><p>我以为我System.out.println搜全了，结果还漏掉了一个，同时我还忘记了我曾经写过这样一个测试输出，于是出现了我以为我打印的测试数据是乱码的情况。针对这个打印的测试数据，我又打印了大量其他的测试数据去定位其产生的地点……总之是测试数据随用随建随弃随删。</p><h3 id="测试">测试</h3><h4 id="生成数据">生成数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> xeger <span class="keyword">import</span> Xeger</span><br><span class="line"></span><br><span class="line">powFun = <span class="string">&#x27;x( )&#123;1,3&#125;(\*\* \+?[0-3])?&#x27;</span></span><br><span class="line">const = <span class="string">&#x27;(\+|-)?[1-9]&#123;1,3&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">_x = Xeger(limit=<span class="number">20</span>)</span><br><span class="line">_x._alphabets[<span class="string">&#x27;whitespace&#x27;</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createPow</span>():</span></span><br><span class="line">    testStr = _x.xeger(powFun)</span><br><span class="line">    <span class="keyword">return</span> testStr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createConst</span>():</span></span><br><span class="line">    testStr = <span class="string">&quot;&quot;</span></span><br><span class="line">    a = random.randint(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">2</span>:</span><br><span class="line">        testStr += <span class="string">&quot;+&quot;</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">3</span>:</span><br><span class="line">        testStr += <span class="string">&quot;-&quot;</span></span><br><span class="line">    testStr += _x.xeger(const)</span><br><span class="line">    <span class="keyword">return</span> testStr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createSign</span>():</span></span><br><span class="line">    testStr = _x.xeger(<span class="string">&#x27;[-+*]&#123;1&#125;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> testStr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createParentheses</span>():</span></span><br><span class="line">    testStr = <span class="string">&quot;(&quot;</span></span><br><span class="line">    a = random.randint(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, a):</span><br><span class="line">        b = random.randint(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">1</span>:</span><br><span class="line">            testStr += createConst() + createSign()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            testStr += createPow() + createSign()</span><br><span class="line">    b = random.randint(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">1</span>:</span><br><span class="line">        testStr += createConst()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        testStr += createPow()</span><br><span class="line">    testStr += <span class="string">&quot;)&quot;</span></span><br><span class="line">    <span class="keyword">return</span> testStr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createParenWithPow</span>():</span></span><br><span class="line">    testStr = createParentheses()</span><br><span class="line">    testStr += <span class="string">&quot;**&quot;</span></span><br><span class="line">    b = random.randint(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    a = random.randint(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>):</span><br><span class="line">        testStr += <span class="string">&quot;+&quot;</span></span><br><span class="line">    testStr += <span class="built_in">str</span>(b)</span><br><span class="line">    <span class="keyword">return</span> testStr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createInput</span>():</span></span><br><span class="line">    <span class="built_in">input</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">        b = random.randint(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">input</span> += createConst() + createSign()</span><br><span class="line">        <span class="keyword">elif</span> b == <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">input</span> += createPow() + createSign()</span><br><span class="line">        <span class="keyword">elif</span> b == <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">input</span> += createParentheses() + createSign()</span><br><span class="line">        <span class="keyword">elif</span> b == <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">input</span> += createParenWithPow() + createSign()</span><br><span class="line">    b = random.randint(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">input</span> += createConst()</span><br><span class="line">    <span class="keyword">elif</span> b == <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">input</span> += createPow()</span><br><span class="line">    <span class="keyword">elif</span> b == <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">input</span> += createParentheses()</span><br><span class="line">    <span class="keyword">elif</span> b == <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">input</span> += createParenWithPow()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">input</span></span><br><span class="line"></span><br><span class="line">x = sympy.Symbol(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkAns</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(f)</span><br><span class="line">    <span class="built_in">print</span>(sympy.apart(f))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Press the green button in the gutter to run the script.</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    f = createInput()</span><br><span class="line">    checkAns(f)</span><br></pre></td></tr></table></figure><p>大概是利用了xeger包中可以根据正则表达式随机生成对应表达式的工具，以及sympy中可以负责检查/化简公式的方法。</p><p>当然，如果这里存在各种数据上的限制，比如不能超过8次方，乘号后面不能有两个符号一类，单独再写一个函数判断一下即可，不满足则重新生成。</p><h4 id="在python中调用jar包评测姬">在python中调用jar包（评测姬）</h4><h5 id="打jar包">打jar包</h5><img src="03/05/oo-HW1/image-20220304192220223.png" class title="image-20220304192220223"><p>所有设置完毕后，在顶栏选择build，点击build artifact - build即可。</p><h5 id="python调用jar包">python调用jar包</h5><p>运行jar：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jarDir = <span class="string">&quot;D:\\...\\xxx.jar&quot;</span></span><br><span class="line">process = subprocess.Popen([<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;-jar&#x27;</span>, jarDir], stdin=PIPE, stdout=PIPE, stderr=PIPE)</span><br></pre></td></tr></table></figure><p>输入并获得输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stdout, stderr = process.communicate(strInput.encode())</span><br></pre></td></tr></table></figure><p>由于这样得到的stdout只能输出一行，即，所以在取用结果的时候，可能需要进行如下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret = []</span><br><span class="line">ret += stdout.decode().split(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里专门说明的原因是stdout必须先decode才能从byte类型变成str类型，反之则需要encode，如上面的输入<code>strInput.encode()</code>。</p><p>综上，我获得了第一份自己的评测姬！可以运行随机无前导零的数据并检验结果是否正确！而且，我还开发了一个对拍机器，可以对拍有前导零的数据，但只能检验对拍案例结果是否相同，不能检验正确性。</p><p>同时，如果使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process = subprocess.Popen(parserStudentWin64Dir, stdin=PIPE, stdout=PIPE, stderr=PIPE)</span><br><span class="line">stdout, stderr = process.communicate(strInput.encode())</span><br><span class="line">process.kill()</span><br></pre></td></tr></table></figure><p>则可以给那些使用了预解析读入的代码跑测试，即第一行运行的是exe文件，Popen里第一个参数即exe文件的位置，得到的stdout可以直接作为下一次communicate的输入，不需要解码什么的。</p><p>这里还遇见了一个问题，就是当我这样创建进程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process = subprocess.Popen(<span class="string">&#x27;.\\&#x27;</span> + parserStudentWin64Dir, stdin=PIPE, stdout=PIPE, stderr=PIPE)</span><br></pre></td></tr></table></figure><p>程序曾经会报错，但刚刚试了一下，发现又不报错了。那大概也是可以的。不过，在cmd中运行exe的方法就是<code>.\program.exe</code>。</p><p>但是这样的评测姬效果并不明显，自己的bug没有被跑出来，别人的bug跑出来的比读代码慢得多，而且概率实在是太小了。所以若非明显错误或者比较常出现的错误，这样随机的方法并不显优势，而且费电脑，费风扇，在冬天倒是可以提供不少热量。</p><h3 id="圣杯战争">圣杯战争！</h3><p>给别人打jar包并进行一些对拍。<code>x ** 0*(x   ** 0--417702543406398448-x  ** 1*x ** 1)**+3*x ** 1+831665958992627115213+x   ** 3</code>这个数据没过，但是它太大了的原因。改一改：<code>x ** 0*(x   ** 0--4-x  ** 1)**+3*x ** 1+8+x   ** 3</code>然后他就过了。不开心。然后我才发现，这个数据点hack掉的是我的小可爱，因为我忘了换被测对象jar包地址了。尴尬。<code>x   +(--0984844291422941213129++82476120931311782645690*+097535345144523392575)**3-736876427782337378+(x   ** +6+x  ** 4++086793587927239992302-x  *-06851424254908447276)**2+x</code>这个也是，太大了。<code>- +(-+8247*+09753)**3-7+(x   ** +3+x  ** 4++08-x  *-08)**2</code>一样，还是由于第一位同志不处理次数大于8导致的。还有两位同志不处理*后面两个符号的，所以我这个测试程序跑一点就断，再跑一点又断。最后忍无可忍，打了个补丁，把这群人没处理的问题屏蔽了。</p><p>但现在的问题是电脑风扇要起飞了！</p><p>不过之前手动测试hack了一个人（希望我还能有好报）。不过这个低级错误居然没被测出来，有点震惊，所以果然我在C房吗…</p><p>大概是这样的，我本来想看看有没有人会爆栈，然后：<code>(x+x+x+x+x+x+x+x+x+x+x+x+x+x+x+x+x+x+x+x+x+x+x)**8</code><code>(x+x)**8+(x+x)**8+(x+x)**8+(x+x)**8+(x+x)**8</code>结果发现没有人爆栈。真是令人伤心哈哈哈哈。然后我发现第二条后面还能加点东西：<code>(x+x)**8+(x+x)**8+(x+x)**8+(x+x)**8+(x+x)**8+-x</code>于是代码就跑不动了。后来发现，原来是一位同志的输出符号出现了消失的症状，于是简化样例：<img src="03/05/oo-HW1/image-20220306124313214.png" class></p><p>诶嘿，小心输出错误哦~</p><p>然后我被攻击了。</p><p>现在房里有三个人都被攻击了。真好。</p><p>通过读代码的方式干掉了一个---1的bug。现在hack两次被hack两次。</p><p>被hack数据： <code>5 * ( - + -01 + 7)</code><code>(--+2*x-x**+2*x*2)**2*2*2</code>究其原因，就是左括号后面的加减号没有处理，再带上一个前导零就遇到问题了。大概2k组随机都没有跑出来，可见这种bug存在的应该不少，所以建议下次重构的时候换成正则表达式，直接replaceAll，莫使用程设方法了，太易错了。</p><p>最后的结局： <img src="03/05/oo-HW1/image-20220307142938054.png" class title="image-20220307142938054"></p><h3 id="课上讲解">课上讲解</h3><h4 id="类">类</h4><p>主控类：创建输入输出的对象和管理对象的对象 协控类 对象类</p><h4 id="属性与方法的设计">属性与方法的设计</h4><h5 id="属性">属性</h5><p>依从性问题：逻辑 + 计算效率</p><h5 id="方法-1">方法</h5><p>构造方法 对象生成方法 状态查询方法 状态改变方法</p><h3 id="附录">附录</h3><p>最后，一个比较孤陋寡闻的人需要记录一下每个人名都是什么意思，免得以后又忘记了。Saber：剑士 Lancer：枪兵 Archer：弓兵 Rider：骑兵 Caster：魔术师Assassin：暗杀者 Berserker：狂战士 Alterego：从者的英灵</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记2</title>
      <link href="/2022/02/26/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
      <url>/2022/02/26/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h4 id="设计模式">设计模式</h4><h5 id="工厂模式">工厂模式</h5><p>我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><ul><li>意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</li><li>主要解决：主要解决接口选择的问题。</li><li>何时使用：我们明确地计划不同条件下创建不同实例时。</li><li>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</li><li>关键代码：创建过程在其子类执行。</li><li>应用实例：1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。2、Hibernate 换数据库只需换方言和驱动就可以。</li><li>优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。3、屏蔽产品的具体实现，调用者只关心产品的接口。</li><li>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</li></ul><h5 id="抽象工厂模式">抽象工厂模式</h5><p>围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><h4 id="继承">继承</h4><p>继承就是定义子类继承父类的特征和行为，使得子类可以拥有父类的属性和方法，从而起到代码复用的目的。</p><h4 id="向上转型up-cast">向上转型（up cast）</h4><p>在建立了继承关系之后，可以使用父类型去引用通过子类型创建的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类 名称 = <span class="keyword">new</span> 子类();</span><br></pre></td></tr></table></figure><p>但是，此时这个对象所用的方法还是父类中的方法。即父类型引用不能直接调用子类型对象特有的方法。</p><h4 id="向下转型down-cast">向下转型（down cast）</h4><p>Java 语言提供了一个特殊的关键词 instanceof用来判断一个对象引用所指向的对象的创建类型是否为特定的某个类，一般写为obj instanceof A，其中 obj 为一个对象引用，A为一个类型（类或接口），这个表达式的取值结果为布尔型，如果 obj的创建类型为 A，则结果为 true，否则为 false。</p><p>此时可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(对象引用 <span class="keyword">instanceof</span> 类型) &#123;</span><br><span class="line">类型 名称 = (类型)对象引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个错误">一个错误</h4><p>记得对象随用随建！！！！如果在if外面定义，共用同一个对象，可能出现第二个覆盖第一个的情况…总之会有错，请随用随建！</p><h4 id="重新">重新</h4><p>让子类重新实现一个在父类中已经实现的方法是面向对象的一个重要机制，称为方法重写。</p><h4 id="多态">多态</h4><p>引用类型相同，但创建类型不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引用类型 名称<span class="number">1</span> = <span class="keyword">new</span> 创建类型<span class="number">1</span>();</span><br><span class="line">引用类型 名称<span class="number">2</span> = <span class="keyword">new</span> 创建类型<span class="number">2</span>();</span><br></pre></td></tr></table></figure><h4 id="自定义排序">自定义排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 待排序的类名 <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;待排序的类名&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span> 待排序的类名(参数) &#123;</span><br><span class="line"><span class="keyword">this</span>.参数 = 参数;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> 待排序的对象(参数) &#123;</span><br><span class="line"><span class="keyword">return</span> 待排序的对象;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(待排序的类名 对象名)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.待排序的对象 &lt; 对象名) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">// this &lt; 对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.待排序的对象 &gt; 对象名) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line">Collections.sort(序列名称);</span><br></pre></td></tr></table></figure><hr><!--从这里开始，丢了很多内容。--><!--歪三已经记不得了，只记得有几段写的还挺不错。--><!--可一般不都是这样吗，一些不经意间的闪光出现在了错误的地点。--><!--只能狠自己喜欢保存吧。--><!--不想回忆了，当时明明记录了对于抽象类经实践后的突然醍醐灌顶的理解，现在呢，烟消云散了。--><!--真好。--><hr><h4 id="一个小问题">一个小问题</h4><p>如果想在多个方法中都用到scanner去读入，若每次都重新实例化一个scanner则它们会拒绝读入然后卡死在那里。所以可以采取如下方式解决：把scanner的实例化扔到主类里面主程序入口的外面，也就是如下的样子，并变成public，其他地方调用Main.scanner即可使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象类和接口">抽象类和接口</h4><h5 id="抽象类">抽象类</h5><p>那天我遇到了一个问题，发现我需要在父类中定义一个方法，因为他的儿子们要用。</p><p>但是，在父类面前，我却一点也写不出来，只好撂了一个空壳子在哪儿，等着子类重写。这种情况就是所谓，“父类抽象程度很高，以至于在父类中没有办法去编写一个实现具体功能的方法。”</p><p>所以这么看起来，留个空壳等后人来填，也是可行之举。</p><h5 id="接口">接口</h5><p>但是抽象类的限制有很多。比如这个方法只能存在于父类和他们的儿子中，别的类想要用就属于是痴心妄想了，或者这么说，“那么你就会触霉头了”。接口很大程度上放宽了这种限制，因此，我们可以写出可复用性更好的代码。</p><p>在编程的时候，接口和类创建文件的方式是一样的，每个接口都需要一个独立的.java文件，idea会很贴心的给你标出一个绿色带有“I"字的logo以示区别。哪里用，哪里implements即可。</p><p>接口可以作为引用类型，不可以作为创建类型。也就是说，你不能用接口类型来实例化一个对象，因为这样实例化的行为的概念过于抽象以至于实例化没有意义。</p><h4 id="一个大改进">一个大改进</h4><p>曾经，我的代码极度冗长，因为未能好好理解多态的概念。</p><p>每种装备都要单独建立一个序列，因为在我的眼里，类型不同的对象不能扔到一起去呀，那样怎么处理啊。</p><p>但是转念一想，你个蒟蒻，你管他是什么类的，他们都是equipment类下的小子，统一管理就可以了，反正它都调用的是子类重写的方法，它是什么类型，不需要我操心。</p><p>你看，这就是多态啊。</p><h4 id="面向抽象编程">面向抽象编程</h4><p>我向往自由，我要学面向抽象编程！我真是，我要被象抽死了！</p><h4 id="java类型表示范围">java类型表示范围</h4><p>int：32位，-2,147,483,648（-2^31）到 2,147,483,647（2^31 - 1）long：64位，-9,223,372,036,854,775,808（-2^63）到9,223,372,036,854,775,807（2^63 -1） 不够用的时候一定要换BigInteger！要不然就可以享受debug一天的快乐了hhh</p><hr><!--终于，补完了印象中的大部分内容。--><!--累了，洗洗睡吧！--><hr><h4 id="正则表达式">正则表达式</h4><p>jsonString.split方法，可以根据给定的分隔符来将字符串分割为若干个字符串；jsonString.indexOf方法，可以在给定的字符串中搜索给定字符串出现的位置；jsonString.substring方法，可以按照下表位置区间来从给定字符串截取子字符串;然后真正关于正则表达式的部分，教程里可谓是春秋笔法呢。</p><p>所以我们求助菜鸟教程——</p><table><colgroup><col style="width: 17%"><col style="width: 82%"></colgroup><thead><tr class="header"><th>字符</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>\</td><td>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，<strong>n</strong>匹配字符 <strong>n</strong>。<strong>*匹配换行符。序列 </strong>\\** 匹配 <strong>\</strong>，<strong>\(</strong> 匹配 <strong>(</strong>。</td></tr><tr class="even"><td>^</td><td>匹配输入字符串开始的位置。如果设置了 <strong>RegExp</strong> 对象的<strong>Multiline</strong> 属性，^ 还会与""或"之后的位置匹配。</td></tr><tr class="odd"><td>$</td><td>匹配输入字符串结尾的位置。如果设置了 <strong>RegExp</strong> 对象的<strong>Multiline</strong> 属性，$ 还会与""或"之前的位置匹配。</td></tr><tr class="even"><td>*</td><td>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配"z"和"zoo"。*等效于 {0,}。</td></tr><tr class="odd"><td>+</td><td>一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+等效于 {1,}。</td></tr><tr class="even"><td>?</td><td>零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。?等效于 {0,1}。</td></tr><tr class="odd"><td>{<em>n</em>}</td><td><em>n</em> 是非负整数。正好匹配 <em>n</em>次。例如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配。</td></tr><tr class="even"><td>{<em>n</em>,}</td><td><em>n</em> 是非负整数。至少匹配 <em>n</em>次。例如，"o{2,}"不匹配"Bob"中的"o"，而匹配"foooood"中的所有o。"o{1,}"等效于"o+"。"o{0,}"等效于"o*"。</td></tr><tr class="odd"><td>{<em>n</em>,<em>m</em>}</td><td><em>m</em> 和 <em>n</em> 是非负整数，其中 <em>n</em> &lt;=<em>m</em>。匹配至少 <em>n</em> 次，至多 <em>m</em>次。例如，"o{1,3}"匹配"fooooood"中的头三个 o。'o{0,1}' 等效于'o?'。注意：您不能将空格插入逗号和数字之间。</td></tr><tr class="even"><td>?</td><td>当此字符紧随任何其他限定符（<em>、+、?、{</em>n<em>}、{</em>n<em>,}、{</em>n<em>,</em>m*}）之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"。</td></tr><tr class="odd"><td>.</td><td>匹配除""之外的任何单个字符。若要匹配包括""在内的任意字符，请使用诸如"[]"之类的模式。</td></tr><tr class="even"><td>(<em>pattern</em>)</td><td>匹配 <em>pattern</em> 并捕获该匹配的子表达式。可以使用<strong>$0…$9</strong>属性从结果"匹配"集合中检索捕获的匹配。若要匹配括号字符 ()，请使用"("或者")"。</td></tr><tr class="odd"><td>(?:<em>pattern</em>)</td><td>匹配 <em>pattern</em>但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or"字符(|) 组合模式部件的情况很有用。例如，'industr(?:y|ies) 是比'industry|industries' 更经济的表达式。</td></tr><tr class="even"><td>(?=<em>pattern</em>)</td><td>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配<em>pattern</em>的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows(?=95|98|NT|2000)' 匹配"Windows 2000"中的"Windows"，但不匹配"Windows3.1"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr><tr class="odd"><td>(?!<em>pattern</em>)</td><td>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配<em>pattern</em>的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows(?!95|98|NT|2000)' 匹配"Windows 3.1"中的 "Windows"，但不匹配"Windows2000"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr><tr class="even"><td><em>x</em>|<em>y</em></td><td>匹配 <em>x</em> 或 <em>y</em>。例如，'z|food'匹配"z"或"food"。'(z|f)ood' 匹配"zood"或"food"。</td></tr><tr class="odd"><td>[<em>xyz</em>]</td><td>字符集。匹配包含的任一字符。例如，"[abc]"匹配"plain"中的"a"。</td></tr><tr class="even"><td>[^*xyz*]</td><td>反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。</td></tr><tr class="odd"><td>[<em>a-z</em>]</td><td>字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。</td></tr><tr class="even"><td>[^*a-z*]</td><td>反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。</td></tr><tr class="odd"><td>匹配一个字边界，即字与空格间的位置。例如，"er匹配"never"中的"er"，但不匹配"verb"中的"er"。</td><td></td></tr><tr class="even"><td></td><td>非字边界匹配。"er"匹配"verb"中的"er"，但不匹配"never"中的"er"。</td></tr><tr class="odd"><td>*</td><td>匹配 <em>x</em> 指示的控制字符。例如，匹配 Control-M或回车符。<em>x</em> 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c就是"c"字符本身。</td></tr><tr class="even"><td> 数字字符匹配。等效于 [0-9]。</td><td></td></tr><tr class="odd"><td></td><td>非数字字符匹配。等效于 [^0-9]。</td></tr><tr class="even"><td> 换页符匹配。等效于 0c 和 。</td><td></td></tr><tr class="odd"><td></td><td>换行符匹配。等效于 0a 和 。</td></tr><tr class="even"><td> 匹配一个回车符。等效于 0d 和 。</td><td></td></tr><tr class="odd"><td></td><td>匹配任何空白字符，包括空格、制表符、换页符等。与 [ 等效。</td></tr><tr class="even"><td></td><td>匹配任何非空白字符。与 [^ 等效。</td></tr><tr class="odd"><td> 制表符匹配。与 和 等效。</td><td></td></tr><tr class="even"><td> 垂直制表符匹配。与 0b 和 等效。</td><td></td></tr><tr class="odd"><td></td><td>匹配任何字类字符，包括下划线。与"[A-Za-z0-9_]"等效。</td></tr><tr class="even"><td></td><td>与任何非单词字符匹配。与"[^A-Za-z0-9_]"等效。</td></tr><tr class="odd"><td>n*</td><td>匹配 <em>n</em>，此处的 <em>n</em>是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，""匹配"A"。""与""&amp;"1"等效。允许在正则表达式中使用ASCII 代码。</td></tr><tr class="even"><td>*num*</td><td>匹配 <em>num</em>，此处的 <em>num</em>是一个正整数。到捕获匹配的反向引用。例如，"(.)\1"匹配两个连续的相同字符。</td></tr><tr class="odd"><td>*n*</td><td>标识一个八进制转义码或反向引用。如果 *n* 前面至少有 <em>n</em>个捕获子表达式，那么 <em>n</em> 是反向引用。否则，如果 <em>n</em>是八进制数 (0-7)，那么 <em>n</em> 是八进制转义码。</td></tr><tr class="even"><td>*nm*</td><td>标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 <em>nm</em>个捕获子表达式，那么 <em>nm</em> 是反向引用。如果 *nm* 前面至少有<em>n</em> 个捕获，则 <em>n</em> 是反向引用，后面跟有字符<em>m</em>。如果两种前面的情况都不存在，则 *nm* 匹配八进制值<em>nm</em>，其中 <em>n</em> 和 <em>m</em> 是八进制数字 (0-7)。</td></tr><tr class="odd"><td></td><td>当 <em>n</em> 是八进制数 (0-3)，<em>m</em> 和 <em>l</em> 是八进制数(0-7) 时，匹配八进制转义码 <em>nml</em>。</td></tr><tr class="even"><td>*</td><td>匹配 <em>n</em>，其中 <em>n</em> 是以四位十六进制数表示的 Unicode字符。例如，0A9 匹配版权符号 (©)。</td></tr></tbody></table><p>匹配使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String content = <span class="string">&quot;I am noob &quot;</span> +  <span class="string">&quot;from runoob.com.&quot;</span>;</span><br><span class="line"> </span><br><span class="line">String pattern = <span class="string">&quot;.*runoob.*&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isMatch = Pattern.matches(pattern, content);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串中是否包含了 &#x27;runoob&#x27; 子字符串? &quot;</span> + isMatch);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>更厉害的一种操作叫：</p><h5 id="捕获组">捕获组</h5><h6 id="普通捕获组">普通捕获组</h6><p>从正则表达式左侧开始，每出现一个左括号"("记做一个分组，分组编号从 1开始。0 代表整个表达式。</p><p>例子如下：对于时间字符串：2017-04-25，表达式：<strong>(\d{4})-((\d{2})-(\d{2}))</strong>有 4 个左括号，所以有 4 个分组:</p><table><thead><tr class="header"><th>编号</th><th>捕获组</th><th>匹配</th></tr></thead><tbody><tr class="odd"><td>0</td><td>()-(()-())</td><td>2017-04-25</td></tr><tr class="even"><td>1</td><td>()</td><td>2017</td></tr><tr class="odd"><td>2</td><td>(()-())</td><td>04-25</td></tr><tr class="even"><td>3</td><td>()</td><td>04</td></tr><tr class="odd"><td>4</td><td>()</td><td>25</td></tr></tbody></table><h6 id="命名捕获组">命名捕获组</h6><p>每个以左括号开始的捕获组，都紧跟着<strong>?</strong>，而后才是正则表达式。</p><p>例子如下：</p><p>对于时间字符串：2017-04-25，表达式如下：<strong>(?&lt;year&gt;\d{4})-(?&lt;md&gt;(?&lt;month&gt;\d{2})-(?&lt;date&gt;\d{2}))</strong></p><p>有 4 个命名的捕获组，分别是:</p><table><thead><tr class="header"><th style="text-align: left;">编号</th><th style="text-align: left;">名称</th><th style="text-align: left;">捕获组</th><th style="text-align: left;">匹配</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0</td><td style="text-align: left;">0</td><td style="text-align: left;">(?)-(?(?)-(?))</td><td style="text-align: left;">2017-04-25</td></tr><tr class="even"><td style="text-align: left;">1</td><td style="text-align: left;">year</td><td style="text-align: left;">(?)-</td><td style="text-align: left;">2017</td></tr><tr class="odd"><td style="text-align: left;">2</td><td style="text-align: left;">md</td><td style="text-align: left;">(?(?)-(?))</td><td style="text-align: left;">04-25</td></tr><tr class="even"><td style="text-align: left;">3</td><td style="text-align: left;">month</td><td style="text-align: left;">(?)</td><td style="text-align: left;">04</td></tr><tr class="odd"><td style="text-align: left;">4</td><td style="text-align: left;">date</td><td style="text-align: left;">(?)</td><td style="text-align: left;">25</td></tr></tbody></table><p>使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按指定模式在字符串查找</span></span><br><span class="line">String line = <span class="string">&quot;This order was placed for QT3000! OK?&quot;</span>;</span><br><span class="line">String pattern = <span class="string">&quot;(\\D*)(\\d+)(.*)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Pattern 对象</span></span><br><span class="line">Pattern r = Pattern.compile(pattern);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在创建 matcher 对象</span></span><br><span class="line">Matcher m = r.matcher(line);</span><br><span class="line"><span class="keyword">if</span> (m.find( )) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Found value: &quot;</span> + m.group(<span class="number">0</span>) );</span><br><span class="line">    System.out.println(<span class="string">&quot;Found value: &quot;</span> + m.group(<span class="number">1</span>) );</span><br><span class="line">    System.out.println(<span class="string">&quot;Found value: &quot;</span> + m.group(<span class="number">2</span>) );</span><br><span class="line">    System.out.println(<span class="string">&quot;Found value: &quot;</span> + m.group(<span class="number">3</span>) ); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;NO MATCH&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Found value: This order was placed for QT3000! OK?</span></span><br><span class="line"><span class="comment">    Found value: This order was placed for QT</span></span><br><span class="line"><span class="comment">    Found value: 3000</span></span><br><span class="line"><span class="comment">    Found value: ! OK?</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h6 id="非捕获组">非捕获组</h6><p>在左括号后紧跟<strong>?:</strong>，而后再加上正则表达式，构成非捕获组<strong>(?:Expression)</strong>。</p><p>对于时间字符串：2017-04-25，表达式如下：(?:\d{4})-((\d{2})-(\d{2}))</p><p>这个正则表达式虽然有四个左括号，理论上有 4 个捕获组。但是第一组<strong>(?:)</strong>，其实是被忽略的。当使用 matcher.group(4)时，系统会报错。</p><h4 id="非贪婪匹配">非贪婪匹配</h4><table><thead><tr class="header"><th>代码</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>*？</td><td>重复任意次，但尽可能少重复</td></tr><tr class="even"><td>+？</td><td>重复1次或更多次，但尽可能少重复</td></tr><tr class="odd"><td>？？</td><td>重复0次或1次，但尽可能少重复</td></tr><tr class="even"><td>{n,m}?</td><td>重复n到m次，但尽可能少重复</td></tr><tr class="odd"><td>{n,}?</td><td>重复n次以上，但尽可能少重复</td></tr></tbody></table><h4 id="一些小说明">一些小说明</h4><p>首先，正则表达式的调试：https://c.runoob.com/front-end/854/用在线的测试工具来debug，会比本地瞪眼瞅/先大量删除然后慢慢加回去的方法有效一些。但是，这个方法并不靠谱……即使是直接用它的导出代码也不靠谱。而且注意右边的修饰符下拉菜单，有时候需要用多行模式！这里总结一个小经验，如果不是用捕获组之类而是直接匹配，记得给pattern串加上严格的开始喝结尾限制！</p><p>例子，我们现在要匹配当前的句子里是否有这样的前缀存在，于是我们应该使用：**<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>{2,3}[b]{2,4}[c]{2,4}.*$**这样的pattern来处理。</p><p>一开始，蒟蒻是这样理解正则表达式的，即带匹配串里面包含这个pattern部分就可以被识别出来。所以当时本人使用的是<strong><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>{2,3}[b]{2,4}[c]{2,4}</strong>，区别在于这个只限制了开头的样子，没有关心结尾在哪里，是什么样的。结果就是，遇到如aaabbbcca这样中间存在空格的字符串，就无法匹配到。</p><p>但是，与之对应的，在捕获组的时候我就完全没有考虑这个开头结尾的约束问题…但，蒟蒻个人猜测，应该是空格惹的祸，这个，上次就是因为打成大写了结果意思完全反了过来，这次又整这出，真实不省心。真正的原因还未确定。所以这里暂时挂起，待我慢慢解决。</p><p>补充一下另一种匹配方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATTERN = <span class="string">&quot;^.*a.*a.*b.*b.*b.*b.*b.*c.*c.*$&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> Pattern pattern = Pattern.compile(PATTERN);</span><br><span class="line"></span><br><span class="line">String content = <span class="string">&quot;&quot;</span>;<span class="comment">// 待匹配的串</span></span><br><span class="line"><span class="keyword">boolean</span> isMatch = (patternA4.matcher(content).matches() ? <span class="number">1</span> : <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="再遇小问题">再遇小问题</h4><p>打开gitlab上提供的代码，结果告诉我抽象类不能access。解决方法：invalid cache，重启，好了。所以当你确定没有实现上的问题的时候，重启IDEA可解决大部分问题。</p><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>a<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>a<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记</title>
      <link href="/2022/02/18/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/18/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>matlab学习笔记</p><h1 id="一-基础知识">一 基础知识</h1><h3 id="常用数学函数">常用数学函数</h3><ul><li><p>sin如果是角度用sind</p><ul><li>如sin(pi/2) = sind(90)</li></ul></li><li><p>abs可用来求实数的绝对值、复数的模、字符串的ASCII码值</p></li><li><p>取整</p><ul><li>round：四舍五入</li><li>ceil：向上</li><li>floor：向下</li><li>fix：舍去小数取整</li></ul></li><li><p>%： rem(x, y)</p></li><li><p>isprime(x)</p></li><li><p>标准函数名都是小写</p></li><li><p>区分大小写</p></li><li><p>预定义变量</p><ul><li>ans：默认复制变量</li><li>NaN：画图时用于裁剪</li><li>i和j：复数（注意！循环变量避让！）</li><li>pi</li></ul></li><li><p>变量的删除修改</p><ul><li><p>工作区改</p></li><li><p>who</p></li><li><p>whos</p></li><li><p>.mat</p><ul><li>保存工作区变量的文件</li><li>使用save和load命令</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save mydata a x// a和x两个变量装入madata.mat中</span><br><span class="line">load mydata// 从mydata.mat中取出变量</span><br></pre></td></tr></table></figure></li></ul></li><li><p>输出格式</p><ul><li>用format来定义</li><li>目前已知rat是有理数</li></ul></li></ul><h3 id="矩阵运算">矩阵运算</h3><ul><li><strong>事实证明，下标从1开始</strong></li><li>冒号表达式：<ul><li>初始值:步长:终止值</li><li>步长可省，忽略为1，此时只有一个冒号</li></ul></li><li>linspace(第一个元素, 最后一个元素, 总数)<ul><li>总数可省，自动产生100个元素</li></ul></li><li>结构矩阵<ul><li>或许可以理解为结构体？</li><li>结构矩阵元素.成员名 = 表达式</li><li>可以分别是不同的类型，matlab会放弃给你都显示的</li></ul></li><li>单元矩阵<ul><li>每个元素就是由不同类型的数据组成的</li><li>用{}括起来！</li><li>直接写，不用想结构矩阵那样拆开分别赋值</li></ul></li><li>矩阵元素引用<ul><li>如果改动的位置比较大，超出了原来的矩阵大小，matlab会自动在扩大的地方填充0</li><li>通过下标找元素，如A(x,y)</li><li>通过序号引用：按内存顺序<ul><li>序号 =sub2ind(要转换的行数和列数的向量size(A)，转换矩阵的元素行下标，转换矩阵元素的列下标)，后两者可以是矩阵，即多个元素都要转换：由下标换位序号</li><li>[行下标, 列下标] = ind2sub(要转换的行数和列数的向量size(A),序号)：序号换成下标</li></ul></li></ul></li><li>子矩阵<ul><li>A(i,:)：第i行</li><li>A(i:i+m,:)：第i-i+m行</li><li>A(:,j)：第j列</li><li>A(i:i+n,k:k+m)：第i-i+n行且在k-k+m列中的元素</li><li>当然，这里面都是冒号表达式，所以甚至可以写步长</li><li>end用来代指最后一行/一列</li></ul></li><li>删除元素<ul><li>空矩阵：x = []</li><li>删除方法：赋值为空矩阵</li><li>删除后矩阵会缩小的</li></ul></li><li>reshape(矩阵，行数，列数)：总元素不变，改行数列数，存储顺序不变<br></li><li>堆叠元素：A(:)，使之成为一个列向量，实践证明是按列展开的，不是按存储顺序</li></ul><h3 id="基本运算">基本运算</h3><ul><li>在矩阵意义下的运算</li><li>算数运算<ul><li>标量可以和矩阵运算，此时标量作用于矩阵中每一个数</li><li>除法：右除( $ B<em>A^{-1} $ )、左除(A^{-1}</em>B)</li><li>乘方：A^x，注意A是方阵，x是标量！</li><li>点运算：<ul><li>.*：对应元素做乘法运算</li><li>./：点右除</li><li>.：点左除<br></li><li>.^：点乘方</li></ul></li></ul></li><li>关系运算<ul><li>~=：不等于</li><li>矩阵和矩阵相比是按位置比较，得到一个矩阵</li><li>标量和矩阵比则标量和每一个矩阵元素比，也得到一个矩阵</li></ul></li><li>逻辑运算<ul><li>比较方法同上</li></ul></li></ul><h3 id="字符串">字符串</h3><ul><li>单引号</li><li>字符串即一个行向量</li><li>用两个单引号表示字符串中的单引号</li><li>可以形成字符串矩阵，但需要保证列数相同</li><li>eval(s)：把字符串内容作为指令执行</li><li>可以用char()和abs()/double()在ASCII和字符串之间转换</li><li>可以比较，得到一个同样大小的矩阵/向量<ul><li>strcmp(s1,s2)：相等返回1</li><li>strncmp(s1,s2,n)：前n个字符相等返回1</li><li>strcmpi(s1,s2)：忽略大小写，相等返回1</li><li>strncmpi(s1,s2,n)：忽略大小写，前n个字符相等返回1</li></ul></li><li>findstr(s1, s2)：返回短字符串在成字符串中的开始位置</li><li>strrep(s1,s2,s3)：将字符串s1中的左右子字符串s2替换为s3，区分大小写！</li></ul><h1 id="二-矩阵处理">二 矩阵处理</h1><h3 id="特殊矩阵">特殊矩阵</h3><ul><li><p>zeros：全零</p></li><li><p>ones：全一</p></li><li><p>eye：对角线为1（方阵即单位矩阵，可以不是方阵，从左上角开始为1）</p></li><li><p>rand：（0,1）区间均匀分布的随机矩阵</p></li><li><p>randn：~N(0,1)</p></li><li><p>可以使用函数(size(A))这种形式</p></li><li><p>magic(n)：幻方</p></li><li><p>vander(V)：以V为基础的范德蒙矩阵</p></li><li><p>hilb(n)：希尔伯特矩阵，H(i,j) = 1/(i+j-1)</p></li><li><p>compan(p)：p是一个多项式的系数向量，伴随矩阵</p></li><li><p>pascal(5)：帕斯卡矩阵，p(i,j)=p(i,j-1)+p(i-1,j)</p></li></ul><h3 id="矩阵变换">矩阵变换</h3><ul><li><p>diag(A,k)：提出矩阵A第K条对角线上的元素，右上为正，左下为负，主对角线为0（此时k可省略）</p></li><li><p>diag(V,k)：以向量V为第k条对角线元素，产生对角矩阵，k为0即主对角线时可省略</p></li><li><p>triu(A,k)：上三角阵，提取第k条及右上的元素，k为0时可省略</p></li><li><p>tril(A,k)：同理</p></li><li><p>A.'：转置</p></li><li><p>A’：共轭转置（用于复数）</p></li><li><p>rot90(A,k)：将矩阵A逆时针方向旋转90°的k倍，k为1时可省略</p></li><li><p>fliplr(A)：左右翻转</p></li><li><p>flipud(A)：上下翻转</p></li><li><p>inv：逆矩阵</p></li><li><p>方程求解</p><ul><li>A是系数矩阵，B是常数向量，用x=A</li><li>也可用x = inv(A)*b,这里就是说Ax=b的意思，其实两种都一样</li></ul></li></ul><h3 id="矩阵求值">矩阵求值</h3><ul><li><p>det(A)：方阵A对应行列式</p></li><li><p>rank(A)；秩</p></li><li><p>trace(A)：迹（对角线元素之和）</p></li><li><p>范数</p><ul><li>norm(V,2)：向量V的1——范数（向量元素的绝对值之和，2可省略）</li><li>norm(V,1)：向量V的2——范数（向量元素平方和的平方根）</li><li>norm(V,inf)：向量V的<span class="math inline">\(\infty\)</span>——范数（所有向量元素绝对值中的最大值）</li></ul></li><li><p>条件数</p><ul><li>矩阵A的条件数 = A的范数*A的逆矩阵范数</li><li>越接近1，性能越好</li><li>cond(A,1)：矩阵A的1——范数下的条件数</li><li>cond(A,2)：矩阵A的2——范数下的条件数，2可省略</li><li>cond(A,inf)：矩阵A的<span class="math inline">\(\infty\)</span>——范数下的条件数</li></ul></li></ul><h3 id="矩阵特征值">矩阵特征值</h3><ul><li>$ Ax = x $</li><li>E = eig(A)</li><li>[X, D] = eig(A)，X是各列对应的特征向量，D是X的各列的特征值</li></ul><h3 id="稀疏矩阵">稀疏矩阵</h3><ul><li>A = sparse(S)，将S转化为稀疏存储方式的矩阵</li><li>S = full(A)，将A转化为完全存储方式的矩阵</li><li>sparse(u, v, S)：uvS等长，S为要存储的非零元素，(u,v)是坐标</li><li>带状稀疏矩阵：<ul><li>[B,d] = spdiags(A)，从A中提取全部非零对角线得到B，位置向量得到d</li><li>A = spdiags(B, d, m, n)，上述的操作反过来</li></ul></li></ul><h3 id="程设">程设</h3><ul><li>注意运行脚本文件的时候，matlab需要在那个目录下才行，要不然无法实现</li><li>input();</li><li>disp();</li><li>匿名函数：函数句柄变量 = @(匿名函数输入参数)匿名表达式</li></ul><h3 id="绘图">绘图</h3><ul><li>plot(x, y)</li><li>plot(x)，其中横坐标为1,2,3,4,...</li><li>fplot(f, lims, 选项)</li><li>fplot(funx, funy, tlims, 选项)</li><li>title(图形标题)</li><li>xlable()和ylable()</li><li>text(x, y, 说明)</li><li>gtext(说明)，用鼠标定位</li><li>legend(图例1，图例2，...)</li><li>axis([xmin, xmax, ymin, ymax, zmin, zmax])</li><li>hold on / hold off / hold</li><li>subplot(n, m, p)，n行m列，第p张图</li></ul><h3 id="算法">算法</h3><h6 id="线性规划">线性规划</h6><p>目标：$ min{ c^Tx } $ s.t. $ Ax &lt;= b $ $ Aeqx = beq $ $ lb &lt;= x&lt;= ub $</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x, fval] = <span class="built_in">linprog</span>(c, A, b)</span><br><span class="line">[x, fval] = <span class="built_in">linprog</span>(c, A, b, Aeq, beq)</span><br><span class="line">[x, fval] = <span class="built_in">linprog</span>(c, A, b, Aeq, beq, lb, ub)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记1</title>
      <link href="/2022/02/15/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
      <url>/2022/02/15/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h2 id="java">java</h2><h4 id="读入">读入</h4><p>使用scanner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">String name = scanner.next();</span><br><span class="line"><span class="keyword">long</span> price = scanner.nextLong();</span><br><span class="line"><span class="keyword">double</span> capacity = scanner.nextDouble();</span><br></pre></td></tr></table></figure><h4 id="容器">容器</h4><h5 id="arraylist">ArrayList&lt;&gt;</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;类&gt; 名字 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">名字.add(元素);</span><br><span class="line">名字.set(idx, 元素);</span><br><span class="line">名字.remove(idx或元素);</span><br><span class="line"><span class="keyword">for</span> (类型 item : 名称) &#123;&#125;</span><br><span class="line">Collections.sort(名称); <span class="comment">//引入collections类</span></span><br><span class="line"><span class="keyword">if</span> (名称.contains(元素)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>于是这里歪三产生了一个奇怪的问题，即如果列表里的元素和下标无法区分怎么办：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">tmp.add(<span class="number">5</span>);</span><br><span class="line">tmp.add(<span class="number">6</span>);</span><br><span class="line">tmp.add(<span class="number">3</span>);</span><br><span class="line">tmp.add(<span class="number">4</span>);</span><br><span class="line">System.out.println(tmp);</span><br><span class="line">tmp.remove(<span class="number">3</span>);</span><br><span class="line">System.out.println(tmp);</span><br></pre></td></tr></table></figure><p>采取以上实验之后，她发现了，程序移除了3号位置的元素，而非3这个元素，在idea里，括号中出现的提示字符串也是“index:”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>故idx优先级比元素内容高，且如果两个类型相同，按idx来，所以如果真的要remove一个比较大的元素，直接输入值可能出现越界行为，如下（但满面红光！）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IndexOutOfBoundsException: Index <span class="number">5</span> out of bounds <span class="keyword">for</span> length <span class="number">4</span></span><br><span class="line">at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:<span class="number">64</span>)</span><br><span class="line">at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:<span class="number">70</span>)</span><br><span class="line">at java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:<span class="number">266</span>)</span><br><span class="line">at java.base/java.util.Objects.checkIndex(Objects.java:<span class="number">359</span>)</span><br><span class="line">at java.base/java.util.ArrayList.remove(ArrayList.java:<span class="number">504</span>)</span><br><span class="line">at Main.main(Main.java:<span class="number">15</span>)</span><br></pre></td></tr></table></figure><h5 id="hashmap">HashMap</h5><p>散列表，无序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;类<span class="number">1</span>, 类<span class="number">2</span>&gt; 名称 = <span class="keyword">new</span> HashMap&lt;类<span class="number">1</span>, 类<span class="number">2</span>&gt;();</span><br><span class="line">名称.put(key,value);</span><br><span class="line">名称.remove(key);</span><br><span class="line">名称.clear();</span><br><span class="line">名称.size();</span><br><span class="line"><span class="keyword">for</span> (Integer item : 名称.keySet()) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (Integer item : 名称.values()) &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="treemap">TreeMap</h5><p>它存储类似于HashMap 只允许不同的key<br>log（n）的时间成本 有序 本质是红黑树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;类<span class="number">1</span>, 类<span class="number">2</span>&gt; pairs = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">名称.put(key,value);</span><br><span class="line">value = 名称.get(key);</span><br><span class="line">名称.remove(key);</span><br><span class="line">名称.clear();</span><br><span class="line">名称.size();</span><br><span class="line">名称.firstKey();</span><br><span class="line">名称.lastKey();</span><br><span class="line">名称.ceillingKey(key);<span class="comment">//返回大于或等于给定键的最小键，如果没有这样的键则返回null，floor反之</span></span><br><span class="line">名称.higherKey(key);<span class="comment">//返回严格大于指定键的最小键，lower反之</span></span><br><span class="line"><span class="comment">//上面四个Key换成Entry就可对键值对进行操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="hashset">HashSet</h5><p>集合，无序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;类&gt; 名称 = <span class="keyword">new</span> HashSet&lt;类&gt;();</span><br><span class="line">名称.add(元素);</span><br><span class="line">名称.remove(元素);</span><br><span class="line">名称.clear();</span><br><span class="line">名称.size();</span><br><span class="line"><span class="keyword">for</span> (Integer item : 名称) &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="treeset">TreeSet</h5><p>有序集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;类&gt; 名称 = <span class="keyword">new</span> TreeSet&lt;类&gt;();</span><br><span class="line">名称.add(元素);</span><br><span class="line">名称.remove(元素);</span><br><span class="line">名称.clear();</span><br><span class="line">名称.size();</span><br><span class="line"><span class="keyword">for</span> (Integer item : 名称) &#123;&#125;</span><br></pre></td></tr></table></figure><p>那怎样重载排序的运算符呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Integer&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? <span class="number">1</span> : -<span class="number">1</span>;<span class="comment">// 从大往小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="biginteger">BigInteger</h5><p>好难用…c/c++选手留下痛苦的泪水 今天也是怀念unsigned longlong的一天啊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger sum = <span class="keyword">new</span> BigInteger(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">sum = sum.add(tmp);</span><br></pre></td></tr></table></figure><p>怎么进行数据转换呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger tmp = <span class="keyword">new</span> BigInteger(val.toString());<span class="comment">//但是对于非val类型的就得看下面的方法了</span></span><br><span class="line">BigInteger tmp = <span class="keyword">new</span> BigInteger(Long.toString(一个长整型数));<span class="comment">//int同理</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记0</title>
      <link href="/2022/02/13/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/"/>
      <url>/2022/02/13/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/</url>
      
        <content type="html"><![CDATA[<h1 id="java">java</h1><h2 id="一-java对象及语言初步">一 java对象及语言初步</h2><ul><li><p>java的并发性</p><ul><li>无并发：main loop</li><li>对象并发</li></ul></li><li><p>对象在程序中第一次出现的时候只是一个引用，需要实例化（开辟的是引用空间而不是数据空间）</p></li><li><p>语法</p><ul><li>驼峰 接口名、类名首字母大写</li></ul></li><li><p>UML? VISIO? UMLet工具和Dia？</p></li></ul><p><strong>“我们要做对编译系统友好的程序员”</strong></p><h2 id="二-java的表达式流控制和数组">二 java的表达式，流控制和数组</h2><h6 id="和c的区别">和C的区别</h6><ul><li>强类型语言</li><li>不提供指针运算符！但是有引用</li><li>字符串运算符+</li><li>零填充的右移&gt;&gt;&gt;</li><li>++、--是最快的操作，还有移位操作，都是一个时钟周期的事情</li></ul><h6 id="混合类型运算">混合类型运算</h6><ul><li>long：都不是float和double，至少有一个是long</li><li>int：只能是int</li><li>double：至少有一个是double</li><li>float 只少有一个是float，且都不是double</li></ul><h6 id="操作符">操作符</h6><ul><li>位移<ul><li>无符号右移：&gt;&gt;&gt;</li></ul></li><li>逻辑运算（区别于布尔运算）<ul><li>&amp;|^~</li><li>异或曾经被大量用在画画中</li></ul></li><li>逻辑操作符<ul><li>&amp;&amp; || ! &amp; | ^</li></ul></li><li>赋值<ul><li>注意新增一个&gt;&gt;&gt;=</li></ul></li><li>其他<ul><li>instanceof：<ul><li>op1 instanceof op2</li></ul></li></ul></li></ul><h6 id="类型强制转换">类型强制转换</h6><p>整型与浮点型</p><h6 id="流控制">流控制</h6><h6 id="数组声明">数组声明</h6><ul><li>可以改变空间 用new</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">a[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><ul><li>在java里面数组得名字是一个地址变量（区别于c是地址常量）</li></ul><h2 id="三-java语言的对象与类">三 java语言的对象与类</h2><h6 id="封装">封装</h6><h6 id="多态">多态</h6><h6 id="继承">继承</h6><h6 id="创建对象的步骤">创建对象的步骤</h6><ul><li>声明</li><li>实例化</li><li>初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[类型] 名称;</span><br><span class="line">名称 = <span class="keyword">new</span> 对象所属类的构造方法，如[类型]();</span><br></pre></td></tr></table></figure><h6 id="对象的回收">对象的回收</h6><ul><li>当把一个对象没有引用指向它时，会被自动回收</li></ul><h6 id="类的构造方式">类的构造方式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名(参数)</span><br><span class="line">&#123; ··· &#125;</span><br><span class="line"><span class="comment">//方法名必须与类名相同，不能带返回类型</span></span><br></pre></td></tr></table></figure><h6 id="类成员方法定义">类成员方法定义</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modifiers&gt;&lt;return_type&gt;&lt;name&gt;</span><br><span class="line">([&lt;argument_list])[<span class="keyword">throws</span>&lt;exception&gt;]&#123;&lt;block&gt;&#125;</span><br><span class="line"><span class="comment">//传值，方法调用不改变参数的值</span></span><br><span class="line"><span class="comment">//但若参数是对象，参数的值是该对象的引用，故对象的内容可以在方法中被改变，但是对象的引用不会改变</span></span><br></pre></td></tr></table></figure><h6 id="数据的隐藏和分装">数据的隐藏和分装</h6><ul><li>数据隐藏：private，保证对象中数据的一致性</li><li>封装<ul><li>隐藏类中具体实现的细节</li><li>强迫使用统一接口访问数据</li><li>使代码可维护性好</li></ul></li></ul><h6 id="this-引用">this 引用</h6><ul><li>指向当前的对象本身</li></ul><h6 id="重载">重载</h6><ul><li>在同一个类中一个方法名被用来定义多个方法</li><li>参数必须不同</li><li>返回类型、修饰符可相同</li></ul><h6 id="激活重载的构造方法">激活重载的构造方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;name1&gt;(para1, para <span class="number">2</span>)</span><br><span class="line">    &#123; ··· &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;name1&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">this</span>.(a, b); <span class="comment">//这里就在调用之前同名的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="子类">子类</h6><ul><li>有父类全部的属性和自己新定义的属性</li><li>带private修饰符的不可被继承</li><li>构造方法不能被继承但可以调用，调用自己的用this()，调用父类的用super()</li><li>extends</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> &lt;<span class="title">father_name</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123; ··· &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> &lt;<span class="title">son_name</span>&gt; <span class="keyword">extends</span> &lt;<span class="title">father_name</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123; ··· &#125;</span><br></pre></td></tr></table></figure><ul><li>java中任何一个子类的实例化都可以作为父类的实例使用，可以调用父类具有的方法-&gt; 所以一个类数组的每一个单元的类型可以是各种子类</li><li>单继承，即extends后面只有一个类名</li></ul><h6 id="多态-1">多态</h6><ul><li>引用类型 + 实例化类型</li><li>父类对象的变量作为子类对象的变量使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;father_name&gt; &lt;name&gt; = <span class="keyword">new</span> &lt;son_name&gt;();</span><br></pre></td></tr></table></figure><h6 id="重写">重写</h6><ul><li>子类可以改变从父类继承的行为，被重写方法的返回值、方法名、参数列表要与父类中的方法完全一样</li><li>如果不一样，那叫多态</li><li>方法的访问权限不能缩小</li></ul><h6 id="抽象类">抽象类</h6><ul><li>抽象类不能直接用来生成实力，一般可通过定义子类进行实例化</li></ul><h6 id="接口">接口</h6><ul><li>interface</li><li>所有成员方法都是抽象的，并且只能定义static final成员变量</li><li>接口的继承（？用implements，该子类中必须实现接口（及其超类）中的所有方法</li><li>extends和implements同时存在时，就按这个顺序写：extends &lt;&gt;implements &lt;&gt;</li><li>可以通过实现接口实现多重继承：一个类可只继承一个父类，并实现多个接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;&gt; <span class="keyword">extends</span> &lt;&gt; <span class="keyword">implements</span> &lt;&gt;&lt;&gt;···&lt;&gt; </span>&#123; ··· &#125;</span><br></pre></td></tr></table></figure><h6 id="静态变量类型">静态变量类型</h6><ul><li>static / class variable</li></ul><h6 id="静态类方法">静态类方法</h6><ul><li>可以直接被调用，而不需要生成任何实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> &lt;&gt;()</span><br><span class="line">&#123; ··· &#125;</span><br></pre></td></tr></table></figure><h6 id="final">final</h6><ul><li>被定义成final的类不能被继承（不能有子类）</li><li>成员方法不能被重写，成员变量不能被改变，一般用大写表示，是常量</li></ul><h2 id="四-java包与访问控制例外处理">四 java包与访问控制、例外处理</h2><p>包与访问处理可以和using namespace std类比</p><h6 id="类分组">类分组</h6><ul><li>语句：package 包名</li></ul><h6 id="高级访问控制">高级访问控制</h6><ul><li>不针对类，以类为单位</li><li>应用于class或type层次</li></ul><h6 id="内部类">内部类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> //只在包容类中调用 </span>= 不能被任何其他类访问，只能自己访问，作为类的一个成员使用</span><br><span class="line">&#123; ··· &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>wrapper：将基本类型表示成类，可调用MIN_VALUE和MAX_VALUE，还有valueOf和toString实现字符串与数字之间的转化</li></ul><h6 id="collection-api-集合类">collection API 集合类</h6><ul><li>set<ul><li>不能包含重复元素</li><li>HashSet</li><li>TreeSet</li></ul></li><li>list<ul><li>有序集合，元素可重复</li></ul></li><li>string</li></ul><h6 id="捕捉与例外处理">捕捉与例外处理</h6><ul><li>try，后面必须跟随一个catch或者finally语句块</li><li>catch</li><li>finally</li><li>抛出：throw</li><li>获得例外并处理：connectMe</li></ul><h2 id="五-io">五 I/O</h2><ul><li>设备、DMA</li></ul><h6 id="流式io">流式I/O</h6><ul><li>按输入源头<ul><li>node stream</li><li>filter stream</li></ul></li><li>字节流<ul><li>input stream<ul><li>甚至可以skip</li></ul></li><li>output stream<ul><li>void write * 3</li><li>void flush() //强行写，保证写进去了</li></ul></li></ul></li><li>reader: int read()</li><li>writer: int write()</li><li>grep</li><li>管道流：把一个线程的输出连接到另一个线程的输入<ul><li>倒排字典 押韵 -&gt; 好背 lol</li><li>单词逆序 -&gt; 排序 -&gt; 然后再逆回来</li></ul></li><li>过滤流：从原始流成块读入，或将数据累计到一个大数据块儿后再成批输出</li></ul><h6 id="大作业-orz">大作业 orz</h6><h2 id="六-awt及applet编程">六 AWT及Applet编程</h2><ul><li>AWT 抽象窗口工具集</li><li>Java.awt包</li></ul><h6 id="容器">容器</h6><ul><li>所有组件都必须放在容器内（如窗口）</li><li>frame / panel / layout manager（如比较古早的网页布局设计方法）</li><li>events 描述不同类型的用户动作</li><li>component<ul><li>支持基本的drawing</li><li>paint(), update(), repaint()</li></ul></li></ul><h6 id="applet">applet</h6><ul><li>html 标志方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献阅读week_2</title>
      <link href="/2022/02/04/week-2/"/>
      <url>/2022/02/04/week-2/</url>
      
        <content type="html"><![CDATA[<h2 id="week-2">week 2</h2><h2 id="section">1</h2><h3 id="题目面向服务的制造系统中制造服务供需匹配研究综述与展望">题目：面向服务的制造系统中制造服务供需匹配研究综述与展望</h3><h3 id="笔记">笔记：</h3><ul><li>制造服务供需匹配：<ul><li>供应：以服务形式存在的各类制造资源</li><li>资源：通过配置整合成为能力</li><li>服务：资源和能力通过一定的感知与接人、虚拟化、服务化等处理后以制造服务的形式存在从而可以通过网络被聚合、检索、调用等，并为社会化的用户提供面向产品全生命周期的各类应用</li><li>需求：全生命周期过程中涉及的所有与生产相关或与产品相关的任务以及其他服务需求的集合</li><li>资源+需求配置，结果得到制造服务和制造服务需求的映射关系</li><li>资源配置：需要哪些制造服务、怎么用，来解决某个服务需求</li><li>需求配置：是什么需求、任务按什么顺序被某个服务执行</li><li>包括静态预调度和动态再调度的双重决策</li><li>分类：<ul><li>从匹配的实质出发：包括供需对象匹配和供需数量匹配</li><li>从实现匹配的主体出发：包括企业供需匹配和系统供需匹配</li></ul></li><li>未来研究展望：<ul><li><strong>社会化</strong>制造服务供需的<strong>动态</strong>匹配</li><li>大数据的应用：演化、统计、挖掘与预测</li><li>供需匹配与企业协作及其价值创造的相互映射与影响</li><li>SOM系统／服务平台的完善及其与工业物联网的融合</li></ul></li></ul></li></ul><h3 id="总结">总结：</h3><p>本文是一篇综述型文章。为推进制造业的信息化发展，本文发展面向服务的制造系统进行了现状讨论与趋势分析。其供需匹配在于资源配置和需求配置，目的是得到制造服务和制造服务需求的映射关系。其中供需匹配的研究模型分为供需静态、需求动态、供应动态、供需动态和过程动态。供需匹配问题的实现方法，从匹配依据的角度包括成本类、能耗类、时间类、质量类、风险类和其他评估指标；从技术手段分为点对点式、基于中介器和基于系统/服务平台的供需匹配；从求解方法分为基于模板／本体和关键字、基于流程驱动的方法、基于人工智能和规划的方法、基于图论的方法、基于中介器的方法、基于服务组合的方法、基于供应链的方法、基于智能体的方法、基于服务质量优化的方法等。其仍有不少展望值得继续探究。</p><h2 id="section-1">2</h2><h3 id="题目面向服务的制造系统中制造服务供需匹配研究综述与展望-1">题目：面向服务的制造系统中制造服务供需匹配研究综述与展望</h3><h3 id="笔记云制造典型特征关键技术与应用">笔记：云制造典型特征、关键技术与应用</h3><ul><li>典型技术特征：制造资源和能力的物联化、虚拟化、服务化、协同化、智能化</li><li>关键技术：<ul><li>物联化技术<ul><li>自适应适配器技术，以及制定接口规范和标准传输协议</li></ul></li><li>虚拟化技术<ul><li>涉及各类“虚拟器件”模板或镜像的创建、发布、存储技术以及将物理环境迁移到虚拟环境的技术等</li><li>需要建立规范化的虚拟资源和能力描述模型，能够灵活管理“物理一虚拟器件”之间的映射关系</li></ul></li><li>智能化技术</li><li>云安全是一个共性的、十分重要的问题，限于篇幅，本文并未专门论述</li></ul></li><li>应用案例：<ul><li>面向航天复杂产品的集团企业云制造服务平台</li><li>面向轨道交通装备的集团企业云制造服务平台</li><li>支持企业业务紧密合作的中小企业云制造服务平台</li><li>支持产业集群协作的中小企业云制造服务平台</li><li>（以上均从五个技术特征分析）</li></ul></li><li>总结展望：<ul><li>在落实阶段</li><li>系统建设和技术/产品发展相互促进</li><li>建造云制造技术研究队伍</li><li>重视自主云制造产业</li></ul></li></ul><h3 id="总结-1">总结：</h3><p>本文总结了云制造的典型技术特征，即制造资源和能力的物联化、虚拟化、服务化、协同化、智能化；以及实现云制造的关键技术，即物联化技术、虚拟化技术、智能化技术、以及本文并未展开的安全技术。同时，本文展示了当前云制造的一些应用案例。而对于未来云制造的发展，本文提出应该在云制造系统建设和技术/产品发展相互促进的良性循环中，通过建造云制造技术研究队伍，并重视自主云制造产业的方式进行进一步工作。</p><h2 id="section-2">3</h2><h3 id="题目云制造及相关先进制造模式分析">题目：云制造及相关先进制造模式分析</h3><h3 id="笔记-1">笔记：</h3><ul><li>制造的服务化、基于知识的创新能力，以及对各类制造资源的聚合与协同能力、对环境的友好性，已成为构成企业竞争力的关键要素和制造业信息化发展的趋势</li><li>与云制造相关的先进制造模式<ul><li>敏捷制造<ul><li>有点推式制造的感觉？需要快速反应。纹理给出了三种别人的解释，想必他们自己也没有很好的辨析清楚（笑）。</li><li>这种模式下诞生了虚拟企业（只关注其具有核心竞争能力的功能业务，将非核心业务进行虚拟化/当市场出现新机遇时，不同公司为了共同的竞争目标，以网络为基础所组成的临时性动态联盟）</li><li>这个虚拟企业有趣！</li></ul></li><li>网络化制造<ul><li>是敏捷制造等模式的延续和发展</li><li>通过网络实现分散计算资源的共享与优化配置</li></ul></li><li>面向服务的制造</li></ul></li><li>云制造<ul><li>对比敏捷制造<ul><li>平台更开放</li><li>协作联盟范围更广</li><li>资源种类数量更丰富</li><li>企业间有更持久的业务过程经验和知识积累</li><li>涉及业务范围更广</li></ul></li><li>对比网络化制造</li><li>对比面向服务的制造<ul><li>云制造是面向服务制造理念的一种体现，通过产品与服务、制造与服务的融合，实现以向用户提供专业化及社会化的服务为目的。</li><li>云制造理念丰富了面向服务制造的内涵，如强调了制造能力的服务化、资源的按需使用及动态协同等。</li></ul></li></ul></li><li>总结：<ul><li>云制造借鉴了已有先进制造模式的成果，并在理念、模式、组织实施、技术架构等多方面进行了拓展。</li><li>模式、技术及应用仍有展望</li></ul></li></ul><h3 id="总结-2">总结：</h3><p>为了更好的理解云制造的特点和内涵，本文列举了现有的先进制造模式：敏捷制造、网络化制造与面向服务的制造，并一一与云制造的理念嗯应用模式对比，找出区别与联系。从中可见云制造拥有更加广阔的平台和丰富的资源，同时更加体现了制造的服务化、对各类制造资源的聚合与协同能力，实现以向用户提供专业化及社会化的服务。</p><h2 id="section-3">4</h2><h3 id="题目云制造模式下制造能力建模关键技术">题目：云制造模式下制造能力建模关键技术</h3><h3 id="笔记-2">笔记：</h3><ul><li>制造能力是云制造服务平台中最重要和核心的服务内容之一，通过智力资源的引入，能够将上述资源进行有效集成并以能力的形式对外提供</li><li>云制造模式下制造能力概念模型与分类<ul><li>制造能力概念模型<ul><li>制造能力：在某一具体活动过中产生，体现了一种对制造资源配置和整合的能力</li><li>包括四个部分：资源(Resource，R)、过程(Process，P)、任务(Task，T)和知识(Knowledge，K)，即制造能力的RPT-K模型</li></ul></li><li>分类<ul><li>制造能力层次结构：为资源级(单元级)、业务级(流水线级)、企业级和产业级</li><li>制造能力需求：制造资源租用/产品业务购买方式</li><li>制造能力组成：基本能力和增值能力</li></ul></li></ul></li><li>制造能力多维信息描述模型：包括要素描述、关系描述、和评估指标<ul><li>（这里也有离散的感觉！）</li><li>主体资源</li><li>产品／业务信息描述</li><li>人力资源</li><li>过程知识</li></ul></li><li>制造能力描述框架（上面是 是什么，这里是 怎么描述，也就是语言）<ul><li>离散！！！！离散啊啊啊啊！</li></ul></li><li>制造能力管理及应用技术<ul><li>制造能力封装发布、智能匹配、动态组合、制造能力协同、制造能力综合评估及演化等</li><li>采用“一次搜索、二次推荐”的方法来实现</li></ul></li><li>本文通过前面给出的制造能力的相关理论分析，设计开发了一款制造能力服务化原型系统。该系统主要针对三种资源(硬件加工设备、软件、智力资源)及能力进行服务化封装发布。</li></ul><h3 id="总结-3">总结：</h3><p>本文对云制造模式下制造能力概念模型进行了描述（RPT-K模型），并提出了针对制造能力层次结构、制造能力需求和制造能力组成的分类。根据要素描述、关系描述、和评估指标建立制造能力多维信息描述模型和描述框架。制造能力管理及应用技术在于制造能力封装发布、智能匹配、动态组合、制造能力协同、制造能力综合评估及演化等。同时，本文通过制造能力的相关理论分析，设计开发了一款制造能力服务化原型系统。该系统主要针对三种资源（硬件加工设备、软件、智力资源）及能力进行服务化封装发布。</p><h2 id="section-4">5</h2><h3 id="题目云制造特征及云服务组合关键问题研究">题目：云制造特征及云服务组合关键问题研究</h3><h3 id="笔记-3">笔记：</h3><ul><li>制造云服务组合是提高云制造资源利用率、实现制造资源增值的关键途径之一</li><li>而云制造系统中云服务的多样性、复杂性、规模性等特点，使得以上方法不能直接用于云服务组合的实现。</li><li>云制造的典型特征：<ul><li>面向服务和需求</li><li>不确定性</li><li>用户参与</li><li>透明和集成（计算机意义下的透明）</li><li>主动（订单主动寻找制造方/云服务主动寻找租户）</li><li><strong>按需使用和付费</strong></li><li>低门槛、外包式制造</li><li>敏捷化</li><li>专业化</li><li>基于能力共享与交易</li><li>基于知识</li><li>基于群体创新（维基百科式）</li><li>绿色低碳（是云制造目标之一）</li></ul></li><li>概念辨析<ul><li>制造资源<ul><li>一切能在制造全生命周期中发挥作用的所有软硬件资源、人、知识等的总称</li><li>可描述出相应的制造能力</li><li>经虚拟化封装成制造云服务</li></ul></li><li>制造云服务<ul><li>建成云服务</li><li>与云计算服务相对应</li><li>把云制造资源和云制造能力基于知识进行虚拟封装，接入智能平台，通过网络想用户提供高度虚拟化的云端资源/服务的过程</li></ul></li><li>制造云<ul><li>云服务按照一定规则聚合形成</li><li>云服务资源池</li></ul></li><li>针对按需分配和使用资源的特点，需要云服务组合</li></ul></li><li>云服务组合<ul><li>主要模型（图4）</li><li>关键问题<ul><li>云服务组合建模、描述、一致性检查、可执行模型转换</li><li>云服务组合关联关系</li><li>云服务组合柔性管理</li><li>云服务组合网络及动力学特性</li><li>云服务组合综合评估及优选</li></ul></li></ul></li></ul><img src="02/04/week-2/image-20220204085628392.png" class title="image-20220204085628392"><ul><li>下一步：将对本文提到的云服务组合关键问题进行深入研究，提出相应的解决方法，并对云制造模式进行全方位研究。</li></ul><h3 id="总结-4">总结：</h3><p>云制造系统中云服务的多样性、复杂性、规模性等特点，使得一般制造方法不能直接用于云服务组合这一提高云制造资源利用率、实现制造资源增值的关键途径的实现。本文有限分析了云制造特点，辨析了制造资源、制造云服务、制造云三者的概念，提出云服务组合的重要性，并在此基础上对云服务组合全生命周期需求进行分析，阐述了云组合服务的关键问题：云服务组合建模／描述和一致性检查、云服务关联关系、云服务组合柔性、组合网络及其动力学特性、云服务组合建模与评估、组合优选等，为未来实现高效智能化的云制造服务管理提供理论支持。</p><h2 id="section-5">6</h2><h3 id="题目制造云构建关键技术研究">题目：制造云构建关键技术研究</h3><h3 id="笔记-4">笔记：</h3><ul><li>概念介绍<ul><li>制造云服务</li><li>制造云<ul><li>制造公云</li><li>制造私云</li></ul></li></ul></li><li>制造云构建层次示意图</li><li>制造云构建的关键技术<ul><li>资源分类（同样的，还是资源形成能力） <img src="02/04/week-2/image-20220204094403945.png" class title="image-20220204094403945"><ul><li>定义属性：静态/动态</li></ul></li><li>资源虚拟化<ul><li>主要指云制造能力和资源的虚拟化</li><li>弱化物理依赖</li><li>包括资源感知和资源的虚拟接入</li><li>资源感知<ul><li>硬资源感知：物联网</li><li>软资源感知：对静态属性</li></ul></li><li>虚拟接入</li></ul></li><li>虚拟资源服务化<ul><li>把资源描述规范，以服务的形式发布到云平台</li><li>DMM[c=(Task，Resource，Participator，Knowledge)。</li></ul></li><li>云服务部署<ul><li>对制造云中的云服务进行集中、高效的管理</li><li>面向完全托管的部署</li><li>面向部分托管的部署</li></ul></li></ul></li><li>面向设计仿翼的云服务平台<ul><li>虚拟化支撑子系统</li><li>云服务管理子系统</li><li>知识库管理子系统</li><li>面向云服务的复杂产品设计子系统</li></ul></li></ul><h3 id="总结-5">总结：</h3><p>本文围绕制造云的构建，研究了其过程与其中的关键技术。本文首先结合云制造模式的特点，对制造云及制造云服务进行了相关说明和层次展示，并对制造云构建过程中的关键技术依次做了详细阐述：资源分类、资源虚拟化、虚拟资源服务化与云服务部署。最后，结合已有成果，课题组初步开发了面向设计仿真的云服务平台原型，该平台主要针对产品全生命周期应用过程中设计、仿真阶段的各类资源，包括虚拟化支撑、云服务管理、知识库管理和面向云服务的复杂产品设计四个子系统。同时，本文也展望未来，如云制造运行模式、平台标准规范等依旧是云制造研究中面临的问题，下一步将结合制造业实际需求对相关的问题做更深入的研究与探索，推进云制造落地。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务 云制造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献阅读week_1</title>
      <link href="/2022/01/25/week-1/"/>
      <url>/2022/01/25/week-1/</url>
      
        <content type="html"><![CDATA[<h2 id="section">1</h2><h3 id="题目基于bom的节能减排评估系统研究水">题目：基于BOM的节能减排评估系统研究水</h3><h3 id="笔记">笔记：</h3><p>这个BOM物料清单！这不是经管考点嘛。目标：节能减排，到转变经济增长方式，合理利用资源，优化企业生产结构的目的，从而建设一个资源节约型、环境友好型社会。以使节能减排评估与企业现有信息化有机结合和无缝集成，从而在实现了企业节能减排评估设计的基础上，盘活了企业现有信息化系统，实现了企业的信息化增效。目前，温室气体减排对于全面实施节能减排有重要意义，而有了产品生命周期温室气体排放评估，便可以计算产品碳足迹，在商品上添加碳标签，引导消费者购买更低碳的商品，实现减排。同时</p><h3 id="总结">总结：</h3><p>本文提出一种基于BOM的节能减排评估方法，实现企业节能减排评估设计与信息化的有机结合。节能减排的两种方法——计算碳足迹，添加碳标签以引导消费者购买更低碳的商品、把二氧化碳排放权作为一种商品，形成的二氧化碳排放权交易，都依赖于对产品生命周期温室气体排放的评估。于是本文提出基于物料清单的节能减排评估，其结构包括应用层、核心功能层和数据支撑层，其中应用层包括用户管理、节能减排数据采集与统计、节能减排指标评价与分析、节能减排设计和结果可视化；核心功能层负责链接应用层和数据支撑层；数据支撑层负责存放用户和企业数据以及减排的指标。其运作流程如下：完善企业减排基础数据库；对产品生命周期建模；基于BOM对产品生命周期模型中各个环节进行属性添加；计算各个环节的能耗和排放数据，进行节能减排评估；对照标准判定模型可用性，迭代得到最优方案。</p><h2 id="section-1">2</h2><h3 id="题目基于owlp的产品开发过程共享信息语义描述">题目：基于OWL—P的产品开发过程共享信息语义描述</h3><h3 id="笔记-1">笔记：</h3><p>为缩短开发时间，提高企业的竞争力，复杂产品开发的许多阶段都由分布在不同地点、实现不同功能的学科团队合作完成，这就需要产品开发过程中的各种信息能够被顺畅地交换和共享。本体作为“共享概念模型的明确的形式化规范说明”，提供了形式化描述知识的基础，使系统之间的知识级共享和集成成为可能。太硬了太硬了啊啊啊…我看不懂了……这充满了离散数学的逻辑……</p><h3 id="总结-1">总结：</h3><p>为缩短复杂产品的开发时间，提高企业的竞争力，企业需要对交换的静态结构信息（各个原件的概念、属性等）和动态特征信息（不同组件的连接顺序、内部数据流关系、对外接口、装配顺序等）进行语义化描述。故本文提出利用面向过程的Web本体描述语言，构造产品共享信息模型。在OWL语法基础上定义语义、关系以及运算规则，建立了一个逻辑运算系统，提出了可以同时描述静态结构和动态特性的OWL—P语言，满足复杂产品的抽象、产品的知识共享、以及产品的知识推理。</p><h2 id="section-2">3</h2><h3 id="题目基于云制造平台企业合作演化仿真系统的设计与实现">题目：基于云制造平台企业合作演化仿真系统的设计与实现</h3><h3 id="笔记-2">笔记</h3><p>云制造：云制造是为降低制造资源的浪费，借用云计算的思想，利用信息技术实现制造资源的高度共享。建立共享制造资源的公共服务平台，将巨大的社会制造资源池连接在一起，提供各种制造服务，实现制造资源与服务的开放协作、社会资源高度共享。企业用户无需再投入高昂的成本购买加工设备等资源，咨询通过公共平台来购买租赁制造能力。在理想情况下，云制造将实现对产品开发、生产、销售、使用等全生命周期的相关资源的整合，提供标准、规范、可共享的制造服务模式。这种制造模式可以使制造业用户像用水、电、煤气一样便捷地使用各种制造服务。</p><p>但由于市场的开放性，会有很多因素影响交易的进行。为应对云制造服务平台的不稳定性，进行仿真系统的设计。 其结构如下：</p><ul><li>记录每个企业的基本信息+交易信息，其中包括可调节的服务质量和服务时间</li><li>管理线程：交易频率+交易对象+交易状态 结果：</li><li>产生可视化交易网格</li><li>将不同规则约束下的仿真中交易发生的频率对比实际，得到演化后企业利润</li><li>同时可以通过此仿真模型来调整平台的规则，避免个体、团体垄断出现，平衡平台中企业利润的分配</li></ul><h3 id="总结-2">总结：</h3><p>此文以利用云计算的思想，使制造资源的高度共享，以降低制造资源浪费的云制造平台为背景，介绍了一个企业合作演化仿真系统。该系统结构包括两个部分，资源池和其上的仿真管理平台，其中资源池中记录每个企业的可调的基本信息与变动的交易信息，而仿真管理平台又分为线程管理（即交易频率、交易对象、交易状态）、交易过程管理（此次交易的现金流、对质量的评价等）及规则接口管理（以一定规则对交易对象进行排序，如企业位置、服务价格、服务时间、服务质量等）三个主要模块。（注：这里原文的实际写作顺序和概括性话语的顺序不一样。）该仿真平台可调整的参数包括：线程数量的随机程度，企业的位置、服务质量、服务时间，交易的服务时间误差，交易排序规则。其用途体现在，其一，仿真结果可以将不同规则约束下的仿真中交易发生的频率对比实际，得到演化后企业利润；其二，可以通过此仿真模型来调整平台的交易规则，避免个体、团体垄断出现，同时平衡平台中企业利润的分配。</p><h3 id="问题">问题：</h3><p>大概是我境界不够或者文章有些年头了？感觉这篇文章起在了一个我并不了解的地方，确实有其用处，但这个模型过于粗糙了。首先，一上来我就没有看懂文章里写的云计算是什么意思。因为他真的没有突出云制造和现在的交易市场的区别在哪里——交易对象是放眼到整个世界中算出来的。或者说，他这个论文太短了，什么都没说清就过去了。其次，这个变量也太多了，如何贴合实际的进行调整，本人认为这不应该是交由人类来做的事情，文章也没有说，只是提出了这么一个平台的概念。这个规则到底由不由平台制定，由谁制定，这都很难说。特别是这样的云制造，它会涉及国家之间的贸易往来，那请问这个模型是否还有其他意义？或者，这个规则还能怎么制定？所以本人认为，这个模型建立的非常粗糙，看似用了很多随机数模拟真实情况（但有没有考虑中心极限定理哇！），但有些脱离实际。而且，这个交易本身也是被抽象出来的，实际上的交易可能涉及链状等复杂情况，也可能涉及诸多感性联系的影响，很难模拟。并且，至于他到底多有用，也没有一个用于评估价值的系统与之呼应（满脑子loss函数了属于是），最后只给了我三张只写了一个图注的图，让我来猜他们是什么意思。所以它的用途也仍有待考究。总结一下，就是面向的问题太大太广，提出的方法太模糊，成品太粗糙。</p><h2 id="section-3">4</h2><h3 id="题目面向产品全生命周期的制造资源优选及组合方法研究">题目：面向产品全生命周期的制造资源优选及组合方法研究</h3><p>将服务分为两类：单一资源服务需求任务和多资源服务需求任务目标问题：服务的优选服务属性：前端属性是指该类服务处在制造全生命周期的后一个制造环节，被其他制造资源调用时所用到的匹配属性；后端属性是指该类资源处在制造全生命周期的前一个环节时，调用其他服务所用到的匹配属性。连续型；离散型。正向属性是指当某类属性的取值变大时，制造代价也变大；负向属性反之。</p><ul><li><p>解决方法：</p><ul><li><p>单服务：</p></li><li><p>使用权值计算法，对服务属性进行加权，用公式 $ Price(s) =_{n}^{i=1} {w(a_i)a_i} $ ，但若此时约束条件不为0，则$ Price =+$</p></li><li><p>约束条件包括：</p><p>$ status =</p><span class="math display">\[\begin{cases}0,  &amp; \text{资源可用} \\1, &amp; \text{资源不可用}\end{cases}\]</span><p>$</p><p>$ 加工精度 =</p><span class="math display">\[\begin{cases}0,  &amp; \text{实际加工精度 &gt;= 用户期望} \\1, &amp; \text{资源不可用 &lt; 用户期望}\end{cases}\]</span><p>$</p><p>$ 服务类型系数 =</p><span class="math display">\[\begin{cases}0,  &amp; \text{服务类型匹配} \\1, &amp; \text{服务类型不匹配}\end{cases}\]</span><p>$</p><p>三者相加得到最终约束条件。</p></li><li><p>此时得到了所有服务的price，由低到高排序得到最佳匹配服务。</p></li></ul></li><li><p>多服务组合优选</p><ul><li>$ Price(service_i) = <em>{正向因素} {r_ja</em>{ij}} - <em>{负向因素}{r_ja</em>{ij}}$ ，其中 <span class="math inline">\(r_j\)</span>表示j个属性的权值，$ a_{ij}$ 表示第i个服务的j个属性大小</li><li>最优服务组合即最优个体相加得到</li></ul></li></ul><h3 id="总结-3">总结：</h3><p>此文运用云制造系统服务云池的理论，结合制造业产业链中产品全生命周期理论，对单一资源服务需求任务和多资源服务需求任务分别建立模型进行仿真。文章将服务的属性分为前端属性、后端属性；连续型、离散型；正向属性、负向属性。</p><p>对于单一资源服务，文章采用使用权值计算法，对服务属性进行加权，得到如下制造代价的公式：$ Price(s) = _{n}^{i=1} {w(a_i)a_i} $ ，受到以下三个条件的约束：</p>$ status =<span class="math display">\[\begin{cases}0,  &amp; \text{资源可用} \\1, &amp; \text{资源不可用}\end{cases}\]</span><p>$</p>$ 加工精度 =<span class="math display">\[\begin{cases}0,  &amp; \text{实际加工精度 &gt;= 用户期望} \\1, &amp; \text{资源不可用 &lt; 用户期望}\end{cases}\]</span><p>$</p>$ 服务类型系数 =<span class="math display">\[\begin{cases}0,  &amp; \text{服务类型匹配} \\1, &amp; \text{服务类型不匹配}\end{cases}\]</span><p>$</p><p>三者相加得到最终约束条件。但若约束条件不为0，则$ Price = +$。由此此时得到所有服务的制造代价，由低到高排序得到最佳匹配服务。</p><p>而对于多服务组合优选的模型建立，本文采取个体相加得到组合最优的策略，运用加权公式$Price(service_i) = <em>{正向因素} {r_ja</em>{ij}} - <em>{负向因素}{r_ja</em>{ij}}$ 计算每个服务的代价 ，其中 <span class="math inline">\(r_j\)</span> 表示j个属性的权值，$ a_{ij}$表示第i个服务的j个属性大小。在多资源的任务中，每一个进程选择下一项服务时都通过对这种服务的制造代价由低到高排序得到下一步的最佳匹配服务，即转化为多个单环节服务优选模型组合构成。</p><p>此模型可以用于解决云制造系统基于产品全生命周期的制造资源和服务的选优和组合优化的问题，但未考虑时间对属性等因素的影响。</p><h2 id="section-4">5</h2><h3 id="题目云制造资源服务能耗评估及应用">题目：云制造资源服务能耗评估及应用</h3><h3 id="笔记-3">笔记：</h3><p>本文利用物联网技术对制造硬资源(设备资源、物料资源、基础设施资源等)的能耗信息进行感知和采集，针对不同类型的硬资源，采取不同的物联网感知技术与适配技术，对已感知的能耗信息进行描述，满足云制造平台对资源粗耦合接入的需求，将异构的资源整合到统一的云基础架构中并实现标准化、服务化提供支持。</p><p>（这个文档有两页有问题，是白页）</p><h3 id="总结-4">总结：</h3><p>本文从考虑降低能耗的角度提出了一种基于物联网的云制造资源服务能耗综合评估框架和云制造服务能耗计算模型。其中，云制造资源服务能耗综合评估框架主要由物联网技术进行的数据采集、评估、以及用户接口来提供评估应用三个部分组成。而能耗计算模型面向服务的云制造模式，更注重过程，能耗问题研究主要在服务准备能耗、服务优化组合能耗、服务配置能耗、服务使用能耗、服务处置能耗和回收能耗等阶段。云制造服务能耗计算矩阵用于计算若干任务单位在正常载荷、空载、附加载荷(或者是损失能耗) 状态下所消耗的某种一次能源、二次能源及能耗工质；任务的综合耗能公式为能耗折煤量之和；服务的综合能耗为可定量的某类基本单位服务所需要的能耗。再由约束条件，可得出资源服务能耗的评估系统。由此模型可初步探索出如何加强制造资源的节能调度、进行全过程管理，进一步推动云制造的研究。</p><h2 id="section-5">6</h2><h3 id="题目云制造资源虚拟化研究">题目：云制造资源虚拟化研究</h3><h3 id="笔记-4">笔记：</h3><p>CPS是一个综合计算、网络和物理环境的复杂系统，通过3C技术(计算(Computation)、通信(Communication)和控制(Control))的融合，实现物理世界与虚拟世界的相互作用，提供实时感知、动态控制和信息反馈等服务.物联网侧重于物与物之间的互联以达到世界万物的联通与感知，例如对于物流物品的跟踪监控；而CPS在物与物互联与感知的基础上，则更侧重于对物的反馈控制，实现人、机、物的融合与协作。</p><h3 id="总结-5">总结：</h3><p>本文在云制造基础上提出了云制造资源虚拟化的框架，主要分为制造资源、物联网／CPS基础设施、物理资源历、虚拟资源云池以及虚拟资源管理这五个层次。其中制造资源又分为硬制造资源和软制造资源，硬制造资源可在云计算概念下被虚拟化；虚拟资源云池建立物理（物理资源历）与虚拟制造资源之间的映射关系。在虚拟化支持下的云制造关键技术包括资源的智能感知与控制、服务环境的按需动态构建、动态调度、环境的高可靠协同运行与容错迁移、人机交互、及多级安全隔离和访问控制。云制造资源虚拟化可以使软硬资源共享更加全面深入，提高效率和安全性，实现节能降耗。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>helloworld</title>
      <link href="/2022/01/24/helloworld/"/>
      <url>/2022/01/24/helloworld/</url>
      
        <content type="html"><![CDATA[<h1 id="yblog-的诞生">Yblog 的诞生</h1><h3 id="一-拥有自己的github-page">一 拥有自己的github page</h3><ol type="1"><li>拥有一个github账号（并牢牢记住用户名和密码！！！）。</li><li>点击右上角加号，再点击new repository。 <img src="01/24/helloworld/image-20220124203950430.png" class title="image-20220124203950430"></li><li>Repository name设为用户名.github.io，勾选Add a READMEfile，点击创建。 <img src="01/24/helloworld/image-20220124204325686.png" class title="image-20220124204325686"></li></ol><h3 id="二-安装node.js">二 安装Node.js</h3><p>安装选项全部默认。 测试：cmd中输入node -v和npm -v，出现版本号。</p><h3 id="三-安装git">三 安装Git</h3><p>安装选项全部默认。 测试：cmd中输入git --version，出现版本号。</p><h3 id="四-安装hexo">四 安装hexo</h3><ol type="1"><li>在合适的地方新建一个文件夹，用来存放自己的博客文件。</li><li>在新建的文件夹中右键，选择Git Bash Here，打开git的控制台窗口</li><li>输入npm i hexo-cli -g，安装hexo <img src="01/24/helloworld/image-20220124204809173.png" class title="image-20220124204809173"> 测试：输入hexo-v，出现版本号。</li><li>初始化：输入hexo init初始化文件夹，接着输入npminstall安装必备的组件。</li></ol><h3 id="五-关联github和本地">五 关联github和本地</h3><ol type="1"><li>在git bash中输入git config --global user.name "用户名"</li><li>输入git config --global user.email "邮箱"</li><li>生成密钥SSH key：ssh-keygen -t rsa -C "邮箱 &lt;一张不能对外显示的图片 &gt; 此时我们获得了一个很可爱的小方盒子。</li></ol><p>&lt; 一段不能对外显示的字符串 &gt;</p><ol start="4" type="1"><li>输入cat ~/.ssh/id_rsa.pub，将输出复制出来：</li></ol><p>&lt; 一段不能对外显示的字符串 &gt;</p><ol start="5" type="1"><li><p>打开github网页，点击自己的头像找到settings，然后找到SSH and GPGkeys一栏，新建一个sshkey。把第4步复制出来的key粘贴到下面的key文本框中，title随便起一个就行。<img src="01/24/helloworld/image-20220124205724033.png" class title="image-20220124205724033"></p></li><li><p>测试：输入ssh -T git@github.com。 <img src="01/24/helloworld/image-20220124205918174.png" class title="image-20220124205918174"></p></li><li><p>打开博客根目录下的_config.yml 修改并扩充最后一行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/用户名/用户名.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p></li><li><p>修改/scaffolds/post.md中内容为 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">top: false</span><br><span class="line">cover: false</span><br><span class="line">password:</span><br><span class="line">toc: true</span><br><span class="line">mathjax: true</span><br><span class="line">summary:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br></pre></td></tr></table></figure></p></li><li><p>由于这个博客用的是master这个branch，于是在项目页面下找到settings<img src="01/24/helloworld/image-20220124210633409.png" class title="image-20220124210633409"> 然后就在options中使劲往下划，直到看到github pages的条目：<img src="01/24/helloworld/image-20220124210744886.png" class title="image-20220124210744886"> 点击check it outhere，修改sourse，并点击save。<img src="01/24/helloworld/image-20220124210907304.png" class title="image-20220124210907304"></p></li></ol><h3 id="六-发布文章">六 发布文章！</h3><p>终于到这里了！ 1. 在根目录下打开git bash，输入npm ihexo-deployer-git。 2. 新建文章：hexo new post "helloword" 3.在/source/_post/ 目录下可以找到helloword.md 4.这种时候用什么编辑都行了。 5. 生成静态网页：hexo g 6. 本地预览：hexo s7. 上传github：hexo d</p><h3 id="七-美化">七 美化</h3><p>建议直接搜索hexo theme，任君挑选。 我使用了https://github.com/jerryc127/hexo-theme-butterfly这个主题，<del>（butterfly就是辉人啊！）</del>，通过阅读他给出的readme.md即完成了配置。1. 在博客根目录打开git base，输入npm i hexo-theme-butterfly 2.打开博客根目录下的_config.yml，找到里面的theme这一句，没记错的话在很靠下的地方，改成：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure></p><ol start="3" type="1"><li>其实不需要这一步，但万一第二步失败了可以尝试。（这只蒟蒻是因为太心急了，还没刷新出来就以为失败了所以多做了一步）输入npminstall hexo-renderer-pug hexo-renderer-stylus即可。</li></ol><p><strong>完美！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/24/hello-world/"/>
      <url>/2022/01/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
